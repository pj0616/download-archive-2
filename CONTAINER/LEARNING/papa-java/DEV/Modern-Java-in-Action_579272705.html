<!DOCTYPE html>
<html>
    <head>
        <title>DevOps : Modern Java in Action</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">DevOps</a></span>
                            </li>
                                                    <li>
                                <span><a href="DevOps-Home_603226548.html">DevOps Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Learn_522715137.html">Learn</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            DevOps : Modern Java in Action
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Nicholas Guner</span>, last modified on Aug 09, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="ModernJavainAction-PassingCodewithBehaviorParameterization">Passing Code with Behavior Parameterization</h1><h3 id="ModernJavainAction-Consideraninterface">Consider an interface</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface ApplePredicate 
{  
    boolean test (Apple apple);
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-Functionsthattakeaninterface">Functions that take an interface</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Apple&gt; filterApples(List&lt;Apple&gt; inventory,  ApplePredicate predicate)
{
    List&lt;Apple&gt; result = new ArrayList&lt;&gt;();
    for(Apple apple : inventory)
    {
        if(predicate.test(apple))
        {
            result.add(apple);
        }
    }
    return result;
}</pre>
</div></div></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p)
{
  List&lt;T&gt; result = new ArrayList&lt;&gt;();
  for(T t : list)
  {
    if(p.test(t))
    {
        result.add(t);
    }
  }
  return result;
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-Callfunctionthattakesapredicate">Call function that takes a predicate</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Using anonymous class</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Apple&gt; redApples = filterApples(inventory, new ApplePredicate()
{
    public boolean test(Apple apple)
    {
        return &quot;red&quot;.equals(apple.getColor());
    }
});</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><strong>Using a lambda</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Apple&gt; redApples = filterApples(inventory, (Apple apple) -&gt; 
                   &quot;red&quot;.equals(apple.getColor());</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-Sort">Sort</h3><p>Consider an interface:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface Comparator&lt;T&gt; 
{
  int compare(T o1, T o2);
}</pre>
</div></div><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Using a comparator</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">inventory.sort(new Comparator&lt;Apple&gt;()
{
    public int compare(Apple a1, Apple a2)
    {
        return a1.getWeight().compareTo(a2.getWeight());
    }
});</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><strong>Using a lambda</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">inventory.sort((a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-CreateaThread">Create a Thread</h3><p>Consider an interface:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface Runnable {
  void run();
}</pre>
</div></div><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Using anonymous class</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Thread t = new Thread(new Runnable()
{
    public void run()
    {
        System.out.println(&quot;Hello world&quot;);
    }
});</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><strong>Using a lambda</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Thread t = new Thread(() -&gt; System.out.println(&quot;Hello world&quot;));</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-CreateaCallable">Create a Callable</h3><p>Consider an interface:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface Callable&lt;V&gt; {
  V call();
}</pre>
</div></div><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Using anonymous class</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">ExecutorService executorService = Executors.newCachedThreadPool();
Future&lt;String&gt; threadName = executorService.submit(new Callable&lt;String&gt;() {
@Override
  public String call() throws Exception {
    return Thread.currentThread().getName();
  }
});</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><strong>Using a lambda</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Future&lt;String&gt; threadName = executorService.submit(() -&gt; Thread.currentThread().getName());</pre>
</div></div></td></tr></tbody></table></div><h1 id="ModernJavainAction-LambdaExpressions">Lambda Expressions</h1><p>You can use a lambda expression in the context of a functional interface which is an interface that specifies only one abstract method, for example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface Predicate&lt;T&gt;
{
    boolean test (T t);
}</pre>
</div></div><p>Lambda expressions let you provide the implementation of the abstract method of a functional interface directly inline and treat the whole expression as an instance of a functional interface (more technically speaking, an instance of a concrete implementation of the functional interface).</p><h3 id="ModernJavainAction-CommonfunctionalinterfacesinJava8">Common functional interfaces in Java 8</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Interface</p></th><th class="confluenceTh"><p>Descriptor</p></th><th class="confluenceTh"><p>Primitive specializations</p></th></tr><tr><td class="confluenceTd"><p><code>Predicate&lt;T&gt;</code></p></td><td class="confluenceTd"><p><code>T -&gt; boolean</code></p></td><td class="confluenceTd"><p><code>IntPredicate, LongPredicate, DoublePredicate</code></p></td></tr><tr><td class="confluenceTd"><p><code>Consumer&lt;T&gt;</code></p></td><td class="confluenceTd"><p><code>T -&gt; void</code></p></td><td class="confluenceTd"><p><code>IntConsumer, LongConsumer, DoubleConsumer</code></p></td></tr><tr><td class="confluenceTd"><p><code>Function&lt;T,R&gt;</code></p></td><td class="confluenceTd"><p><code>T -&gt; R</code></p></td><td class="confluenceTd"><p><code>IntFunction&lt;R&gt;, IntToDoubleFunction, IntToLongFunction, LongFunction&lt;R&gt;, LongToDoubleFunction, LongToIntFunction, DoubleFunction&lt;R&gt;,  ToIntFunction&lt;T&gt;, ToDoubleFunction&lt;T&gt;, ToLongFunction&lt;T&gt;</code></p></td></tr><tr><td class="confluenceTd"><p><code>Supplier&lt;T&gt;</code></p></td><td class="confluenceTd"><p><code>() -&gt; T</code></p></td><td class="confluenceTd"><p><code>BooleanSupplier, IntSupplier, LongSupplier, DoubleSupplier</code></p></td></tr><tr><td class="confluenceTd"><p><code>UnaryOperator&lt;T&gt;</code></p></td><td class="confluenceTd"><p><code>T -&gt; T</code></p></td><td class="confluenceTd"><p><code>IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator</code></p></td></tr><tr><td class="confluenceTd"><p><code>BinaryOperator&lt;T&gt;</code></p></td><td class="confluenceTd"><p><code>(T,T) -&gt; T</code></p></td><td class="confluenceTd"><p><code>IntBinaryOperator, LongBinaryOperator, DoubleBinaryOperator</code></p></td></tr><tr><td class="confluenceTd"><p><code>BiPredicate&lt;L,R&gt;</code></p></td><td class="confluenceTd"><p><code>(L,R) -&gt; boolean</code></p></td><td class="confluenceTd"><p /></td></tr><tr><td class="confluenceTd"><p><code>BiConsumer&lt;T,U&gt;</code></p></td><td class="confluenceTd"><p><code>(T,U) -&gt; void</code></p></td><td class="confluenceTd"><p><code>ObjIntConsumer&lt;T&gt;, ObjLongConsumer&lt;T&gt;, ObjDoubleConsumer&lt;T&gt;</code></p></td></tr><tr><td class="confluenceTd"><p><code>BiFunction&lt;T,U,R&gt;</code></p></td><td class="confluenceTd"><p><code>(T,U) -&gt; R</code></p></td><td class="confluenceTd"><p><code>ToIntBiFunction&lt;T, U&gt;, ToLongBiFunction&lt;T, U&gt;, ToDoubleBiFunction&lt;T,U&gt;</code></p></td></tr></tbody></table></div><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><strong>Consumer</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@FunctionalInterface
public interface Consumer&lt;T&gt;
{
    void accept(T t);
}</pre>
</div></div></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c)
{
    for(T t : list)
    {
        c.accept(t);
    }
}</pre>
</div></div></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">forEach(Arrays.asList(1,2,3,4,5), i -&gt; System.out.println(i));</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><strong>Function</strong></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@FunctionalInterface
public interface Function&lt;T,R&gt;
{
    R apply(T t);
}</pre>
</div></div></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static &lt;T&gt; void map(List&lt;T&gt; list, Function&lt;T,R&gt; f)
{
    List&lt;R&gt; result = new ArrayList&lt;&gt;();
    for(T s : list)
    {
        result.add(f.apply(s));
    }
    return result;
}</pre>
</div></div></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Integer&gt; l = map(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;threee&quot;), s -&gt; s.length());</pre>
</div></div></td></tr></tbody></table></div><p>Note that none of the functional interfaces allow for a checked exception to be thrown. You have two options if you need a lambda expression to throw an exception: define your own functional interface that declares the checked exception, or wrap the lambda with a <code>try/catch</code> block.</p><p>But you may be using an API that expects a functional interface such as <code>Function&lt;T, R&gt;</code> and there’s no option to create your own. In this case you can explicitly catch the checked exception</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Function&lt;BufferedReader, String&gt; f = (BufferedReader b) -&gt; 
{
    try
    {
      return b.readLine();
    }
    catch(IOException e)
    {
      throw new RuntimeException(e);
    }
};</pre>
</div></div><p>Restrictions on local variables. There’s a key difference in how instance and local variables are implemented behind the scenes. Instance variables are stored on the heap, whereas local variables live on the stack. If a lambda could access the local variable directly and the lambda were used in a thread, then the thread using the lambda could try to access the variable after the thread that allocated the variable had deallocated it. Hence, Java implements access to a free local variable as access to a copy of it rather than access to the original variable. This makes no difference if the local variable is assigned to only once—hence the restriction.</p><h3 id="ModernJavainAction-MethodReferences">Method References</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>inventory.sort((Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()));</code></p></td></tr><tr><td class="confluenceTd"><p><code>inventory.sort(comparing(Apple::getWeight);</code></p></td></tr></tbody></table></div><p><code>Comparator </code>has a static helper method called <code>comparing </code>that takes a <code>Function </code>extracting a Comparable key and produces a <code>Comparator </code>object.</p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Lambda</p></th><th class="confluenceTh"><p>Method reference equivalent</p></th></tr><tr><td class="confluenceTd"><p><code>(Apple a) -&gt; a.getWeight()</code></p></td><td class="confluenceTd"><p><code>Apple::getWeight</code></p></td></tr><tr><td class="confluenceTd"><p><code>() -&gt; Thread.currentThread().dumpStack()</code></p></td><td class="confluenceTd"><p><code>Thread.currentThread()::dumpStack</code></p></td></tr><tr><td class="confluenceTd"><p><code>(str, i) -&gt; str.substring(i)</code></p></td><td class="confluenceTd"><p><code>String::substring</code></p></td></tr><tr><td class="confluenceTd"><p><code>(String s) -&gt; System.out.println(s)</code></p></td><td class="confluenceTd"><p><code>System.out::println</code></p></td></tr></tbody></table></div><p>There are three main kinds of method references:</p><ol><li><p>A method reference to a static method</p></li><li><p>A method reference to an instance method of an arbitrary type</p></li><li><p>A method reference to an instance method of an existing object</p></li></ol><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 409.0px;"/><col style="width: 351.0px;"/></colgroup><tbody><tr><td colspan="2" class="confluenceTd"><p><code>List&lt;String&gt; list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;A&quot;,&quot;B&quot;);</code></p></td></tr><tr><td class="confluenceTd"><p><code>list.sort((s1, s2) -&gt; s1.compareToIgnoreCase(s2));</code></p></td><td class="confluenceTd"><p><code>list.sort(String::compareToIgnoreCase);</code></p></td></tr></tbody></table></div><h3 id="ModernJavainAction-Constructorreferences">Constructor references</h3><p>You can create a reference to an existing constructor using its name and the keyword new as follows: <code>ClassName::new</code>.</p><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 404.0px;"/><col style="width: 555.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p><code>Supplier&lt;Apple&gt; c1 = Apple::new;</code></p></td><td class="confluenceTd"><p><code>Supplier&lt;Apple&gt; c1 = () -&gt; new Apple();</code></p></td></tr><tr><td colspan="2" class="confluenceTd"><p><code>Apple a1 = c1.get();</code></p></td></tr><tr><td class="confluenceTd"><p><code>Function&lt;Integer,Apple&gt; c2 = Apple::new;</code></p></td><td class="confluenceTd"><p><code>Function&lt;Integer,Apple&gt; c2 = (weight) -&gt; new Apple(weight);</code></p></td></tr><tr><td colspan="2" class="confluenceTd"><p><code>Apple a2 = c2.apply(110);</code></p></td></tr><tr><td colspan="2" class="confluenceTd"><p><code>ByFunction&lt;String,Integer,Apple&gt; c3 = Apple::new;</code></p><p><code>ByFunction&lt;String,Integer,Apple&gt; c3 = (color,weight) -&gt; new Apple(color, weight);</code></p></td></tr><tr><td colspan="2" class="confluenceTd"><p><code>Apple a3 = c32.apply(&quot;green&quot;, 110);</code></p></td></tr></tbody></table></div><p>You can use a Map to associate constructors with a string value:</p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">static Map&lt;String,Function&lt;Integer,Fruit&gt;&gt; map = new HashMap&lt;&gt;()
{{
      put(&quot;apple&quot;, Apple::new);
      put(&quot;orange&quot;, Orange::new);
      ...
}};</pre>
</div></div></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static Fruit giveMeFruit(String fruit, Integer weight)
{
  return map.get(fruit.toLowerCase()).apply(weight);
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-ComposingComparators">Composing Comparators</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 97.0px;"/><col style="width: 681.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>Reverse </strong></p></th><td class="confluenceTd"><p><code>inventory.sort(comparing(Apple::getWeight).reversed());</code></p></td></tr><tr><th class="confluenceTh"><p><strong>Chaining</strong></p></th><td class="confluenceTd"><p><code>inventory.sort(comparing(Apple::getWeight).thenComparing(Apple::getCountry);</code></p></td></tr><tr><th class="confluenceTh"><p><strong>Negation</strong></p></th><td class="confluenceTd"><p><code>Predicate&lt;Apple&gt; notRedApple = redApple.negate();</code></p></td></tr><tr><th class="confluenceTh"><p><strong>Combine</strong></p></th><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Predicate&lt;Apple&gt; redAndHeavy = redApple.and(a -&gt; a.getWeight() &gt; 150);
Predicate&lt;Apple&gt; redAndHeavyOrGreen = redApple
                          .and(a -&gt; a.getWeight() &gt; 150)
                          .or(a -&gt; &quot;green&quot;.equals(a.getColor()));</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-ComposingFunctions">Composing Functions</h3><p>The method andThen returns a function that first applies a given function to an input and then applies another function to the result of that application.</p><p>You can also use the method compose similarly to first apply the function given as argument to compose and then apply the function to the result.</p><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Function&lt;Integer,Integer&gt; f = x -&gt; x + 1;
Function&lt;Integer,Integer&gt; g = x -&gt; x * 2;
Function&lt;Integer,Integer&gt; h = f.andThen(g);
int result = h.apply(1); // == 4
</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Function&lt;Integer,Integer&gt; f = x -&gt; x + 1;
Function&lt;Integer,Integer&gt; g = x -&gt; x * 2;
Function&lt;Integer,Integer&gt; h = f.compose(g);
int result = h.apply(1); // == 3</pre>
</div></div></td></tr></tbody></table></div><h1 id="ModernJavainAction-Workingwithstreams">Working with streams</h1><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Return the names of dishes that are low in calories, sorted by number of calories:</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;String&gt; names = menu.stream().filter(d -&gt; d.getCalories() &lt; 400)
                                  .sorted(comparing(Dish::getCalories))
                                  .map(Dish::getName)
                                  .collect(Comparators.toList());</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p>Group dishes by type:</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type,List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType));</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p>Convert array to a stream</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">String[] arrayOfWords = {&quot;Goodbye&quot;, &quot;World&quot;};
Stream&lt;String&gt; streamOfwords = Arrays.stream(arrayOfWords);</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p>Return a list of all the unique characters for a list of words.</p><p>[&quot;Hello&quot;, &quot;World&quot;] -&gt;  [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;,&quot;W&quot;, &quot;r&quot;, &quot;d&quot;]</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;String&gt; uniqueChars = words.stream().map(w -&gt; w.split(&quot;&quot;)
                                .flatMap(Arrays::stream)
                                .distinct()
                                .collect(toList());</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p>Given two lists of numbers return all pairs of numbers:</p><p>[1, 2, 3] and a list [3, 4] ==&gt; [(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Integer&gt; numbers1 = Arrays.asList(1,2,3);
List&lt;Integer&gt; numbers2 = Arrays.asList(3,4);
List&lt;int[]&gt;pairs = numbers1.stream()
                           .flatMap(i -&gt; 
                               numbers2.stream().map(j -&gt; new int[]{ i,j }))
                           .collect(toList());</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p>Same as above only for pairs that are divisible by 3:</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">	List&lt;Integer&gt;numbers1 = Arrays.asList(1,2,3);
	List&lt;Integer&gt;numbers2 = Arrays.asList(3,4);
	List&lt;int[]&gt;pairs = numbers1.stream()
	                           .flatMap(i -&gt; 
	                               numbers2.stream().filter(j -&gt; (i + j) %3 == 0)
	                           .map(j -&gt; new int[]{ i,j }))
	                           .collect(toList());</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-Matching">Matching</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 65.0px;"/><col style="width: 693.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>any</strong></p></th><td class="confluenceTd"><p><code>menu.stream().anyMatch(Dish::isVegetarian)</code></p></td></tr><tr><th class="confluenceTh"><p><strong>all</strong></p></th><td class="confluenceTd"><p><code>menu.stream().allMatch(d -&gt; d.getCalories() &gt;= 1000)</code></p></td></tr><tr><th class="confluenceTh"><p><strong>none</strong></p></th><td class="confluenceTd"><p><code>menu.stream().noneMatch(d -&gt; d.getCalories() &gt;= 1000)</code></p></td></tr></tbody></table></div><h3 id="ModernJavainAction-Finding">Finding</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 78.0px;"/><col style="width: 680.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>any</strong></p></th><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Dish&gt; dish = menu.stream().filter(Dish::isVegetarian).findAny();
dish.ifPresent(d -&gt; System.out.println(d.getName());</pre>
</div></div></td></tr><tr><th class="confluenceTh"><p><strong>first</strong></p></th><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Integer&gt; nos = Arrays.asList(1, 2, 3, 4, 5);
Optional&lt;Integer&gt; firstDivBy3 = nos.stream().map(x -&gt; x * x)
                                            .filter(x -&gt; x % 3 == 0)
                                            .findFirst();</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-Reducing">Reducing</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 93.0px;"/><col style="width: 665.0px;"/></colgroup><tbody><tr><th class="confluenceTh"><p><strong>sum</strong></p></th><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int sum = numbers.stream().reduce(0, (a, b) -&gt; a + b);</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int sum = numbers.stream().reduce(0, Integer::sum);</pre>
</div></div></td></tr><tr><th class="confluenceTh"><p><strong>product</strong></p></th><td class="confluenceTd"><p><code>int product = numbers.stream().reduce(1, (a, b) -&gt; a * b);</code></p></td></tr><tr><th class="confluenceTh"><p><strong>max</strong></p></th><td class="confluenceTd"><p><code>Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</code></p></td></tr><tr><th class="confluenceTh"><p><strong>min</strong></p></th><td class="confluenceTd"><p><code>Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);</code></p></td></tr><tr><th class="confluenceTh"><p><strong>count</strong></p></th><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int count = menu.stream().map(d -&gt; 1).reduce(0, (a, b) -&gt; a + b);</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">long count = menu.stream().count();</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-NumericStreams">Numeric Streams</h3><ol><li><p>Can't use <code>sum </code>method on <code>Stream&lt;T&gt;</code></p></li><li><p>Three primitive specialized stream interfaces to tackle this issue: <code>IntStream</code>, <code>DoubleStream</code>, and <code>LongStream </code>that respectively specialize the elements of a stream to be int, long, and double—and thereby avoid hidden boxing costs.</p></li><li><p>Each of these interfaces brings new methods to perform common numeric reductions such as <code>sum </code>to calculate the sum of a numeric stream and <code>max </code>to find the maximum element.</p></li></ol><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Convert to numeric</p></td></tr><tr><td class="confluenceTd"><p><code>int totalCalories = menu.stream().mapToInt(Dish::getCalories).sum();</code></p></td></tr><tr><td class="confluenceTd"><p>Convert from numeric  to object stream</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream&lt;Integer&gt; stream = intStream.boxed();</pre>
</div></div></td></tr></tbody></table></div><p>If you want to calculate the maximum element in an <code>IntStream</code>, you need something different for a starting value than 0 since 0 is a wrong result.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();
int max = maxCalories.orElse(1);</pre>
</div></div><h4 id="ModernJavainAction-NumericRanges">Numeric Ranges</h4><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 130.0px;"/><col style="width: 628.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p>1 to 100 even</p></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">IntStream even = IntStream.rangedClosed(1,100).filter(n -&gt; n % 2 == 0);
System.out.println(even.count());</pre>
</div></div></td></tr></tbody></table></div><h4 id="ModernJavainAction-Pythagoreantriples">Pythagorean triples</h4><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream&lt;int[]&gt; pythagoreanTriples = IntStream.rangeClosed(1,100)
                                            .boxed()
                                            .flatMap(a -&gt; IntStream.rangeClosed(a, 100)
                                            .mapToObj(b -&gt; new int[]{a, b, (int)Math.sqrt(a * a + b * b)})
                                            .filter(t -&gt; t[2] %1 == 0));</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><code>pythagoreanTriples.limit(5).forEach(t -&gt; System.out.println(t[0] + &quot;, &quot; + t[1] + &quot;, &quot; + t[2]));</code></p></td></tr></tbody></table></div><h3 id="ModernJavainAction-StreamsfromValues">Streams from Values</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream&lt;String&gt; stream = Stream.of(&quot;Java8&quot;,&quot;Lambdas&quot;,&quot;In&quot;,&quot;Action&quot;);</pre>
</div></div><h3 id="ModernJavainAction-Emptystream">Empty stream</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream&lt;String&gt; emptyStream = Stream.empty();</pre>
</div></div><h3 id="ModernJavainAction-Streamfromarrays">Stream from arrays</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int [] numbers = { 2, 3, 6, 8, 11, 45};
int sum = Arrays.stream(numbers).sum();</pre>
</div></div><h3 id="ModernJavainAction-Streamsfromfiles">Streams from files</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">long uniqueWords = 0;
try(Stream&lt;String&gt; lines = Files.lines(Paths.get(&quot;data.txt&quot;), Charset.defaultCharset()))
{
    uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(&quot; &quot;))).distinct().count();
}
catch(IOException e)
{
}</pre>
</div></div><h3 id="ModernJavainAction-InfiniteStreams-Iterate">Infinite Streams - Iterate</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream.iterate(0, n -&gt; n + 2).limit(10).forEach(System.out::println);</pre>
</div></div><h4 id="ModernJavainAction-Generatethefirst20elementsoftheseriesofFibonaccituplesusingtheiteratemethod:(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21).">Generate the first 20 elements of the series of Fibonacci tuples using the iterate method: (0, 1), (1, 1), (1, 2), (2, 3), (3, 5), (5, 8), (8, 13), (13, 21).</h4><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream.iterate(new int[]{0, 1}, t -&gt; new int[]{ t[1], t[0] + t[1] })
                    .limit(20)
                    .forEach(t -&gt; System.out.println(&quot;(&quot; + t[0] + &quot;,&quot; + t[1] +&quot;)&quot;));</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream.iterate(new int[]{0, 1}, t -&gt; new int[]{ t[1], t[0] + t[1] })
       .limit(10).map(t -&gt; t[0])
       .forEach(System.out::println);</pre>
</div></div><h3 id="ModernJavainAction-InfiniteStreams-Generate">Infinite Streams - Generate</h3><p>Generate doesn’t apply successively a function on each new produced value. It takes a lambda of type <code>Supplier&lt;T&gt;</code> to provide new values.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream.generate(Math::random).limit(5).forEach(System.out::println);</pre>
</div></div><p>Generate Fibonacci tuples. It’s important to note that a supplier that’s stateful isn’t safe to use in parallel code.</p><p>What you need to do now is create an <code>IntSupplier </code>that maintains in its state the previous value in the series, so <code>getAsInt </code>can use it to calculate the next element. In addition, it can update the state of the <code>IntSupplier </code>for the next time it’s called</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">IntSupplier fib = new IntSupplier()
{
    private int previous = 0;
    private int current = 1;
    public int getAsInt()
    {
        int oldPrevious = this.previous;
        int nextValue = this.previous + this.current;
        this.previous = this.current;
        this.current = nextValue;
        return oldPrevious;
    }
};</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">IntStream.generate(fib).limit(10).forEach(System.out::println);</pre>
</div></div><h1 id="ModernJavainAction-Collectingdatawithstreams">Collecting data with streams</h1><h3 id="ModernJavainAction-Grouptransactionsbycurrency">Group transactions by currency</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = transactions.stream()
                   .collect(groupingBy(Transaction::getCurrency));</pre>
</div></div><h3 id="ModernJavainAction-Predefinedcollectors">Predefined collectors</h3><ol><li><p>Reducing and summarizing stream elements to a single value</p></li><li><p>Grouping elements</p></li><li><p>Partitioning elements</p></li></ol><h3 id="ModernJavainAction-Reducingandsummarizing">Reducing and summarizing</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><p>Counting</p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">long howManyDishes = menu.stream().count();</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">long howManyDishes = menu.stream().collect(Collectors.counting());</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><code>MaxBy </code>and <code>MinBy</code></p></td></tr><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Dish&gt; mostCalorieDish = menu.stream()
                  .collect(maxBy(comparingInt(Dish::getCalories)));</pre>
</div></div><p>Use max with numeric stream</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();</pre>
</div></div><p>Using reduce</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Integer&gt; max = menu.stream().mapToInt(Dish::getCalories).reduce(Integer::max);</pre>
</div></div></td></tr></tbody></table></div><h3 id="ModernJavainAction-Summarization">Summarization</h3><p>The Collectors class provides a specific factory method for summing: <code>Collectors.summingInt</code>. It accepts a function that maps an object into the int that has to be summed and returns a collector that, when passed to the usual collect method, performs the requested summarization</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int totalCalories = menu.stream().collect(summingInt(Dish::getCalories));</pre>
</div></div><p>Also available is a <code>Collectors.averagingInt</code>, to calculate the average of the same set of numeric values:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">double avgCalories = menu.stream().collect(averagingInt(Dish::getCalories));</pre>
</div></div><p>You can use the collector returned by the <code>summarizingInt</code> factory method.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">IntSummaryStatistics menuStatistics = menu.stream()
                                           .collect(summarizingInt(Dish::getCalories));</pre>
</div></div><h3 id="ModernJavainAction-JoiningStrings">Joining Strings</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">String shortMenu = menu.stream().map(Dish::getName).collect(joining());</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">String shortMenu = menu.stream().map(Dish::getName).collect(joining(&quot;, &quot;));</pre>
</div></div><h3 id="ModernJavainAction-Collectors.reducingfactorymethodisageneralization">Collectors.reducing factory method is a generalization</h3><p>Calculate the total calories in your menu using reduction</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, (i, j) -&gt; i + j));</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int totalCalories = menu.stream().collect(reducing(0, Dish::getCalories, Integer:sum);</pre>
</div></div><p>Find highest calorie dish using reduction</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Dish&gt; mostCalorieDish = menu.stream()
           .collect(reducing((d1, d2) -&gt; d1.getCalories() &gt; d2.getCalories() ? d1 : d2));</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Dish&gt; mostCalorieDish = menu.stream()
                                     .collect(maxBy(comparingInt(Dish::getCalories)));</pre>
</div></div><p>Counting using the reducing collector</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">int count = menu.stream().collect(reducing(0L, e -&gt; 1L, Long::sum);</pre>
</div></div><h3 id="ModernJavainAction-DifferencesbetweenthecollectandreducemethodsoftheStreaminterface">Differences between the collect and reduce methods of the Stream interface</h3><ol><li><p>Reduce method is meant to combine two values and produce a new one; it’s an immutable reduction.</p></li><li><p>Collect method is designed to mutate a container to accumulate the result it’s supposed to produce</p></li></ol><h2 id="ModernJavainAction-Grouping">Grouping</h2><p>Classify the dishes in the menu according to their type</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType = menu.stream().collect(groupingBy(Dish::getType));</pre>
</div></div><p>Create a set instead of a list</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Set&lt;Dish&gt;&gt; dishesByType = menu.stream()
                                             .collect(groupingBy(Dish::getType, toSet()));</pre>
</div></div><p>Classify using something more complex than a simple property accessor.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public enum CaloricLevel { DIET, NORMAL, FAT }</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream()
                      .collect(groupingBy(dish -&gt; {
                           if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;
                           else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;
                           else return CaloricLevel.FAT;
                       }));</pre>
</div></div><p>Count number of dishes in each subgroup</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream()
                                       .collect(groupingBy(Dish::getType, counting()));</pre>
</div></div><p>Sum the calories of all the dishes in the menu</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Integer&gt; totalCaloriesByType = menu.stream()
                  .collect(groupingBy(Dish::getType, summingInt(Dish::getCalories)));</pre>
</div></div><p>Most caloric dish by type</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType = menu.stream()
           .collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories))));</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Dish&gt; mostCaloricByType = menu.stream()
           .collect(groupingBy(Dish::getType, 
                collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get)));</pre>
</div></div><p>Which Caloric Levels are available in the menu for each type of Dish</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream().collect(
   groupingBy(Dish::getType, mapping( dish -&gt;
        { 
          if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;
          else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;
          else return CaloricLevel.FAT;
        }, toSet() )));</pre>
</div></div><p>Controlling what type of set is returned</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream().collect(
   groupingBy(Dish::getType, mapping( dish -&gt;
        { 
          if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;
          else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;
          else return CaloricLevel.FAT;
        }, toCollection(HashSet::new))));</pre>
</div></div><p>Multilevel grouping</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByCaloricLevel = 
          menu.stream().collect(groupingBy(Dish::getType,
                            groupingBy(dish -&gt; {
                               if (dish.getCalories() &lt;= 400) return CaloricLevel.DIET;
                               else if (dish.getCalories() &lt;= 700) return CaloricLevel.NORMAL;
                               else return CaloricLevel.FAT;
   })));</pre>
</div></div><h3 id="ModernJavainAction-Partitioning">Partitioning</h3><p>The fact that the partitioning function returns a <code>boolean </code>means the resulting grouping Map will have a Boolean as a key type and therefore there can be at most two different groups—one for true and one for false.</p><p>Partitioning the menu into vegetarian and non-vegetarian dishes</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Boolean,List&lt;Dish&gt;&gt; partitionedMenu = menu.stream()
                                               .collect(partitionBy(Dish::isVegetarian));</pre>
</div></div><p>Mutil-level partitioning and grouping</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Boolean,Map&lt;Dish.Type,List&lt;Dish&gt;&gt;&gt; partitionedMenu = menu.stream()
                       .collect(partitionBy(Dish::isVegetarian, groupingBy(Dish::getType)));</pre>
</div></div><p>Find the most caloric dish among both vegetarian and non-vegetarian dishes</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian = menu.stream().collect(
                      partitioningBy(Dish::isVegetarian, collectingAndThen(
                                    maxBy(comparingInt(Dish::getCalories)), Optional::get)));</pre>
</div></div><p>Partitioning numbers into prime and non-prime</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public boolean isPrime(int candidate)
{
  int candidateRoot = (int) Math.sqrt((double) candidate);  
  return IntStream.range(2, candidateRoot).noneMatch(i -&gt; candidate % i == 0);  
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimes(int n)
{
  return IntStream.rangeClosed(2, n).boxed()
                               .collect(partitioningBy(candidate -&gt; isPrime(candidate)));
}</pre>
</div></div><h3 id="ModernJavainAction-TheCollectorinterface">The Collector interface</h3><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface Collector&lt;T, A, R&gt; 
{
    Supplier&lt;A&gt; supplier();
    BiConsumer&lt;A, T&gt; accumulator();
    Function&lt;A, R&gt; finisher();
    BinaryOperator&lt;A&gt; combiner();
    Set&lt;Characteristics&gt; characteristics();
}</pre>
</div></div><p>Example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;</pre>
</div></div><p>The supplier method has to return a <code>Supplier </code>of an empty result—a parameter-less function that when invoked creates an instance of an empty accumulator used during the collection process.  In our <code>ToListCollector </code>the supplier</p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Supplier&lt;List&lt;T&gt;&gt; supplier() 
{
  return () -&gt; new ArrayList&lt;T&gt;();
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Supplier&lt;List&lt;T&gt;&gt; supplier()
{
  return ArrayList::new;
}</pre>
</div></div></td></tr></tbody></table></div><p>The accumulator method returns the function that performs the reduction operation. The function returns void because the accumulator is modified in place, meaning that its internal state is changed by the function application to reflect the effect of the traversed element. For <code>ToListCollector</code>, this function merely has to add the current item to the list containing the already traversed ones</p><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator()
{
    return (list, item) -&gt; list.add(item);
}</pre>
</div></div></td><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() 
{
    return List::add;
}</pre>
</div></div></td></tr></tbody></table></div><p>The finisher method has to return a function that’s invoked at the end of the accumulation process, after having completely traversed the stream, in order to transform the accumulator object into the final result of the whole collection operation.  Often, as in the case of the <code>ToListCollector</code>, the accumulator object already coincides with the final expected result. As a consequence, there’s no need to perform a transformation, so the finisher method just has to return the identity function</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() 
{
    return Function.identity();
}</pre>
</div></div><p>The combiner method defines how the accumulators resulting from the reduction of different subparts of the stream are combined when the subparts are processed in parallel.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public BinaryOperator&lt;List&lt;T&gt;&gt; combiner() 
{
    return (list1, list2) -&gt; {
      list1.addAll(list2);
      return list1; 
    }
}</pre>
</div></div><p>Parallelizing the reduction process using the combiner method</p><ol><li><p>The original stream is recursively split in substreams until a condition defining whether a stream needs to be further divided becomes false.</p></li><li><p>At this point all substreams can be processed in parallel, each of them using the sequential reduction algorithm.</p></li><li><p>Finally, all the partial results are combined pairwise using the function returned by the combiner method of the collector.</p></li></ol><p>Characteristics, returns an immutable set of Characteristics, defining the behavior of the collector -  in particular providing hints about whether the stream can be reduced in parallel and which optimizations are valid when doing so. Characteristics is an enumeration containing three items:</p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 145.0px;"/><col style="width: 613.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p>UNORDERED</p></td><td class="confluenceTd"><p>The result of the reduction isn’t affected by the order in which the items in the stream are traversed and accumulated</p></td></tr><tr><td class="confluenceTd"><p>CONCURRENT</p></td><td class="confluenceTd"><p>The accumulator function can be called concurrently from multiple threads, and then this collector can perform a parallel reduction of the stream. If the collector isn’t also flagged as UNORDERED, it can perform a parallel reduction only when it’s applied to an unordered data source</p></td></tr><tr><td class="confluenceTd"><p>IDENTITY_FINISH</p></td><td class="confluenceTd"><p>This indicates the function returned by the finisher method is the identity one, and its application can be omitted. In this case, the accumulator object is directly used as the final result of the reduction process. This also implies that it’s safe to do an unchecked cast from the accumulator A to the result R.</p></td></tr></tbody></table></div><p>Putting it all together:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class ToListCollector&lt;T&gt; implements Collector&lt;T, List&lt;T&gt;, List&lt;T&gt;&gt;
{
  @Override
  public Supplier&lt;List&lt;T&gt;&gt; supplier()
  {
    return ArrayList::new;
  }
  @Override
  public BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() 
  {
    return List::add;
  }
  @Override
  public Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() 
  {
    return Function.identity();
  }
  @Override
  public BinaryOperator&lt;List&lt;T&gt;&gt; combiner() 
  {
    return (list1, list2) -&gt; {
        list1.addAll(list2);
        return list1; 
    }
  }
  @Override
  public Set&lt;Charecteristics&gt; characteristics()
  {
    return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, CONCURRENT));
  }
}</pre>
</div></div><p>Performing a custom collect without creating a Collector implementation. In the case of an IDENTITY_FINISH collection operation, there’s a further possibility of obtaining the same result without developing a completely new implementation of the Collector interface.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Dish&gt; dishes = menuStream.collect(ArrayList::new, List::add, List::addAll);</pre>
</div></div><h3 id="ModernJavainAction-Developingyourowncollectorforbetterperformance-Divideonlybyprimenumbers.">Developing your own collector for better performance - Divide only by prime numbers.</h3><p>The problem with the predefined collectors is that during the collecting process you don’t have access to the partial result.  Suppose you had this list; you could pass it to the <code>isPrime </code>method and rewrite it as follows</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static boolean isPrime(List&lt;Integer&gt; primes, int candidate) 
{
    return primes.stream().noneMatch(i -&gt; candidate % i == 0);
}</pre>
</div></div><p>So you need a way to stop testing whether the candidate is divisible by a prime as soon as the next prime is greater than the candidate’s root. Create a method called <code>takeWhile</code>, which, given a sorted list and a predicate, returns the longest prefix of this list whose elements satisfy the predicate:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static &lt;A&gt; &lt;List&lt;A&gt; takeWhile(List&lt;A&gt; list, Predicate&lt;A&gt; p)
{
    int i = 0;
    for(A item : list)
    {
        if(!p.test(item)
        {
            return list.subList(0, i);
        }
        i++;
    }
    return list;
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static boolean isPrime(List&lt;Integer&gt; primes, int candidate)
{
    int candidateRoot = (int) Math.sqrt((double) candidate);
    return takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream()
                                                     .noneMatch(p -&gt; candidate % p == 0);
}</pre>
</div></div><p>Class signature</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class PrimeNumbersCollector implements 
                 Collector&lt;Integer, Map&lt;Boolean,List&lt;Integer&gt;&gt;, Map&lt;Boolean,List&lt;Integer&gt;&gt;&gt;</pre>
</div></div><p>Supplier</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Supplier&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; supplier() 
{
    return () -&gt; new HashMap&lt;Boolean, List&lt;Integer&gt;&gt;()
    {{
        put(true, new ArrayList&lt;Integer&gt;());
        put(false, new ArrayList&lt;Integer&gt;());
    }};
}</pre>
</div></div><p>Accumulator</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public BiConsumer&lt;Map&lt;Boolean,List&lt;Integer&gt;&gt;, Integer&gt; accumulator()
{
    return (Map&lt;Boolean,List&lt;Integer&gt;&gt; acc, Integer candidate) -&gt; {
      acc.get( isPrime(acc.get(true), candidate) ).add(candidate);
    };
}</pre>
</div></div><p>Making collector work in parallel, if possible.</p><p>Note that in reality this collector can’t be used in parallel, because the algorithm is inherently sequential. This means the combiner method won’t ever be invoked, and you could leave its implementation empty</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public BinaryOperator&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; combiner()
{
    return (Map&lt;Boolean, List&lt;Integer&gt;&gt; map1, Map&lt;Boolean, List&lt;Integer&gt;&gt; map2) -&gt; {
        map1.get(true).addAll(map2.get(true));
        map1.get(false).addAll(map2.get(false);
        return map1;
    };
}</pre>
</div></div><p>The finisher.  The accumulator coincides with the collector’s result so it won’t need any further transformation, and the finisher method returns the identity function:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Function&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; finisher() 
{
    return Function.identity();
}</pre>
</div></div><p>For the characteristic</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Set&lt;Characteristics&gt; characteristics()
{
    return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH));
}</pre>
</div></div><p>Putting it together</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class PrimeNumbersCollector 
    implements Collector&lt;Integer, Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt;
{
  public static List&lt;Integer&gt; takeWhile(List&lt;Integer&gt; list, Predicate&lt;A&gt; p)
  {
      int i = 0;
      for(int item : list)
      {
          if(!p.test(item)
          {
              return list.subList(0, i);
          }
          i++;
      }
      return list;
  }

  public static boolean isPrime(List&lt;Integer&gt; primes, int candidate)
  {
      int candidateRoot = (int) Math.sqrt((double) candidate);
      return takeWhile(primes, i -&gt; i &lt;= candidateRoot).stream()
                                                .noneMatch(p -&gt; candidate % p == 0);
  }

  @Override
  public Supplier&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; supplier()
  {
      return () -&gt; new HashMap&lt;Boolean, List&lt;Integer&gt;&gt;()
      {{
         put(true, new ArrayList&lt;Integer&gt;());
         put(false, new ArrayList&lt;Integer&gt;());
      }};
  }
  
  @Override
  public BiConsumer&lt;Map&lt;Boolean,List&lt;Integer&gt;&gt;, Integer&gt; accumulator()
  {
      return (Map&lt;Boolean,List&lt;Integer&gt;&gt; acc, Integer candidate) -&gt; {
         acc.get( isPrime(acc.get(true), candidate) ).add(candidate);
    };
  }
  
  @Override
  public Function&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; finisher() 
  {
      return Function.identity();
  }
  
  @Override
  public BinaryOperator&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; combiner()
  {
      return (Map&lt;Boolean, List&lt;Integer&gt;&gt; map1, Map&lt;Boolean, List&lt;Integer&gt;&gt; map2) -&gt; {
          map1.get(true).addAll(map2.get(true));
          map1.get(false).addAll(map2.get(false);
          return map1;
      };
  }

  @Override
  public Set&lt;Charecteristics&gt; characteristics()
  {
      return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, CONCURRENT));
  }
}</pre>
</div></div><p>Usage</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimesWithCustomCollector(int n)
{
    return IntStream.rangeClosed(2, n).boxed().collect(new PrimeNumbersCollector());
}</pre>
</div></div><p>It’s possible to obtain the same result by passing the three functions implementing the core logic of <code>PrimeNumbersCollector </code>to the overloaded version of the collect method, taking them as arguments</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Map&lt;Boolean, List&lt;Integer&gt;&gt; partitionPrimesWithCustomCollector(int n)
{
    return IntStream.rangeClosed(2, n).boxed().collect(
        () -&gt; new HashMap&lt;Boolean, List&lt;Integer&gt;&gt;() {{
           put(true, new ArrayList&lt;Integer&gt;());
           put(false, new ArrayList&lt;Integer&gt;());
        }},
    (acc, candidate) -&gt; {
        acc.get(isPrime(acc.get(true), candidate)).add(candidate);
    },
    (map1, map2) -&gt; {
        map1.get(true).addAll(map2.get(true));
        map1.get(false).addAll(map2.get(false);
        return map1;
    });
}</pre>
</div></div><h1 id="ModernJavainAction-Paralleldataprocessingandperformance">Parallel data processing and performance</h1><p>Parallel streams internally use the default <code>ForkJoinPool </code>which by default has as many threads as you have processors, as returned by:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Runtime.getRuntime().availableProcessors()</pre>
</div></div><p>But you can change the size of this pool using the system property:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;12&quot;);</pre>
</div></div><h3 id="ModernJavainAction-Thefork/joinframework">The fork/join framework</h3><p>The fork/join framework was designed to recursively split a parallelizable task into smaller tasks and then combine the results of each subtask to produce the overall result.  It’s an implementation of the <code>ExecutorService </code>interface, which distributes those subtasks to worker threads in a thread pool, called <code>ForkJoinPool</code>.</p><p>To submit tasks to this pool, you have to create a subclass of <code>RecursiveTask&lt;R&gt;</code>, where R is the type of the result produced by the parallelized task (and each of its subtasks) or of <code>RecursiveAction </code>if the task returns no result.</p><p>To define <code>RecursiveTasks </code>you need only implement its single abstract method:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">protected abstract R compute();</pre>
</div></div><p>This method defines both the logic of splitting the task at hand into subtasks and the algorithm to produce the result of a single subtask when it’s no longer possible or convenient to further divide it.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">if (task is small enough or no longer divisible)
{
    compute task sequentially
} 
else
{
    split task in two subtasks
    call this method recursively possibly further splitting each subtask
    wait for the completion of all subtasks
    combine the results of each subtask
}</pre>
</div></div><p>Calculate the sum of a range of numbers (here represented by an array of numbers <code>long[]</code>) using this framework</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class ForkJoinSumCalculator extends RecursiveTask&lt;Long&gt;
{
  public static final long THRESHOLD = 10_000;

  private final long[] numbers;
  private final int start;
  private final int end;

  public ForkJoinSumCalculator(long[] numbers)
  {
    this(numbers, 0, numbers.length);
  }

  private ForkJoinSumCalculator(long[] numbers, int start, int end)
  {
    this.numbers = numbers;
    this.start = start;
    this.end = end;
  }

  @Override
  protected Long compute()
  {
    int length = end - start;
    if (length &lt;= THRESHOLD)
    {
      return computeSequentially();
    }
    ForkJoinSumCalculator leftTask = 
                    new ForkJoinSumCalculator(numbers, start, start + length / 2);
    leftTask.fork();
    ForkJoinSumCalculator rightTask = 
                    new ForkJoinSumCalculator(numbers, start + length / 2, end);
    Long rightResult = rightTask.compute();
    Long leftResult = leftTask.join();
    return leftResult + rightResult;
  }

  private long computeSequentially()
  {
    long sum = 0;
    for (int i = start; i &lt; end; i++)
    {
      sum += numbers[i];
    }
    return sum;
  }

  public static long forkJoinSum(long n)
  {
    long[] numbers = LongStream.rangeClosed(1, n).toArray();
    ForkJoinTask&lt;Long&gt; task = new ForkJoinSumCalculator(numbers);
    return new ForkJoinPool().invoke(task);
  }
}</pre>
</div></div><p style="margin-left: 30.0px;">Calling the fork method on a subtask is the way to schedule it on the <code>ForkJoinPool</code>. It might seem natural to invoke it on both the left and right subtasks, but this is less efficient than just directly calling compute on one of them. Doing this allows you to reuse the same thread for one of the two subtasks and avoid the overhead caused by the unnecessary allocation of a further task on the pool.</p><h3 id="ModernJavainAction-Spliterator">Spliterator</h3><p>There must be an automatic mechanism splitting the stream for you. This new automatic mechanism is called the <code>Spliterator</code>.</p><p><code>Spliterator </code>- Like Iterators, <code>Spliterators </code>are used to traverse the elements of a source, but they’re also designed to do this in parallel. Java 8 already provides a default <code>Spliterator </code>implementation for all the data structures included in its Collections Framework.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface Spliterator&lt;T&gt; 
{
    boolean tryAdvance(Consumer&lt;? super T&gt; action);
    Spliterator&lt;T&gt; trySplit();
    long estimateSize();
    int characteristics();
}</pre>
</div></div><p>The algorithm that splits a Stream into multiple parts is a recursive process. In the first step <code>trySplit </code>is invoked on the first <code>Spliterator </code>and generates a second one. Then in step 2 it’s called again on these two <code>Spliterators</code>, which results in a total of four. The framework keeps invoking the method <code>trySplit </code>on a <code>Spliterator </code>until it returns null to signal that the data structure that it’s processing is no longer divisible</p><p>The last abstract method declared by the <code>Spliterator </code>interface is characteristics, which returns an int encoding the set of characteristics of the <code>Spliterator </code>itself.</p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 122.0px;"/><col style="width: 636.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p>ORDERED</p></td><td class="confluenceTd"><p>Elements have a defined order (for example, a List), so the Spliterator enforces this order when traversing and partitioning them.</p></td></tr><tr><td class="confluenceTd"><p>DISTINCT</p></td><td class="confluenceTd"><p>For each pair of traversed elements x and y, x.equals(y) returns false.</p></td></tr><tr><td class="confluenceTd"><p>SORTED</p></td><td class="confluenceTd"><p> </p></td></tr><tr><td class="confluenceTd"><p>SIZED</p></td><td class="confluenceTd"><p>This Spliterator has been created from a source with a known size (for example, a Set), so the value returned by <code>estimatedSize()</code> is precise.</p></td></tr><tr><td class="confluenceTd"><p>NONNULL</p></td><td class="confluenceTd"><p>It’s guaranteed that the traversed elements won’t be null.</p></td></tr><tr><td class="confluenceTd"><p>IMMUTABLE</p></td><td class="confluenceTd"><p>The source of this Spliterator can’t be modified. This implies that no elements can be added, removed, or modified during their traversal.</p></td></tr><tr><td class="confluenceTd"><p>CONCURRENT</p></td><td class="confluenceTd"><p>The source of this Spliterator may be safely concurrently modified by other threads without any synchronization</p></td></tr><tr><td class="confluenceTd"><p>SUBSIZED</p></td><td class="confluenceTd"><p>Both this Spliterator and all further Spliterators resulting from its split are SIZED.</p></td></tr></tbody></table></div><h4 id="ModernJavainAction-ImplementingyourownSpliterator-developasimplemethodthatcountsthenumberofwordsinaString.">Implementing your own Spliterator - develop a simple method that counts the number of words in a String.</h4><p>Convert String to stream</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream&lt;Character&gt; stream = IntStream.range(0, SENTENCE.length()).mapToObj(SENTENCE::charAt);</pre>
</div></div><p>An immuable class to count words while traversing a stream of characters. The counter is incremented when a new nonspace is met and the last character encountered is a space</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">class WordCounter 
{
  private final int counter;
  private final boolean lastSpace;

  public WordCounter(int counter, boolean lastSpace)
  {
    this.counter = counter;
    this.lastSpace = lastSpace;
  }

  public WordCounter accumulate(Character c) 
  {
	if (Character.isWhitespace(c))
	{
	  return lastSpace ? this : new WordCounter(counter, true);
	}
	else
	{
	  return lastSpace ? new WordCounter(counter + 1, false) : this;
	}
  }

  public WordCounter combine(WordCounter wordCounter)
  {
    return new WordCounter(counter + wordCounter.counter, wordCounter.lastSpace);
  }

  public int getCounter()
  {
    return counter;
  }
}</pre>
</div></div><p style="margin-left: 30.0px;"><code>combine </code>is invoked to aggregate the partial results of two <code>WordCounters </code>operating on two different subparts of the stream of Characters</p><p>Reduce the stream of Characters</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">private int countWords(Stream&lt;Character&gt; stream) 
{
    WordCounter wordCounter = stream.reduce(new WordCounter(0, true), 
                                                WordCounter::accumulate, 
                                                WordCounter::combine);
    return wordCounter.getCounter();
}</pre>
</div></div><p>Try this method with the stream</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Stream&lt;Character&gt; stream = IntStream.range(0, SENTENCE.length()).mapToObj(SENTENCE::charAt);
System.out.println(&quot;Found &quot; + countWords(stream) + &quot; words&quot;);</pre>
</div></div><p>Making the <code>WordCounter </code>work in parallel.  The solution consists of ensuring that the String isn’t split at a random position but only at the end of a word. To do this, you’ll have to implement a <code>Spliterator </code>of Character that splits a String only between two words.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">private static class WordCounterSpliterator implements Spliterator&lt;Character&gt;
{
  private final String string;
  private int currentChar = 0;

  private WordCounterSpliterator(String string)
  {
    this.string = string;
  }

  @Override
  public boolean tryAdvance(Consumer&lt;? super Character&gt; action)
  {
    action.accept(string.charAt(currentChar++));  // consume the current character
    return currentChar &lt; string.length();
  }

  @Override
  public Spliterator&lt;Character&gt; trySplit()
  {
    int currentSize = string.length() - currentChar;
    if (currentSize &lt; 10)
    {
      return null;
    }
    for (int splitPos = currentSize / 2 + currentChar; 
                                 splitPos &lt; string.length(); splitPos++)
    {
      if(Character.isWhitespace(string.charAt(splitPos)))
	  {
        Spliterator&lt;Character&gt; spliterator = 
                   new WordCounterSpliterator(string.substring(currentChar, splitPos));
        currentChar = splitPos;
        return spliterator;
      }
    }
    return null;
  }

  @Override
  public long estimateSize()
  {
    return string.length() - currentChar;
  }

  @Override
  public int characteristics()
  {
    return ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;
  }
}</pre>
</div></div><p>Putting the <code>WordCounterSpliterator </code>to work</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Spliterator&lt;Character&gt; spliterator = new WordCounterSpliterator(SENTENCE);
Stream&lt;Character&gt; stream = StreamSupport.stream(spliterator, true);</pre>
</div></div><p>The second boolean argument passed to the <code>StreamSupport.stream</code> factory method means that you want to create a parallel stream.</p><p>Passing this parallel stream to the <code>countWords </code>method:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">System.out.println(&quot;Found &quot; + countWords(stream) + &quot; words&quot;);</pre>
</div></div><h1 id="ModernJavainAction-RefactoringTestingandDebugging">Refactoring Testing and Debugging</h1><p>Converting anonymous classes to lambda expressions can be a difficult process in certain situations.</p><ol><li><p>The meanings of <code>this </code>and <code>super </code>are different for anonymous classes and lambda expressions. Inside an anonymous class, this refers to the anonymous class itself, but inside a lambda it refers to the enclosing class.</p></li><li><p>Anonymous classes are allowed to shadow variables from the enclosing class. Lambda expressions can't</p></li><li><p>Converting an anonymous class to a lambda expression can make the resulting code ambiguous in the context of overloading.</p></li></ol><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static void doSomething(Task a){ r.execute(); }interface Task
{
    public void execute();
}</pre>
</div></div></td></tr><tr><td class="confluenceTd"><p><code>public static void doSomething(Runnable r){ r.run(); }</code></p></td></tr><tr><td class="confluenceTd"><p><code>public static void doSomething(Task a){ r.execute(); }</code></p></td></tr></tbody></table></div><p>You can now pass an anonymous class implementing Task without a problem:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">doSomething(new Task() 
{
    public void execute()
    {
       System.out.println(&quot;Danger danger!!&quot;);
    }
});</pre>
</div></div><p>But converting this anonymous class to a lambda expression results in an ambiguous method call, because both Runnable and Task are valid target types:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">doSomething(() -&gt; System.out.println(&quot;Danger danger!!&quot;));</pre>
</div></div><h3 id="ModernJavainAction-Conditionaldeferredexecution">Conditional deferred execution</h3><p>Consider:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">logger.log(Level.FINER, &quot;Problem: &quot; + generateDiagnostic());</pre>
</div></div><p>This method internally checks to see if the logger object is set to the right level before logging the message.</p><p>The <code>generateDiagnostic() </code>function is always evaluated, even if the logger isn’t enabled for the message level passed as argument</p><p>The alternative log method has the following signature:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public void log(Level level, Supplier&lt;String&gt; msgSupplier);</pre>
</div></div><p>which is called:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">logger.log(Level.FINER, () -&gt; &quot;Problem: &quot; + generateDiagnostic());</pre>
</div></div><p>which executes like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public void log(Level level, Supplier&lt;String&gt; mgSupplier)
{
    if(logger.isLoggable(level)
    {
       log(level, msgSupplier.get());
    }
}</pre>
</div></div><h3 id="ModernJavainAction-Debugginglambdas">Debugging lambdas</h3><p>Use <code>peek </code>to print the intermediate value before and after each operation in the stream pipeline</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Integer&gt; result = Stream.of(2, 3, 4, 5)
                .peek(x -&gt; System.out.println(&quot;taking from stream: &quot; + x)).map(x -&gt; x + 17)
                .peek(x -&gt; System.out.println(&quot;after map: &quot; + x)).filter(x -&gt; x % 2 == 0)
                .peek(x -&gt; System.out.println(&quot;after filter: &quot; + x)).limit(3)
                .peek(x -&gt; System.out.println(&quot;after limit: &quot; + x)).collect(toList());</pre>
</div></div><h1 id="ModernJavainAction-DefaultMethods">Default Methods</h1><p>First, Java 8 allows static methods inside interfaces. Second, Java 8 introduces a new feature called default methods that allows you to provide a default implementation for methods in an interface.</p><ol><li><p>A common pattern in Java is to define both an interface and a utility companion class defining many static methods for working with instances of the interface. For example, Collections is a companion class to deal with Collection objects. Now that static methods can exist inside interfaces, such utility classes in your code can go away and their static methods can be moved inside an interface.</p></li></ol><p>Different types of compatibilities: binary, source, and behavioral</p><ol><li><p>Binary compatibility means existing binaries running without errors continue to link (which involves verification, preparation, and resolution) without error after introducing a change. For example, just adding a method to an interface is binary compatible because if it’s not called,existing methods of the interface can still run without problems.</p></li><li><p>Source compatibility means an existing program will still compile after introducing a change. For example, adding a method to an interface isn’t source compatible; existing implementations won’t recompile because they need to implement the new method</p></li><li><p>Behavioral compatibility means running a program after a change with the same inputs results in the same behavior. For example, adding a method to an interface is behavioral compatible because the method is never called in the program (or it gets overridden by an implementation).</p></li></ol><p>There are three rules to follow when a class inherits a method with the same signature from multiple places (such as another class or interface):</p><ol><li><p>Classes always win. A method declaration in the class or a superclass takes priority over any default method declaration.</p></li><li><p>Otherwise, sub-interfaces win: the method with the same signature in the most specific default-providing interface is selected. (If B extends A, B is more specific than A).</p></li><li><p>Finally, if the choice is still ambiguous, the class inheriting from multiple interfaces has to explicitly select which default method implementation to use by overriding it and calling the desired method explicitly.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class C implements B, A
{
    void hello()
    {
        B.super.hello();
    }
}</pre>
</div></div></li></ol><h1 id="ModernJavainAction-Optional">Optional</h1><p>Redefining the Person/Car/Insurance data model using <code>Optional</code></p><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 391.0px;"/><col style="width: 578.0px;"/><col style="width: 600.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p /><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static class Insurance
{
  private String companyName;

  public Insurance(String name)
  {
	this.companyName = name;
  }
  public String getName()
  {
    return companyName;
  }
}</pre>
</div></div></td><td class="confluenceTd"><p /><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static class Car
{
  private String make;
  private Optional&lt;Insurance&gt; insurance;

  public Car(String make, Optional&lt;Insurance&gt; insurance)
  {
    this.make = make;
    this.insurance = insurance;
  }
  public Optional&lt;Insurance&gt; getInsurance()
  {
    return insurance;
  }
}
</pre>
</div></div></td><td class="confluenceTd"><p /><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static class Person
{
  private String name;
  private Optional&lt;Car&gt; car;

  public Person(String name, Optional&lt;Car&gt; car)
  {
    this.name = name;
    this.car = car;
  }
  
  public Optional&lt;Car&gt; getCar()
  {
    return car;
  }
}
</pre>
</div></div></td></tr></tbody></table></div><p /><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static void main(String[] args)
{
  Insurance insurance = new Insurance(&quot;Geico&quot;, 1000.0);
  Car carWithIns = new Car(&quot;ford&quot;, Optional.of(insurance));
  Car carNoIns = new Car(&quot;ford&quot;, Optional.empty());

  Optional&lt;Person&gt; optChild = Optional.of(new Person(&quot;small person&quot;, Optional.empty()));
  String insuranceName = optChild.flatMap(Person::getCar).flatMap(Car::getinsurance).map(Insurance::getName).orElse(&quot;none&quot;);
  Assert.assertEquals(&quot;none&quot;, insuranceName);

  Optional&lt;Person&gt; optBoy = Optional.of(new Person(&quot;medium person&quot;, Optional.of(carNoIns)));
  insuranceName = optBoy.flatMap(Person::getCar).flatMap(Car::getinsurance).map(Insurance::getName).orElse(&quot;none&quot;);
  Assert.assertEquals(&quot;none&quot;, insuranceName);

  Optional&lt;Person&gt; optMan = Optional.of(new Person(&quot;big person&quot;, Optional.of(carWithIns)));
  insuranceName = optMan.flatMap(Person::getCar).flatMap(Car::getinsurance).map(Insurance::getName).orElse(&quot;none&quot;);
  Assert.assertEquals(&quot;Geico&quot;, insuranceName);
}</pre>
</div></div><p>Creating Optional objects</p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 323.0px;"/><col style="width: 435.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p>Empty optional</p></td><td class="confluenceTd"><p><code>Optional&lt;Car&gt; optCar = Optional.empty();</code></p></td></tr><tr><td class="confluenceTd"><p>optional from a non-null value</p></td><td class="confluenceTd"><p><code>Optional&lt;Car&gt; optCar = Optional.of(car);</code></p></td></tr><tr><td class="confluenceTd"><p>Optional object that may hold a null value:</p></td><td class="confluenceTd"><p><code>Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</code></p></td></tr></tbody></table></div><h3 id="ModernJavainAction-ExtractingvaluefromOptional">Extracting value from <code>Optional</code></h3><p>with <code>map</code></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Insurance&gt; optInsurance = Optional.ofNullable(insurance);
Optional&lt;String&gt; name = optInsurance.map(Insurance::getName);</pre>
</div></div><p>with <code>flatMap</code></p><p>Code:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public String getCarInsuranceName(Person person)
{
    return person.getCar().getInsurance().getName();
}</pre>
</div></div><p><span style="color: rgb(255,86,48);">can't</span> be written as:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Person&gt; optPerson = Optional.of(person);
Optional&lt;String&gt; name = optPerson.map(Person::getCar)
                                 .map(Car::getInsurance).map(Insurance::getName);</pre>
</div></div><p>use this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public String getCarInsuranceName(Optional&lt;Person&gt; person)
{
  return person.flatMap(Person::getCar)
               .flatMap(Car::getInsurance)
               .map(Insurance::getName).orElse(&quot;Unknown&quot;);
}</pre>
</div></div><p>other methods:</p><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 442.0px;"/><col style="width: 518.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><p><code>get()</code></p></td><td class="confluenceTd"><p>Returns the wrapped value if present but throws a NoSuchElementException otherwise.</p></td></tr><tr><td class="confluenceTd"><p><code>orElse(T other)</code></p></td><td class="confluenceTd"><p>it allows you to provide a default value for when the optional doesn’t contain a value.</p></td></tr><tr><td class="confluenceTd"><p><code>orElseGet(Supplier&lt;? extends T&gt; other)</code></p></td><td class="confluenceTd"><p>the supplier is invoked only if the optional contains no value</p></td></tr><tr><td class="confluenceTd"><p><code>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></p></td><td class="confluenceTd"><p>is similar to the get method in that it throws an exception when the optional is empty, but in this case it allows you to choose the type of exception that you want to throw.</p></td></tr><tr><td class="confluenceTd"><p><code>ifPresent(Consumer&lt;? super T&gt; consumer)</code></p></td><td class="confluenceTd"><p>lets you execute the action given as argument if a value is present; otherwise no action is taken.</p></td></tr></tbody></table></div><h3 id="ModernJavainAction-CombiningtwoOptionals">Combining two Optionals</h3><p>We have a method to find cheapest insurance:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Insurance findCheapestInsurance(Person person, Car car)
{
  // some logic
    return cheapestCompany;
}</pre>
</div></div><p>Consider following code which is same as using <code>null </code>checks</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Optional&lt;Insurance&gt; nullSafeFindCheapestInsurance(Optional&lt;Person&gt; person, 
                                                         Optional&lt;Car&gt; car)
{
    if (person.isPresent() &amp;&amp; car.isPresent())
    {
        return Optional.of(findCheapestInsurance(person.get(), car.get()));
    }
    else
    {
        return Optional.empty();
    }
}</pre>
</div></div><p>You can implement that method in a single statement and without using any conditional constructs</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Optional&lt;Insurance&gt; nullSafeFindCheapestInsurance(Optional&lt;Person&gt; person, 
                                                         Optional&lt;Car&gt; car)
{
    return person.flatMap(p -&gt; car.map(c -&gt; findCheapestInsurance(p, c)));
}</pre>
</div></div><p>on the first <code>Optional</code>, if this is empty, the lambda expression passed to it won’t be executed at all and this invocation will just return an empty optional</p><h3 id="ModernJavainAction-Rejectingcertainvalueswithfilter">Rejecting certain values with filter</h3><p>The filter method takes a predicate as an argument. If a value is present in the <code>Optional </code>object and it matches the predicate, the filter method returns that value; otherwise, it returns an empty Optional object.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Optional&lt;Insurance&gt; optInsurance = ...;
optInsurance.filter(insurance -&gt; &quot;CambridgeInsurance&quot;.equals(insurance.getName()))
                                       .ifPresent(x -&gt; System.out.println(&quot;ok&quot;));</pre>
</div></div><p>Converting a <code>String </code>into an <code>Integer </code>returning an <code>Optional</code></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static Optional&lt;Integer&gt; stringToInt(String s)
{
    try
    {
        return Optional.of(Integer.parseInt(s));
    }
    catch(NumberFormatException e)
    {
        return Optional.Empty();
    }
}</pre>
</div></div><h1 id="ModernJavainAction-CompletableFuture">Completable Future</h1><p>What you really want to achieve is to avoid blocking a thread and wasting its computational resources while waiting, potentially for quite a while, for a result from a remote service or from interrogating a database.</p><p><code>Futures </code>limitations:</p><ol><li><p>Check if asynchronous computation is complete (using the <code>isDone </code>method), to wait for its completion</p></li><li><p>When the result of the long computation is available, please send its result to another long computation, and when that’s done, combine its result with the result from another query</p></li></ol><p>This is why more declarative features would be useful</p><ol><li><p>Combining two asynchronous computations in one—both when they’re independent and when the second depends on the result of the first</p></li><li><p>Waiting for the completion of all tasks performed by a set of Futures</p></li><li><p>Waiting for the completion of only the quickest task in a set of Futures (possibly because they’re trying to calculate the same value in different ways) and retrieving its result</p></li><li><p>Programmatically completing a Future (that is, by manually providing the result of the asynchronous operation)</p></li><li><p>Reacting to a Future completion (that is, being notified when the completion happens and then having the ability to perform a further action using the result of the Future, instead of being blocked waiting for its result)</p></li></ol><h3 id="ModernJavainAction-ImplementinganasynchronousAPI">Implementing an asynchronous API</h3><p>Shop declares a method that returns the price of a product given its name:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Shop 
{
    public double getPrice(String product) 
    {
        return calculatePrice(product);
    }
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">private double calculatePrice(String product)
{
    delay();
    return random.nextDouble() * product.charAt(0) + product.charAt(1);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public static void delay()
{
    try
    {
        Thread.sleep(1000L);
    }
    catch (InterruptedException e)
    {
       throw new RuntimeException(e);
    }
}</pre>
</div></div><p>Converting a synchronous method into an asynchronous one</p><ol><li><p>Change getPrice into a getPriceAsync method:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Future&lt;Double&gt; getPriceAsync(String product)
{
  CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();
  new Thread( () -&gt; {
     double price = calculatePrice(product);
     futurePrice.complete(price);
  }).start();
  return futurePrice;
}</pre>
</div></div></li><li><p>invoke this method</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Shop shop = new Shop(&quot;BestShop&quot;);
long start = System.nanoTime();
Future&lt;Double&gt; futurePrice = shop.getPriceAsync(&quot;my product&quot;);
long invokationTime = ((System.nanoTime - start) / 1000000);
System.out.println(&quot;Returned after &quot; + invokationTime  + &quot; msecs&quot;);

doSomethingElse();
try
{
  double.price = futurePrice.get();
  System.out.printf(&quot;Price is %.2f%n&quot;, price);
}
catch(Exception e)
{
  throw new RuntimeException(e);
}
long retrieveTime =  ((System.nanoTime - start) / 1000000);
System.out.println(&quot;Price returned after &quot; + retrieveTime + &quot; msecs&quot;);</pre>
</div></div></li><li><p>Dealing with errors. To make the client aware of the reason the shop wasn’t able to provide the price of the requested product, you have to propagate the Exception that caused the problem inside the <code>CompletableFuture </code>through its <code>completeExceptionally </code>method</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Future&lt;Double&gt; getPriceAsync(String product)
{
  CompetableFuture&lt;Double&gt; futurePrice = new CompetableFuture&lt;&gt;();
  new Thread( () -&gt; {
     try
     {     
       double price = calculatePrice(product);
       futurePrice.complete(price);
     }
     catch(Exception e)
     {
       futurePrice.completeExceptionally(ex);
     }
  {).start();
  return futurePrice;
}</pre>
</div></div><ol><li><p>The client will now be notified with an ExecutionException (which takes an Exception parameter containing the cause—the original Exception thrown by the price calculation method)</p></li></ol></li><li><p>Creating a <code>CompletableFuture </code>with the <code>supplyAsync </code>factory method</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Future&lt;Double&gt; getPriceAsync(String product)
{
  return CompletableFuture.supplyAsync( () -&gt; calculatePrice(product));
}</pre>
</div></div><ol><li><p>it’s possible to optionally pass an Executor to all other <code>CompletableFuture </code>factory methods</p></li></ol></li><li><p>Get prices from multiple shops synchronously</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;Shop&gt; shops = Arrays.asList(new Shop(&quot;BestPrice&quot;),
                                 new Shop(&quot;LetsSaveBig&quot;),
                                 new Shop(&quot;MyFavoriteShop&quot;),
                                 new Shop(&quot;BuyItAll&quot;));</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public List&lt;String&gt; findPrices(String product)
{
  return shops.stream()
      .map(shop -&gt; String.format(&quot;%s price is %.2f&quot;, 
                              shop.getName(), 
                              shop.getPrice(product))).collect(toList());
}</pre>
</div></div></li><li><p>Parallelizing requests using a parallel Stream</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public List&lt;String&gt; findPrices(String product)
{
  return shops.parallelStream()
         .map(shop -&gt; String.format(&quot;%s price is %.2f&quot;, shop.getName(), 
                                                        shop.getPrice(product)))
                                                        .collect(toList());
}</pre>
</div></div><ol><li><p>reduced total time from 4+ secs to 1+ secs.</p></li></ol></li><li><p>Making asynchronous requests with <code>CompletableFutures</code></p><ol><li><p>use the factory method <code>supplyAsync </code>to create <code>CompletableFuture</code></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream().map(shop -&gt;
      CompletableFuture.supplyAsync(() -&gt; 
         String.format(&quot;%s price is %.2f&quot;, shop.getName(), 
                                           shop.getPrice(product)))).collect(toList());</pre>
</div></div></li><li><p>Because the <code>findPrices </code>method you’re trying to re-implement using <code>CompletableFutures </code>has to return just a <code>List&lt;String&gt;</code>, you’ll have to wait for the completion of all these futures and extract the value they contain before returning the List</p><p>To achieve this result, you can apply a second map operation to the original <code>List&lt;CompletableFuture&lt;String&gt;&gt;</code>, invoking a join on all the futures in the List and then waiting for their completion one by one.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public List&lt;String&gt; findPrices(String product)
{
  List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream().map(shop -&gt; 
         CompletableFuture.supplyAsync(()-&gt; String.format(&quot;%s price is %.2f&quot;, 
                                     shop.getName(), shop.getPrice(product))))
                                     .collect(toList());

  return priceFutures.stream().map(CompletableFuture::join).
                                      collect(Collectors.toList());
}</pre>
</div></div></li><li><p>Note that you use two separate stream pipelines, instead of putting the two map operations one after the other in the same stream-processing pipeline—and for a very good reason. Given the lazy nature of intermediate stream operations, if you had processed the stream in a single pipeline, you would have succeeded only in executing all the requests to different shops synchronously and sequentially. This is because the creation of each <code>CompletableFuture </code>to interrogate a given shop would start only when the computation of the previous one had completed, letting the join method return the result of that computation clarifies this important detail</p></li><li><p>Result completed in 2 secs</p></li></ol></li><li><p>Looking for a solution that scales better</p><ol><li><p>The parallel stream version performs so well only because it can run four tasks in parallel, so it’s able to allocate exactly one thread for each shop. But what happens if you decide to add a fifth shop to the list of shops crawled by your best-price-finder application? Not surprisingly, now the sequential version requires just a bit more than 5 seconds to run</p></li><li><p>Unfortunately, the parallel stream version will also now require a whole second more than before, because all four threads it can run in parallel (available in the common thread pool) are now busy with the first four shops. The fifth query will have to wait for the completion of one of the former operations to free up a thread</p></li><li><p>The <code>CompletableFuture </code>version seems just a bit faster than the one using parallel stream. But this last version isn’t satisfying either. For instance, if you try to run your code with nine shops, the parallel stream version takes 3143 milliseconds, whereas the <code>CompletableFuture </code>one requires 3009 milliseconds.</p><ol><li><p>They look equivalent and for a very good reason: they both internally use the same common pool that by default has a fixed number of threads equal to the one returned by <code>Runtime.getRuntime().availableProcessors()</code>.</p></li><li><p>Nevertheless, <code>CompletableFutures </code>have an advantage because, in contrast to what’s offered by the parallel Streams API, they allow you to specify a different Executor to submit their tasks to.</p></li></ol></li></ol></li><li><p>Using a custom executor</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">private final Executor executor = 
     Executors.newFixedThreadPool(Math.min(shops.size(), 100), new ThreadFactory() {
  public Thread newThread(Runnable r)
  {
    Thread t = new Thread();
    t.setDaemon(true);
    return t;
  }
});</pre>
</div></div><ol><li><p>You can now pass the new Executor as the second argument of the <code>supplyAsync </code>factory method:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">CompletableFuture.supplyAsync(() -&gt; shop.getName() + &quot; price is &quot; + 
                                               shop.getPrice(product), executor);</pre>
</div></div></li></ol></li></ol><p style="margin-left: 30.0px;">After this improvement, the solution using the <code>CompletableFutures </code>takes only 1021 ms to process five shops and 1022 ms to process nine.</p><h3 id="ModernJavainAction-Pipeliningasynchronoustasks">Pipelining asynchronous tasks</h3><ol><li><p>All the shops have agreed to use a centralized discount service.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Discount
{
  public enum Code
  {
    NONE(0),
    SILVER(5),
    GOLD(10),
    PLATINUM(15),
    DIAMOND(20);
    private final int percentage;
    Code(int percentage) {this.percentage = percentage;}
  }
}</pre>
</div></div></li><li><p>Shops agreed to change the format of the result of the <code>getPrice </code>method. It now returns a String in the format <code>ShopName:price:DiscountCode</code></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public String getPrice(String product)
{
  double price = calculatePrice(product);
  Discount.Code code = Discount.Code.values()[random.nextInt(Discount.Code.values().length)];
  return String.format(&quot;%s:%.2f:%s&quot;, name, price, code);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">private double calculatePrice(String product)
{
  delay();
  return random.nextDouble()* product.charAt(0) + product.charAt(1);
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">BestPrice:123.26:GOLD</pre>
</div></div></li><li><p>Your best-price-finder application should now obtain the prices from the different shops, parse the resulting Strings, and for each String, query the discount server’s needs.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Quote
{
  private final String shopName;
  private final double price;
  private final Discount.Code discountCode;
  public Quote(StringshopName,doubleprice,Discount.Codecode)
  {
    this.shopName = shopName;
    this.price = price;
    this.discountCode = code;
  }
  public static Quote parse(Strings)
  {
    String[]split = s.split(&quot;:&quot;);
    StringshopName = split[0];
    double price = Double.parseDouble(split[1]);
    Discount.Code discountCode = Discount.Code.valueOf(split[2]);
    return new Quote(shopName,price,discountCode);
  }
  public String getShopName(){returnshopName;}
  public double getPrice(){return price;}
  publicDiscount.Code getDiscountCode(){return discountCode;}
}</pre>
</div></div></li><li><p>Discount Service</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class Discount 
{
    public enum Code 
    {
      NONE(0), 
      SILVER(5), 
      GOLD(10), 
      PLATINUM(15),
      DIAMOND(20);
      private final int percentage;
      Code(int percentage) { this.percentage = percentage; }
    }
    public static String applyDiscount(Quote quote) 
    {
      return quote.getShopName() + &quot; price is &quot; + 
                         Discount.apply(quote.getPrice(), quote.getDiscountCode());
    }
    private static double apply(double price, Code code)
    {
        delay();
        return format(price * (100 - code.percentage) / 100);
    }
}</pre>
</div></div></li><li><p>Composing synchronous and asynchronous operations</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public List&lt;String&gt; findPricesFuture(String product)
{
  List&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = findPricesStream(product)
                            .collect(Collectors.&lt;CompletableFuture&lt;String&gt;&gt;toList());

  return priceFutures.stream().map(CompletableFuture::join).collect(Collectors.toList());
}</pre>
</div></div><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product)
{
  return shops.stream()
            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; 
                                              shop.getPrice(product), executor))
            .map(future -&gt; future.thenApply(Quote::parse))
            .map(future -&gt; future.thenCompose(quote -&gt; 
                        CompletableFuture.supplyAsync(() -&gt; 
                                     Discount.applyDiscount(quote), executor)));
}</pre>
</div></div><ol><li><p>At this point you have two asynchronous operations, modeled with two distinct <code>CompletableFutures</code>, that you want to perform in a cascade</p><ol><li><p>Retrieve the price from a shop and then transform it into a Quote</p></li><li><p>Take this Quote and pass it to the Discount service to obtain the final discounted price</p></li></ol></li><li><p>The Java 8 <code>CompletableFutures </code>API provides the <code>thenCompose </code>method specifically for this purpose, allowing you to pipeline two asynchronous operations, passing the result of the first operation to the second operation when it becomes available.</p></li></ol></li><li><p>Combining two <code>CompletableFutures</code>—dependent and independent</p><ol><li><p>Another frequently occurring case is where you need to combine the results of the operations performed by two completely independent <code>CompletableFutures</code>, and you don’t want to wait for the first to complete before starting on the second.</p></li><li><p>In situations like this, use the <code>thenCombine </code>method; this takes as second argument a <code>BiFunction</code>, which defines how the results of the two <code>CompletableFutures </code>are to be combined when they both become available</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Future&lt;Double&gt; futurePriceInUSD = 
   CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product))
  .thenCombine( CompletableFuture.supplyAsync(() -&gt; 
      exchangeService.getRate(Money.EUR, Money.USD)), (price, rate) -&gt; price * rate));</pre>
</div></div></li></ol></li><li><p>Reacting to a <code>CompletableFuture </code>completion</p><ol><li><p>Returning a stream of Futures:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public Stream&lt;CompletableFuture&lt;String&gt;&gt; findPricesStream(String product)
{
  return shops.stream()
            .map(shop -&gt; CompletableFuture.supplyAsync(() -&gt; 
                               shop.getPrice(product), executor))
            .map(future -&gt; future.thenApply(Quote::parse))
            .map(future -&gt; future.thenCompose(quote -&gt; 
                 CompletableFuture.supplyAsync(() -&gt; 
                       Discount.applyDiscount(quote), executor)));
}</pre>
</div></div></li><li><p>add a fourth map operation on the Stream returned by the findPricesStream method to the three already performed inside that method</p><ol><li><p>This new operation simply registers an action on each <code>CompletableFuture</code>;  this action consumes the value of the <code>CompletableFuture </code>as soon as it completes.</p></li><li><p><code>CompletableFuture </code>API provides this feature via the <code>thenAccept</code> method, which take as argument a Consumer of the value with which it completes</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">findPricesStream(&quot;myPhone&quot;).map(f -&gt; f.thenAccept(System.out::println));</pre>
</div></div></li><li><p>You also want to give the slowest shop a chance to provide its response and print its returned price.</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">CompletableFuture[]futures = findPricesStream(&quot;myPhone&quot;).map(f -&gt; 
    f.thenAccept(System.out::println)).toArray(size -&gt; 
        new CompletableFuture[size]);
CompletableFuture.allOf(futures).join();</pre>
</div></div></li><li><p>In other applications you may wish to wait for the completion of only one of the <code>CompletableFutures </code>in an array. Use <code>anyOf</code>.</p></li></ol></li></ol></li></ol>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Feb 12, 2021 23:35</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
