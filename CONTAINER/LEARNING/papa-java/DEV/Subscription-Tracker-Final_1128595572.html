<!DOCTYPE html>
<html>
    <head>
        <title>DevOps : Subscription Tracker Final</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">DevOps</a></span>
                            </li>
                                                    <li>
                                <span><a href="DevOps-Home_603226548.html">DevOps Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Tutorials_278921431.html">Tutorials</a></span>
                            </li>
                                                    <li>
                                <span><a href="Project-Profit-Application_315097089.html">Project Profit Application</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            DevOps : Subscription Tracker Final
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Nicholas Guner</span>, last modified on Jan 26, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="SubscriptionTrackerFinal-POM.XML">POM.XML</h1><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.1.9.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.spring.subscription.tracker&lt;/groupId&gt;
	&lt;artifactId&gt;subscription-tracker&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;subscription-tracker&lt;/name&gt;
	&lt;description&gt;Subscription Tracker Project&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;com.h2database&lt;/groupId&gt;
			&lt;artifactId&gt;h2&lt;/artifactId&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;com.ibm.db2&lt;/groupId&gt;
			&lt;artifactId&gt;db2jcc4&lt;/artifactId&gt;
			&lt;version&gt;10.5.7.3.69.49&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
			&lt;artifactId&gt;spring-data-rest-hal-browser&lt;/artifactId&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;io.springfox&lt;/groupId&gt;
			&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
			&lt;version&gt;2.9.2&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;io.springfox&lt;/groupId&gt;
			&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
			&lt;version&gt;2.6.1&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
			&lt;optional&gt;true&lt;/optional&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Aspects">Aspects</h1><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Aspect
@Configuration
public class AspectLogger
{
    private Logger logger = LoggerFactory.getLogger(getClass());

    @Around(&quot;@annotation(com.spring.subscription.tracker.subscriptiontracker.aspects.annotations.TrackTime)&quot;)
    public Object trackTime(ProceedingJoinPoint joinPoint) throws Throwable
    {
        long startTime = System.currentTimeMillis();
        Object returnValue = joinPoint.proceed();
        long endTime = System.currentTimeMillis();
        logger.info(&quot;Time taken by {} is {} ms&quot;, joinPoint, endTime - startTime);
        return returnValue;
    }

    @Around(&quot;@annotation(com.spring.subscription.tracker.subscriptiontracker.aspects.annotations.LogInputOutput)&quot;)
    public Object logInputOutput(ProceedingJoinPoint joinPoint) throws Throwable
    {
        Signature signature = joinPoint.getSignature();
        logger.info(signature.getName() + &quot; Arguments: &quot; + Arrays.toString(joinPoint.getArgs()));
        Object returnValue = joinPoint.proceed();
        logger.info(signature.getName() + &quot; Return value: &quot; + returnValue);
        return returnValue;
    }

    @Around(&quot;@annotation(com.spring.subscription.tracker.subscriptiontracker.aspects.annotations.LogExceptionHandler)&quot;)
    public Object logExceptionHandler(ProceedingJoinPoint joinPoint) throws Throwable
    {
        Object returnValue = joinPoint.proceed();
        logger.error(&quot;Return value: &quot; + returnValue);
        return returnValue;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-Annotations">Annotations</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExceptionHandler
{
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogInputOutput
{
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface TrackTime
{
}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Config">Config</h1><h3 id="SubscriptionTrackerFinal-AuditorAwareImpl">AuditorAwareImpl</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class AuditorAwareImpl implements AuditorAware&lt;String&gt;
{
    @Override
    public Optional&lt;String&gt; getCurrentAuditor()
    {
        return Optional.of(System.getProperty(&quot;user.name&quot;));
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-DataSourceConfig">DataSourceConfig</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Configuration
@Profile({&quot;db2&quot;})
public class DataSourceConfig
{
    @Value(&quot;${datasource.driver-class-name}&quot;)
    private String dataSourceDriverClass;

    @Value(&quot;${datasource.url}&quot;)
    private String dataSourceUrl;

    @Value(&quot;${datasource.username}&quot;)
    private String username;

    @Value(&quot;${datasource.password}&quot;)
    private String password;

    @Bean
    public DataSource getDataSource()
    {
        String username = SecurityEncoder.decrypt(this.username);
        String password = SecurityEncoder.decrypt(this.password);

        return DataSourceBuilder
                .create()
                .username(username)
                .password(password)
                .url(dataSourceUrl)
                .driverClassName(dataSourceDriverClass)
                .build();
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-HttpServer">HttpServer</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Component
@Profile({&quot;h2&quot;, &quot;db2&quot;})
public class HttpServer
{
    @Bean
    public ServletWebServerFactory servletContainer(@Value(&quot;${server.http.port}&quot;) int httpPort)
    {
        Connector connector = new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);
        connector.setPort(httpPort);

        TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
        tomcat.addAdditionalTomcatConnectors(connector);
        return tomcat;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-JPAConfig">JPAConfig</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Configuration
@EnableJpaAuditing(auditorAwareRef = &quot;auditorAware&quot;)
public class JpaConfig
{
    @Bean
    public AuditorAware&lt;String&gt; auditorAware()
    {
        return new AuditorAwareImpl();
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-SSLConfig">SSLConfig</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Component
@Profile({&quot;h2&quot;, &quot;db2&quot;})
public class SSLConfig implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;
{
    @Value(&quot;${server.ssl.key-store}&quot;)
    private  String keyStore;

    @Value(&quot;${server.ssl.key-store-type}&quot;)
    private  String keyStoreType;

    @Value(&quot;${server.ssl.key-store-password}&quot;)
    private  String password;

    @Override
    public void customize(ConfigurableServletWebServerFactory serverFactory)
    {
        String password = SecurityEncoder.decrypt(this.password);

        Ssl ssl = new Ssl();
        ssl.setKeyStore(keyStore);
        ssl.setKeyStoreType(keyStoreType);
        ssl.setKeyPassword(password);
        ssl.setKeyStorePassword(password);
        serverFactory.setSsl(ssl);
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-SwaggerConfig">SwaggerConfig</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Configuration
@EnableSwagger2
public class SwaggerConfig
{
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
                .select()
                .apis(RequestHandlerSelectors.any())
                .paths(PathSelectors.any())
                .build();
    }
}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Resources">Resources</h1><h3 id="SubscriptionTrackerFinal-application.properties">application.properties</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">spring.jpa.show-sql=true
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:db

spring.jackson.default-property-inclusion=NON_NULL

spring.jpa.properties.hibernate.jdbc.time_zone=UTC

management.endpoints.web.exposure.include=*
info.app.name=@project.name@
info.app.description=@project.description@
info.app.version=@project.version@
info.app.encoding=@project.build.sourceEncoding@
info.app.java.version=@java.version@

# Create SQL DDL Statements
#spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.DB2Dialect
#spring.jpa.properties.javax.persistence.schema-generation.create-source=metadata
#spring.jpa.properties.javax.persistence.schema-generation.scripts.action=create
#spring.jpa.properties.javax.persistence.schema-generation.scripts.create-target=create.sql

logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type=TRACE</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-application-db2.properties">application-db2.properties</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">spring.profiles.include=ssl

spring.jpa.properties.hibernate.default_schema=SOD_OTHER
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.DB2Dialect

datasource.url=jdbc:db2://nyg13qi8-vip.ny.fw.gs.com:56834/ntrkdi02
datasource.username=tMkX5NSQ4E//Q7u+0GDAbw==
datasource.password=Q770LtFMSBYr7SA4AIx78A==

datasource.driver-class-name=com.ibm.db2.jcc.DB2Driver</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-application-h2.properties">application-h2.properties</h3><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">spring.profiles.include=ssl
spring.jpa.properties.hbm2ddl.import_files=data.sql</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-application-ssl.properties">application-ssl.properties</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 760.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">server.http.port=8081
server.port=8443
server.ssl.key-store-type=JKS
server.ssl.key-store=classpath:ssl-key.jks
server.ssl.key-store-password=j63qzV58IESMd8YTlzXnbg==
server.ssl.key-alias=ssl-key</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-data.sql">data.sql</h3><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">-- PROJECT
INSERT INTO PROJECT(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_NAME, PROJECT_DESCRIPTION, REVENUE, CREATED_BY, LAST_MODIFIED_BY) VALUES(1, &#39;00000000-0000-0000-0000-000000000001&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;P-1&#39;, &#39;Project one&#39;, 1200000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_NAME, PROJECT_DESCRIPTION, REVENUE, CREATED_BY, LAST_MODIFIED_BY) VALUES(2, &#39;00000000-0000-0000-0000-000000000002&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;P-2&#39;, &#39;Project two&#39;, 700000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_NAME, PROJECT_DESCRIPTION, REVENUE, CREATED_BY, LAST_MODIFIED_BY) VALUES(3, &#39;00000000-0000-0000-0000-000000000003&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;P-3&#39;, &#39;Project three&#39;, 2300000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_NAME, PROJECT_DESCRIPTION, REVENUE, CREATED_BY, LAST_MODIFIED_BY) VALUES(4, &#39;00000000-0000-0000-0000-000000000004&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;P-4&#39;, &#39;Project four&#39;, 0.0, &#39;unknown&#39;, &#39;unknown&#39;)

-- WORKER
INSERT INTO WORKER(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_CODE, WORKER_NAME, COMPENSATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(1, &#39;00000000-0000-0000-0000-000000000001&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;CODE-1&#39;, &#39;One First&#39;, 120000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_CODE, WORKER_NAME, COMPENSATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(2, &#39;00000000-0000-0000-0000-000000000002&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;CODE-2&#39;, &#39;Two Second&#39;, 240000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_CODE, WORKER_NAME, COMPENSATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(3, &#39;00000000-0000-0000-0000-000000000003&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;CODE-3&#39;, &#39;Three Third&#39;, 190000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_CODE, WORKER_NAME, COMPENSATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(4, &#39;00000000-0000-0000-0000-000000000004&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;CODE-4&#39;, &#39;Four Forth&#39;, 185000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_CODE, WORKER_NAME, COMPENSATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(5, &#39;00000000-0000-0000-0000-000000000005&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;CODE-5&#39;, &#39;Five Fifth&#39;, 45000.00, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_CODE, WORKER_NAME, COMPENSATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(6, &#39;00000000-0000-0000-0000-000000000006&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;CODE-6&#39;, &#39;Six Sixth&#39;, 40000.00, &#39;unknown&#39;, &#39;unknown&#39;)

-- EMPLOYEES
INSERT INTO EMPLOYEE(ID, BENE_CODE) VALUES(1, &#39;BENE-1&#39;)
INSERT INTO EMPLOYEE(ID, BENE_CODE) VALUES(2, &#39;BENE-1&#39;)
INSERT INTO EMPLOYEE(ID, BENE_CODE) VALUES(3, &#39;BENE-2&#39;)

-- CONSULTANTS
INSERT INTO CONSULTANT(ID, AGENCY_CODE) VALUES(4, &#39;AGENCY-1&#39;)
INSERT INTO CONSULTANT(ID, AGENCY_CODE) VALUES(5, &#39;AGENCY-2&#39;)
INSERT INTO CONSULTANT(ID, AGENCY_CODE) VALUES(6, &#39;AGENCY-3&#39;)

-- SUBSCRIPTION
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(1, &#39;00000000-0000-0000-0000-000000000001&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-1&#39;, &#39;Subscription 1&#39;, 8000.00, 4, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(2, &#39;00000000-0000-0000-0000-000000000002&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-2&#39;, &#39;Subscription 2&#39;, 24000.00, 2, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(3, &#39;00000000-0000-0000-0000-000000000003&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-3&#39;, &#39;Subscription 3&#39;, 3600.00, 3, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(4, &#39;00000000-0000-0000-0000-000000000004&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-4&#39;, &#39;Subscription 4&#39;, 30200.00, 4, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(5, &#39;00000000-0000-0000-0000-000000000005&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-5&#39;, &#39;Subscription 5&#39;, 850.00, 1, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(6, &#39;00000000-0000-0000-0000-000000000006&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-6&#39;, &#39;Subscription 6&#39;, 1400.00, 1, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO SUBSCRIPTION(ID, AUDIT_ID, IN_UTC, OUT_UTC, SUBSCRIPTION_CODE, SUBSCRIPTION_NAME, FEES, DIVISOR, CREATED_BY, LAST_MODIFIED_BY) VALUES(7, &#39;00000000-0000-0000-0000-000000000007&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, &#39;SUB-7&#39;, &#39;Subscription 7&#39;, 2200.00, 1, &#39;unknown&#39;, &#39;unknown&#39;)


-- PROJECT-WORKER-MAP
--  PROJECT 1
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(1, &#39;00000000-0000-0000-0000-000000000001&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 1, 1, 0.8, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(2, &#39;00000000-0000-0000-0000-000000000002&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 1, 3, 0.9, &#39;unknown&#39;, &#39;unknown&#39;)
--  PROJECT 2
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(3, &#39;00000000-0000-0000-0000-000000000003&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 2, 2, 0.6, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(4, &#39;00000000-0000-0000-0000-000000000004&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 2, 4, 0.3, &#39;unknown&#39;, &#39;unknown&#39;)
-- PROJECT 3
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(5, &#39;00000000-0000-0000-0000-000000000005&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 1, 0.2, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(6, &#39;00000000-0000-0000-0000-000000000006&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 2, 0.4, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(7, &#39;00000000-0000-0000-0000-000000000007&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 3, 0.1, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO PROJECT_WORKER_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, PROJECT_ID, WORKER_ID, APPROPRIATION, CREATED_BY, LAST_MODIFIED_BY) VALUES(8, &#39;00000000-0000-0000-0000-000000000008&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 4, 0.7, &#39;unknown&#39;, &#39;unknown&#39;)

-- WORKER-SUBSCRIPTION-MAP
--  WORKER-1
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(1, &#39;00000000-0000-0000-0000-000000000001&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 1, 1, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(2, &#39;00000000-0000-0000-0000-000000000002&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 1, 2, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(3, &#39;00000000-0000-0000-0000-000000000003&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 1, 3, &#39;unknown&#39;, &#39;unknown&#39;)
--  WORKER-2
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(4, &#39;00000000-0000-0000-0000-000000000004&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 2, 1, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(5, &#39;00000000-0000-0000-0000-000000000005&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 2, 2, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(6, &#39;00000000-0000-0000-0000-000000000006&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 2, 3, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(7, &#39;00000000-0000-0000-0000-000000000007&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 2, 4, &#39;unknown&#39;, &#39;unknown&#39;)
--  WORKER-3
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(8, &#39;00000000-0000-0000-0000-000000000008&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 1, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(9, &#39;00000000-0000-0000-0000-000000000009&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 3, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(10, &#39;00000000-0000-0000-0000-000000000010&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 3, 5, &#39;unknown&#39;, &#39;unknown&#39;)
--  WORKER-4
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(11, &#39;00000000-0000-0000-0000-000000000011&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 4, 2, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(12, &#39;00000000-0000-0000-0000-000000000012&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 4, 4, &#39;unknown&#39;, &#39;unknown&#39;)
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(13, &#39;00000000-0000-0000-0000-000000000013&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 4, 6, &#39;unknown&#39;, &#39;unknown&#39;)
--  WORKER-5
INSERT INTO WORKER_SUBSCRIPTION_MAP(ID, AUDIT_ID, IN_UTC, OUT_UTC, WORKER_ID, SUBSCRIPTION_ID, CREATED_BY, LAST_MODIFIED_BY) VALUES(14, &#39;00000000-0000-0000-0000-000000000014&#39;, CURRENT_TIMESTAMP, &#39;9999-12-31&#39;, 5, 1, &#39;unknown&#39;, &#39;unknown&#39;)

--SEQUENCE
alter sequence HIBERNATE_SEQUENCE restart with 101</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Exceptions">Exceptions</h1><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@ControllerAdvice
public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler
{
    @ExceptionHandler(Exception.class)
    @LogExceptionHandler
    public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), ex.getMessage(), request.getDescription(false));
        return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR);
    }


    @ExceptionHandler(NotFoundException.class)
    @LogExceptionHandler
    public final ResponseEntity&lt;Object&gt; handleNotFoundException(NotFoundException ex, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(AlreadyExistsException.class)
    @LogExceptionHandler
    public final ResponseEntity&lt;Object&gt; handleAlreadyExistsException(AlreadyExistsException ex, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity(exceptionResponse, HttpStatus.NOT_MODIFIED);
    }

    @ExceptionHandler(ProjectViolationException.class)
    @LogExceptionHandler
    public final ResponseEntity&lt;Object&gt; handleProjectViolationException(ProjectViolationException ex, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity(exceptionResponse, HttpStatus.FAILED_DEPENDENCY);
    }

    @ExceptionHandler(WorkerViolationException.class)
    @LogExceptionHandler
    public final ResponseEntity&lt;Object&gt; handleWorkerViolationException(WorkerViolationException ex, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity(exceptionResponse, HttpStatus.FAILED_DEPENDENCY);
    }

    @ExceptionHandler(SubscriptionViolationException.class)
    @LogExceptionHandler
    public final ResponseEntity&lt;Object&gt; handleSubscriptionViolationException(SubscriptionViolationException ex, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), ex.getMessage(),
                request.getDescription(false));
        return new ResponseEntity(exceptionResponse, HttpStatus.FAILED_DEPENDENCY);
    }

    @Override
    protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
                                                                  HttpHeaders headers, HttpStatus status, WebRequest request)
    {
        ExceptionResponse exceptionResponse = new ExceptionResponse(ZonedDateTime.now(), &quot;Validation Failed&quot;,
                ex.getBindingResult().getAllErrors().get(0).getDefaultMessage());
        return new ResponseEntity(exceptionResponse, HttpStatus.BAD_REQUEST);
    }
}

@ResponseStatus(HttpStatus.NOT_MODIFIED)
public class AlreadyExistsException  extends RuntimeException
{
    public AlreadyExistsException(String message)
    {
        super(message);
    }
}

public class ExceptionResponse
{
    private ZonedDateTime timestamp;
    private String message;
    private String details;

    public ExceptionResponse(ZonedDateTime timestamp, String message, String details) {
        this.timestamp = timestamp;
        this.message = message;
        this.details = details;
    }

    public ZonedDateTime getTimestamp() {
        return timestamp;
    }

    public String getMessage() {
        return message;
    }

    public String getDetails() {
        return details;
    }
}

@ResponseStatus(HttpStatus.NOT_FOUND)
public class NotFoundException extends RuntimeException
{
    public NotFoundException(String message)
    {
        super(message);
    }
}

@ResponseStatus(HttpStatus.FAILED_DEPENDENCY)
public class ProjectViolationException extends RuntimeException
{
    public ProjectViolationException(String message)
    {
        super(message);
    }
}

@ResponseStatus(HttpStatus.FAILED_DEPENDENCY)
public class SubscriptionViolationException extends RuntimeException
{
    public SubscriptionViolationException(String message)
    {
        super(message);
    }

}

@ResponseStatus(HttpStatus.FAILED_DEPENDENCY)
public class WorkerViolationException extends RuntimeException
{
    public WorkerViolationException(String message)
    {
        super(message);
    }
}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Repositories">Repositories</h1><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public interface ConsultantRepository extends JpaRepository&lt;Consultant, Integer&gt;
{
    @Query(&quot;from Consultant where id =:id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;Consultant&gt; findById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Consultant where id =:id&quot;)
    Optional&lt;Consultant&gt; findAllById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Consultant where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Consultant&gt; findAll();

    @Query(&quot;from Consultant where auditId =:auditId&quot;)
    List&lt;Consultant&gt; findByAuditId(@Param(&quot;auditId&quot;) String auditId);

    @Query(&quot;from Consultant&quot;)
    List&lt;Consultant&gt; findAllWithAudit();

    @Query(&quot;from Consultant where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Consultant&gt; findOnlyAudit();
}

public interface EmployeeRepository extends JpaRepository&lt;Employee, Integer&gt;
{
    @Query(&quot;from Employee where id =:id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;Employee&gt; findById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Employee where id =:id&quot;)
    Optional&lt;Employee&gt; findAllById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Employee where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Employee&gt; findAll();

    @Query(&quot;from Employee where auditId =:auditId&quot;)
    List&lt;Employee&gt; findByAuditId(@Param(&quot;auditId&quot;) String auditId);

    @Query(&quot;from Employee&quot;)
    List&lt;Employee&gt; findAllWithAudit();

    @Query(&quot;from Employee where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Employee&gt; findOnlyAudit();
}

public interface ProjectRepository extends JpaRepository&lt;Project, Integer&gt;
{
    @Query(&quot;from Project where id =:id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;Project&gt; findById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Project where id =:id&quot;)
    Optional&lt;Project&gt; findAllById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Project where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Project&gt; findAll();

    @Query(&quot;from Project where auditId =:auditId&quot;)
    List&lt;Project&gt; findByAuditId(@Param(&quot;auditId&quot;) String auditId);

    @Query(&quot;from Project&quot;)
    List&lt;Project&gt; findAllWithAudit();

    @Query(&quot;from Project where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Project&gt; findOnlyAudit();
}

public interface ProjectWorkerMapRepository extends JpaRepository&lt;ProjectWorkerPair, Integer&gt;
{
    @Query(&quot;from ProjectWorkerPair where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;ProjectWorkerPair&gt; findAll();

    @Query(&quot;from ProjectWorkerPair where project.ID = :id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;ProjectWorkerPair&gt; findByProjectId(@Param(&quot;id&quot;) int id);

    @Query(&quot;from ProjectWorkerPair where worker.ID = :id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;ProjectWorkerPair&gt; findByWorkerId(@Param(&quot;id&quot;) int id);

    @Query(&quot;from ProjectWorkerPair where project.ID = :projectId and worker.ID = :workerId and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;ProjectWorkerPair&gt; findByProjectIdWorkerId(@Param(&quot;projectId&quot;) int projectId, @Param(&quot;workerId&quot;) int workerId);

    @Query(&quot;from ProjectWorkerPair where project.ID IN :projectIdList and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;ProjectWorkerPair&gt; findByProjectIdList(@Param(&quot;projectIdList&quot;) List&lt;Integer&gt; projectIdList);

    @Query(&quot;from ProjectWorkerPair where worker.ID IN :workerIdList and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;ProjectWorkerPair&gt; findByWorkerIdList(@Param(&quot;workerIdList&quot;) List&lt;Integer&gt; workerIdList);

    @Query(&quot;from ProjectWorkerPair&quot;)
    List&lt;ProjectWorkerPair&gt; findAllWithAudit();

    @Query(&quot;from ProjectWorkerPair where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;ProjectWorkerPair&gt; findOnlyAudit();

    @Query(&quot;from ProjectWorkerPair where project.ID = :id&quot;)
    List&lt;ProjectWorkerPair&gt; findByProjectIdWithAudit(@Param(&quot;id&quot;) int id);

    @Query(&quot;from ProjectWorkerPair where worker.ID = :id&quot;)
    List&lt;ProjectWorkerPair&gt; findByWorkerIdWithAudit(@Param(&quot;id&quot;) int id);
}

public interface SubscriptionRepository extends JpaRepository&lt;Subscription, Integer&gt;
{
    @Query(&quot;from Subscription where id =:id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;Subscription&gt; findById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Subscription where id =:id&quot;)
    Optional&lt;Subscription&gt; findAllById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Subscription where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Subscription&gt; findAll();

    @Query(&quot;from Subscription where auditId =:auditId&quot;)
    List&lt;Subscription&gt; findByAuditId(@Param(&quot;auditId&quot;) String auditId);

    @Query(&quot;from Subscription&quot;)
    List&lt;Subscription&gt; findAllWithAudit();

    @Query(&quot;from Subscription where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Subscription&gt; findOnlyAudit();
}

public interface WorkerRepository extends JpaRepository&lt;Worker, Integer&gt;
{
    @Query(&quot;from Worker where id =:id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;Worker&gt; findById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Worker where id =:id&quot;)
    Optional&lt;Worker&gt; findAllById(@Param(&quot;id&quot;) int id);

    @Query(&quot;from Worker where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Worker&gt; findAll();

    @Query(&quot;from Worker where auditId =:auditId&quot;)
    List&lt;Worker&gt; findByAuditId(@Param(&quot;auditId&quot;) String auditId);

    @Query(&quot;from Worker&quot;)
    List&lt;Worker&gt; findAllWithAudit();

    @Query(&quot;from Worker where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;Worker&gt; findOnlyAudit();
}

public interface WorkerSubscriptionMapRepository extends JpaRepository&lt;WorkerSubscriptionPair, Integer&gt;
{
    @Query(&quot;from WorkerSubscriptionPair where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;WorkerSubscriptionPair&gt; findAll();

    @Query(&quot;from WorkerSubscriptionPair where worker.ID = :id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;WorkerSubscriptionPair&gt; findByWorkerId(@Param(&quot;id&quot;) int id);

    @Query(&quot;from WorkerSubscriptionPair where subscription.ID = :id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;WorkerSubscriptionPair&gt; findBySubscriptionId(@Param(&quot;id&quot;) int id);

    @Query(&quot;from WorkerSubscriptionPair where worker.ID = :workerId and subscription.ID = :subscriptionId and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    Optional&lt;WorkerSubscriptionPair&gt; findByWorkerIdSubscriptionId(@Param(&quot;workerId&quot;) int workerId, @Param(&quot;subscriptionId&quot;) int subscriptionId);

    @Query(&quot;from WorkerSubscriptionPair where worker.ID IN :workerIdList and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;WorkerSubscriptionPair&gt; findByWorkerIdList(@Param(&quot;workerIdList&quot;) List&lt;Integer&gt; workerIdList);

    @Query(&quot;from WorkerSubscriptionPair&quot;)
    List&lt;WorkerSubscriptionPair&gt; findAllWithAudit();

    @Query(&quot;from WorkerSubscriptionPair where outUtc &lt;&gt; &quot; + BaseEntity.DATE_INFINITY_STRING)
    List&lt;WorkerSubscriptionPair&gt; findOnlyAudit();

    @Query(&quot;from WorkerSubscriptionPair where worker.ID = :id&quot;)
    List&lt;WorkerSubscriptionPair&gt; findByWorkerIdWithAudit(@Param(&quot;id&quot;) int id);

    @Query(&quot;from WorkerSubscriptionPair where subscription.ID = :id&quot;)
    List&lt;WorkerSubscriptionPair&gt; findBySubscriptionIdWithAudit(@Param(&quot;id&quot;) int id);

}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Entities">Entities</h1><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity extends ResourceSupport
{
    public static ZonedDateTime DATE_INFINITY = ZonedDateTime.parse(&quot;9999-12-31T00:00:00Z&quot;);
    public static final String DATE_INFINITY_STRING = &quot;&#39;9999-12-31&#39;&quot;;

    @CreatedBy
    @Column(name = &quot;created_by&quot;)
    private String createdBy;

    @LastModifiedBy
    @Column(name = &quot;last_modified_by&quot;)
    private String lastModifiedBy;

    @CreatedDate
    @Column(name = &quot;in_utc&quot;, nullable = false)
    private Date inUtc;

    @Column(name = &quot;out_utc&quot;)
    private ZonedDateTime outUtc = DATE_INFINITY;

    public String getCreatedBy()
    {
        return createdBy;
    }

    public void setCreatedBy(String createdBy)
    {
        this.createdBy = createdBy;
    }

    public String getLastModifiedBy()
    {
        return lastModifiedBy;
    }

    public void setLastModifiedBy(String lastModifiedBy)
    {
        this.lastModifiedBy = lastModifiedBy;
    }

    public Date getInUtc()
    {
        return inUtc;
    }

    public void setInUtc(Date inUtc)
    {
        this.inUtc = inUtc;
    }

    public ZonedDateTime getOutUtc()
    {
        return outUtc;
    }

    public void setOutUtc(ZonedDateTime outUtc)
    {
        this.outUtc = outUtc;
    }
}

@Entity
public class Consultant extends Worker
{
    private String agencyCode;

    //  Required by the mapping controllers
    public Consultant()
    {
        super();
    }

    //  Default Constructor needed for the audit controller
    public Consultant(Consultant other)
    {
        super(other);
        this.agencyCode = other.getAgencyCode();
    }

    public String getAgencyCode()
    {
        return agencyCode;
    }

    public void setAgencyCode(String agencyCode)
    {
        this.agencyCode = agencyCode;
    }
}

@Entity
public class Employee extends Worker
{
    private String beneCode;

    //  Required by the mapping controllers
    public Employee()
    {
        super();
    }

    //  Default Constructor needed for the audit controller
    public Employee(Employee other)
    {
        super(other);
        this.beneCode = other.getBeneCode();
    }

    public String getBeneCode()
    {
        return beneCode;
    }

    public void setBeneCode(String beneCode)
    {
        this.beneCode = beneCode;
    }
}

@Entity
@Table(uniqueConstraints={
        @UniqueConstraint(columnNames = {&quot;auditId&quot;, &quot;out_utc&quot;})
})
public class Project extends BaseEntity
{
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column(name=&quot;ID&quot;, updatable = false, nullable = false)
    @JsonProperty
    private int ID;
    private String auditId = UUID.randomUUID().toString();
    @NotNull(message=&quot;Project name must be specified.&quot;)
    private String projectName;
    //@Pattern(regexp = &quot;^[\\p{Alnum}]{1,10}$&quot;, message=&quot;Project description must be less than 11 characters.&quot;)
    private String projectDescription;
    private double revenue;
    @JsonIgnore
    @OneToMany(mappedBy = &quot;project&quot;)
    private List&lt;ProjectWorkerPair&gt; projectWorkerPairs = new ArrayList&lt;&gt;();
    @Transient
    private List&lt;Worker&gt; workers;

    //  Constructor for the audit record
    public Project(Project other)
    {
        super();
        this.auditId = other.auditId;
        this.projectName = other.projectName;
        this.projectDescription = other.projectDescription;
        this.setOutUtc(ZonedDateTime.now());
        this.setInUtc(other.getInUtc());
    }

    public Project(int id, String projectName, String projectDescription, double revenue)
    {
        this.ID = id;
        this.projectName = projectName;
        this.projectDescription = projectDescription;
        this.revenue = revenue;
    }


    public Project()
    {
        super();
    }

    public int getID()
    {
        return ID;
    }

    public void setID(int ID)
    {
        this.ID = ID;
    }

    public String getProjectName()
    {
        return projectName;
    }

    public void setProjectName(String projectName)
    {
        this.projectName = projectName;
    }

    public String getProjectDescription()
    {
        return projectDescription;
    }

    public void setProjectDescription(String projectDescription)
    {
        this.projectDescription = projectDescription;
    }

    public double getRevenue()
    {
        return revenue;
    }

    public void setRevenue(double revenue)
    {
        this.revenue = revenue;
    }

    public List&lt;ProjectWorkerPair&gt; getProjectWorkerPairs()
    {
        return projectWorkerPairs;
    }

    public void setProjectWorkerPairs(List&lt;ProjectWorkerPair&gt; projectWorkerPairs)
    {
        this.projectWorkerPairs = projectWorkerPairs;
    }

    public String getAuditId()
    {
        return auditId;
    }

    public void setAuditId(String auditId)
    {
        this.auditId = auditId;
    }

    public List&lt;Worker&gt; getWorkers()
    {
        return workers;
    }

    public void setWorkers(List&lt;Worker&gt; workers)
    {
        this.workers = workers;
    }

    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Project project = (Project) o;
        return ID == project.ID &amp;&amp;
                Objects.equals(projectName, project.projectName) &amp;&amp;
                Objects.equals(projectDescription, project.projectDescription);
    }

    @Override
    public int hashCode()
    {
        return Objects.hash(super.hashCode(), ID, projectName, projectDescription);
    }

    @Override
    public String toString()
    {
        return &quot;Project{&quot; +
                &quot;ID=&quot; + ID +
                &quot;, projectName=&#39;&quot; + projectName + &#39;\&#39;&#39; +
                &quot;, projectDescription=&#39;&quot; + projectDescription + &#39;\&#39;&#39; +
                &quot;, revenue=&quot; + revenue +
                &#39;}&#39;;
    }
}

@Entity
@Table(name = &quot;PROJECT_WORKER_MAP&quot;,
        uniqueConstraints={
        @UniqueConstraint(columnNames = {&quot;auditId&quot;, &quot;out_utc&quot;})
})
public class ProjectWorkerPair extends BaseEntity
{
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column(name=&quot;ID&quot;, updatable = false, nullable = false)
    private int ID;
    private String auditId = UUID.randomUUID().toString();
    private double appropriation;
    @ManyToOne
    @JoinColumn(name = &quot;project_id&quot;)
    private Project project;
    @ManyToOne
    @JoinColumn(name = &quot;worker_id&quot;)
    private Worker worker;

    public ProjectWorkerPair(Project project, Worker worker, double appropriation)
    {
        this.project = project;
        this.worker = worker;
    }

    public ProjectWorkerPair()
    {
    }

    public int getID()
    {
        return ID;
    }

    public void setID(int ID)
    {
        this.ID = ID;
    }

    public Project getProject()
    {
        return project;
    }

    public void setProject(Project project)
    {
        this.project = project;
    }

    public Worker getWorker()
    {
        return worker;
    }

    public void setWorker(Worker worker)
    {
        this.worker = worker;
    }

    public String getAuditId()
    {
        return auditId;
    }

    public void setAuditId(String auditId)
    {
        this.auditId = auditId;
    }

    public double getAppropriation()
    {
        return appropriation;
    }

    public void setAppropriation(double appropriation)
    {
        this.appropriation = appropriation;
    }
}

@Entity
@Table(uniqueConstraints={
                @UniqueConstraint(columnNames = {&quot;auditId&quot;, &quot;out_utc&quot;})
        })
public class Subscription extends BaseEntity
{
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column(name=&quot;ID&quot;, updatable = false, nullable = false)
    @JsonProperty
    private int ID;
    private String auditId = UUID.randomUUID().toString();
    private String subscriptionCode;
    private String subscriptionName;
    private double fees;
    private int divisor;

    @JsonIgnore
    @OneToMany(mappedBy = &quot;subscription&quot;)
    private List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = new ArrayList&lt;&gt;();
    @Transient
    private List&lt;Worker&gt; workers;

    //  Constructor for the audit record
    public Subscription(Subscription other)
    {
        super();
        this.auditId = other.auditId;
        this.subscriptionCode = other.subscriptionCode;
        this.subscriptionName = other.subscriptionName;
        this.fees = other.fees;
        this.divisor = other.divisor;
        this.setOutUtc(ZonedDateTime.now());
        this.setInUtc(other.getInUtc());
    }

    public Subscription()
    {
        super();
    }

    public Subscription(int id, String subscriptionCode, String subscriptionName, double fees, int divisor)
    {
        this.ID = id;
        this.subscriptionCode = subscriptionCode;
        this.subscriptionName = subscriptionName;
        this.fees = fees;
        this.divisor = divisor;
    }


    public int getID()
    {
        return ID;
    }

    public void setID(int ID)
    {
        this.ID = ID;
    }

    public String getSubscriptionCode()
    {
        return subscriptionCode;
    }

    public void setSubscriptionCode(String subscriptionCode)
    {
        this.subscriptionCode = subscriptionCode;
    }

    public String getSubscriptionName()
    {
        return subscriptionName;
    }

    public void setSubscriptionName(String subscriptionName)
    {
        this.subscriptionName = subscriptionName;
    }

    public double getFees()
    {
        return fees;
    }

    public void setFees(double fees)
    {
        this.fees = fees;
    }

    public int getDivisor()
    {
        return divisor;
    }

    public void setDivisor(int divisor)
    {
        this.divisor = divisor;
    }

    public List&lt;WorkerSubscriptionPair&gt; getWorkerSubscriptionPairs()
    {
        return workerSubscriptionPairs;
    }

    public void setWorkerSubscriptionPairs(List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs)
    {
        this.workerSubscriptionPairs = workerSubscriptionPairs;
    }

    public String getAuditId()
    {
        return auditId;
    }

    public void setAuditId(String auditId)
    {
        this.auditId = auditId;
    }

    public List&lt;Worker&gt; getWorkers()
    {
        return workers;
    }

    public void setWorkers(List&lt;Worker&gt; workers)
    {
        this.workers = workers;
    }

    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Subscription that = (Subscription) o;
        return ID == that.ID &amp;&amp;
                Objects.equals(subscriptionCode, that.subscriptionCode) &amp;&amp;
                Objects.equals(subscriptionName, that.subscriptionName);
    }

    @Override
    public int hashCode()
    {
        return Objects.hash(super.hashCode(), ID, subscriptionCode, subscriptionName);
    }
}

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@Table(uniqueConstraints={
        @UniqueConstraint(columnNames = {&quot;auditId&quot;, &quot;out_utc&quot;})
})
public class Worker extends BaseEntity
{
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column(name=&quot;ID&quot;, updatable = false, nullable = false)
    @JsonProperty
    private int ID;
    private String auditId = UUID.randomUUID().toString();
    private String workerCode;
    private String workerName;
    private double compensation;
    @JsonIgnore
    @OneToMany(mappedBy = &quot;worker&quot;)
    private List&lt;ProjectWorkerPair&gt; projectWorkerPairs = new ArrayList&lt;&gt;();
    @JsonIgnore
    @OneToMany(mappedBy = &quot;worker&quot;)
    private List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = new ArrayList&lt;&gt;();
    @Transient
    private List&lt;Subscription&gt; subscriptions;
    @Transient
    private List&lt;Project&gt; projects;

    //  Constructor for the audit record
    public Worker(Worker other)
    {
        super();
        this.auditId = other.auditId;
        this.workerCode = other.workerCode;
        this.workerName = other.workerName;
        this.setOutUtc(ZonedDateTime.now());
        this.setInUtc(other.getInUtc());
    }

    public Worker()
    {
        super();
    }

    public Worker(int id, String workerCode, String workerName, double compensation)
    {
        this.ID = id;
        this.workerCode = workerCode;
        this.workerName = workerName;
        this.compensation = compensation;
    }


    public int getID()
    {
        return ID;
    }

    public void setID(int ID)
    {
        this.ID = ID;
    }

    public String getWorkerCode()
    {
        return workerCode;
    }

    public void setWorkerCode(String workerCode)
    {
        this.workerCode = workerCode;
    }

    public String getWorkerName()
    {
        return workerName;
    }

    public void setWorkerName(String workerName)
    {
        this.workerName = workerName;
    }

    public double getCompensation()
    {
        return compensation;
    }

    public void setCompensation(double compensation)
    {
        this.compensation = compensation;
    }

    public List&lt;ProjectWorkerPair&gt; getProjectWorkerPairs()
    {
        return projectWorkerPairs;
    }

    public void setProjectWorkerPairs(List&lt;ProjectWorkerPair&gt; projectWorkerPairs)
    {
        this.projectWorkerPairs = projectWorkerPairs;
    }

    public List&lt;WorkerSubscriptionPair&gt; getWorkerSubscriptionPairs()
    {
        return workerSubscriptionPairs;
    }

    public void setWorkerSubscriptionPairs(List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs)
    {
        this.workerSubscriptionPairs = workerSubscriptionPairs;
    }

    public String getAuditId()
    {
        return auditId;
    }

    public void setAuditId(String auditId)
    {
        this.auditId = auditId;
    }

    public List&lt;Subscription&gt; getSubscriptions()
    {
        return subscriptions;
    }

    public void setSubscriptions(List&lt;Subscription&gt; subscriptions)
    {
        this.subscriptions = subscriptions;
    }

    public List&lt;Project&gt; getProjects()
    {
        return projects;
    }

    public void setProjects(List&lt;Project&gt; projects)
    {
        this.projects = projects;
    }

    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        Worker worker = (Worker) o;
        return ID == worker.ID &amp;&amp;
                Objects.equals(workerCode, worker.workerCode) &amp;&amp;
                Objects.equals(workerName, worker.workerName);
    }

    @Override
    public int hashCode()
    {
        return Objects.hash(super.hashCode(), ID, workerCode, workerName);
    }
}

@Entity
@Table(name = &quot;WORKER_SUBSCRIPTION_MAP&quot;,
        uniqueConstraints={
                @UniqueConstraint(columnNames = {&quot;auditId&quot;, &quot;out_utc&quot;})
        })
public class WorkerSubscriptionPair extends BaseEntity
{
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    @Column(name=&quot;ID&quot;, updatable = false, nullable = false)
    private int ID;
    private String auditId = UUID.randomUUID().toString();
    @ManyToOne
    @JoinColumn(name = &quot;worker_id&quot;)
    private Worker worker;

    @ManyToOne
    @JoinColumn(name = &quot;subscription_id&quot;)
    private Subscription subscription;

    public WorkerSubscriptionPair(Worker worker, Subscription subscription)
    {
        this.worker = worker;
        this.subscription = subscription;
    }

    public WorkerSubscriptionPair()
    {
    }

    public int getID()
    {
        return ID;
    }

    public void setID(int ID)
    {
        this.ID = ID;
    }

    public Worker getWorker()
    {
        return worker;
    }

    public void setWorker(Worker worker)
    {
        this.worker = worker;
    }

    public Subscription getSubscription()
    {
        return subscription;
    }

    public void setSubscription(Subscription subscription)
    {
        this.subscription = subscription;
    }

    public String getAuditId()
    {
        return auditId;
    }

    public void setAuditId(String auditId)
    {
        this.auditId = auditId;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-DTO">DTO</h1><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class ConsultantDTO extends WorkerDTO
{
    private String agencyCode;

    public ConsultantDTO(Consultant consultant)
    {
        setWorkerID(consultant.getID());
        setWorkerCode(consultant.getWorkerCode());
        setWorkerName(consultant.getWorkerName());
        setCompensation(consultant.getCompensation());
        this.agencyCode = consultant.getAgencyCode();
    }

    public ConsultantDTO()
    {
    }

    public String getAgencyCode()
    {
        return agencyCode;
    }

    public void setAgencyCode(String agencyCode)
    {
        this.agencyCode = agencyCode;
    }
}

public class EmployeeDTO extends WorkerDTO
{
    private String beneCode;

    public EmployeeDTO(Employee employee)
    {
        setWorkerID(employee.getID());
        setWorkerCode(employee.getWorkerCode());
        setWorkerName(employee.getWorkerName());
        setCompensation(employee.getCompensation());
        this.beneCode = employee.getBeneCode();
    }

    public EmployeeDTO()
    {
    }

    public String getBeneCode()
    {
        return beneCode;
    }

    public void setBeneCode(String beneCode)
    {
        this.beneCode = beneCode;
    }
}

public class ProfitDTO extends ResourceSupport
{
    @JsonIgnore
    private int projectID;
    private String projectName;
    private double revenue;
    @JsonIgnore
    private double profit;
    private double compensationCost;
    private double subscriptionCost;
    private double profitability = 1.0;


    public ProfitDTO(Project project)
    {
        this.projectName = project.getProjectName();
        this.revenue = project.getRevenue();
        this.profit = project.getRevenue();
        this.projectID = project.getID();
    }

    public String getProjectName()
    {
        return projectName;
    }

    public void setProjectName(String projectName)
    {
        this.projectName = projectName;
    }

    public double getRevenue()
    {
        return revenue;
    }

    public void setRevenue(double revenue)
    {
        this.revenue = revenue;
    }

    public double getProfit()
    {
         return profit;
    }

    public void setProfit(double profit)
    {
        this.profit = profit;
    }

    public String getProfitability()
    {
        NumberFormat percentageFormat = NumberFormat.getPercentInstance();
        percentageFormat.setMinimumFractionDigits(2);
        return percentageFormat.format(profitability);
    }

    public void setProfitability(double profitability)
    {
        this.profitability = profitability;
    }

    public int getProjectID()
    {
        return projectID;
    }

    public void setProjectID(int projectID)
    {
        this.projectID = projectID;
    }

    public double getCompensationCost()
    {
        return compensationCost;
    }

    public void setCompensationCost(double compensationCost)
    {
        this.compensationCost = compensationCost;
    }

    public double getSubscriptionCost()
    {
        return subscriptionCost;
    }

    public void setSubscriptionCost(double subscriptionCost)
    {
        this.subscriptionCost = subscriptionCost;
    }

    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ProfitDTO profitDTO = (ProfitDTO) o;
        return Objects.equals(projectName, profitDTO.projectName);
    }

    @Override
    public int hashCode()
    {

        return Objects.hash(projectName);
    }
}

public class ProjectDTO extends ResourceSupport
{
    private int projectID;
    private String projectName;
    private String projectDescription;
    private double revenue;

    public ProjectDTO(Project project)
    {
        this.projectID = project.getID();
        this.projectName = project.getProjectName();
        this.projectDescription = project.getProjectDescription();
        this.revenue = project.getRevenue();
    }

    public ProjectDTO()
    {

    }

    public int getProjectID()
    {
        return projectID;
    }

    public void setProjectID(int projectID)
    {
        this.projectID = projectID;
    }

    public String getProjectName()
    {
        return projectName;
    }

    public void setProjectName(String projectName)
    {
        this.projectName = projectName;
    }

    public String getProjectDescription()
    {
        return projectDescription;
    }

    public void setProjectDescription(String projectDescription)
    {
        this.projectDescription = projectDescription;
    }

    public double getRevenue()
    {
        return revenue;
    }

    public void setRevenue(double revenue)
    {
        this.revenue = revenue;
    }
}

public class SubscriptionDTO extends ResourceSupport
{
    private int subscriptionID;
    private String subscriptionCode;
    private String subscriptionName;
    private double fees;
    private int divisor;

    public SubscriptionDTO(Subscription subscription)
    {
        this.subscriptionID = subscription.getID();
        this.subscriptionCode = subscription.getSubscriptionCode();
        this.subscriptionName = subscription.getSubscriptionName();
        this.fees = subscription.getFees();
        this.divisor = subscription.getDivisor();
    }

    public SubscriptionDTO()
    {}

    public int getSubscriptionID()
    {
        return subscriptionID;
    }

    public void setSubscriptionID(int subscriptionID)
    {
        this.subscriptionID = subscriptionID;
    }

    public String getSubscriptionCode()
    {
        return subscriptionCode;
    }

    public void setSubscriptionCode(String subscriptionCode)
    {
        this.subscriptionCode = subscriptionCode;
    }

    public String getSubscriptionName()
    {
        return subscriptionName;
    }

    public void setSubscriptionName(String subscriptionName)
    {
        this.subscriptionName = subscriptionName;
    }

    public double getFees()
    {
        return fees;
    }

    public void setFees(double fees)
    {
        this.fees = fees;
    }

    public int getDivisor()
    {
        return divisor;
    }

    public void setDivisor(int divisor)
    {
        this.divisor = divisor;
    }
}

public class WorkerDTO extends ResourceSupport
{
    private int workerID;
    private String workerCode;
    private String workerName;
    private double compensation;

    public WorkerDTO(Worker worker)
    {
        this.workerID = worker.getID();
        this.workerCode = worker.getWorkerCode();
        this.workerName = worker.getWorkerName();
        this.compensation = worker.getCompensation();
    }

    public WorkerDTO()
    {

    }

    public int getWorkerID()
    {
        return workerID;
    }

    public void setWorkerID(int workerID)
    {
        this.workerID = workerID;
    }

    public String getWorkerCode()
    {
        return workerCode;
    }

    public void setWorkerCode(String workerCode)
    {
        this.workerCode = workerCode;
    }

    public String getWorkerName()
    {
        return workerName;
    }

    public void setWorkerName(String workerName)
    {
        this.workerName = workerName;
    }

    public double getCompensation()
    {
        return compensation;
    }

    public void setCompensation(double compensation)
    {
        this.compensation = compensation;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Controllers">Controllers</h1><h2 id="SubscriptionTrackerFinal-Links">Links</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Component
public class ProjectLinks
{
    public void addLinks(ProjectDTO projectDTO, Link link)
    {
        projectDTO.add(link);
        addWorkerLinks(projectDTO, projectDTO.getProjectID());
    }

    public void addLinks(Project project, Link link)
    {
        project.add(link);
        addWorkerLinks(project, project.getID());
    }

    private void addWorkerLinks(ResourceSupport resource, int id)
    {
        Link workersLink = linkTo(methodOn(ProjectWorkerController.class)
                .getProjectsWorkers(id))
                .withRel(&quot;workers&quot;);
        resource.add(workersLink);
    }
}

@Component
public class ProjectWorkerLinks
{
    private List&lt;ProjectWorkerPair&gt; projectWorkerPairs;

    public List&lt;Resource&lt;Project&gt;&gt; createProjectWorkerResources(List&lt;ProjectWorkerPair&gt; projectWorkerPairs,
                                                                ProjectWorkerBaseController baseController)
    {
        this.projectWorkerPairs = projectWorkerPairs;

        Map&lt;Project, List&lt;Worker&gt;&gt; projectWorkersMap = projectWorkerPairs.stream()
                .collect(Collectors
                        .groupingBy(ProjectWorkerPair::getProject,
                                Collectors.mapping(ProjectWorkerPair::getWorker, Collectors.toList())));


        List&lt;Resource&lt;Project&gt;&gt; projectResources = new ArrayList&lt;&gt;();

        for(Map.Entry&lt;Project, List&lt;Worker&gt;&gt; e : projectWorkersMap.entrySet())
        {
            Project project = e.getKey();
            List&lt;Worker&gt; workers = e.getValue();

            Resource&lt;Project&gt; projectResource = baseController.createProjectWorkerResource(project, workers);

            projectResources.add(projectResource);
        }

        return projectResources;
    }

    public Resource&lt;Project&gt; createProjectWorkerResource(List&lt;ProjectWorkerPair&gt; projectWorkerPairs,
                                                         ProjectWorkerBaseController baseController)
    {
        this.projectWorkerPairs = projectWorkerPairs;

        Optional&lt;Project&gt; projectOptional = projectWorkerPairs.stream().map(ProjectWorkerPair::getProject).findFirst();
        List&lt;Worker&gt; workers = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getWorker)
                .collect(Collectors.toList());

        Project project = projectOptional.get();
        return baseController.createProjectWorkerResource(project, workers);
    }

    public List&lt;Resource&lt;Worker&gt;&gt; createWorkerProjectResources(List&lt;ProjectWorkerPair&gt; projectWorkerPairs,
                                                               ProjectWorkerBaseController baseController)
    {
        this.projectWorkerPairs = projectWorkerPairs;

        Map&lt;Worker, List&lt;Project&gt;&gt; workerProjectsMap = projectWorkerPairs.stream()
                .collect(Collectors
                        .groupingBy(ProjectWorkerPair::getWorker,
                                Collectors.mapping(ProjectWorkerPair::getProject, Collectors.toList())));


        List&lt;Resource&lt;Worker&gt;&gt; workerResources = new ArrayList&lt;&gt;();

        for(Map.Entry&lt;Worker, List&lt;Project&gt;&gt; e : workerProjectsMap.entrySet())
        {
            Worker worker = e.getKey();
            List&lt;Project&gt; projects = e.getValue();

            Resource&lt;Worker&gt; workerResource = baseController.createWorkerProjectResource(worker, projects);

            workerResources.add(workerResource);
        }

        return workerResources;
    }

    public Resource&lt;Worker&gt; createWorkerProjectResource(List&lt;ProjectWorkerPair&gt; projectWorkerPairs,
                                                        ProjectWorkerBaseController baseController)
    {
        this.projectWorkerPairs = projectWorkerPairs;

        Optional&lt;Worker&gt; workerOptional = projectWorkerPairs.stream().map(ProjectWorkerPair::getWorker).findFirst();
        List&lt;Project&gt; projects = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getProject)
                .collect(Collectors.toList());

        Worker worker = workerOptional.get();
        return baseController.createWorkerProjectResource(worker, projects);
    }

    public void addLinks(Project project,
                         Resource&lt;Project&gt; projectResource,
                         List&lt;Worker&gt; workers,
                         Link link)
    {
        NumberFormat percentageFormat = NumberFormat.getPercentInstance();
        percentageFormat.setMinimumFractionDigits(2);

        projectResource.add(link);

        for(Worker worker : workers)
        {
            double appropriation = 1.0;

            Optional&lt;ProjectWorkerPair&gt; workerProjectPairOptional = projectWorkerPairs.stream()
                    .filter(p -&gt; p.getProject().equals(project))
                    .filter(p -&gt; p.getWorker().equals(worker))
                    .findAny();
            if(workerProjectPairOptional.isPresent())
            {
                ProjectWorkerPair projectWorkerPair = workerProjectPairOptional.get();
                appropriation = projectWorkerPair.getAppropriation();
            }
            String appropriationPercent = percentageFormat.format(appropriation);

            Link workerLink = linkTo(methodOn(WorkerController.class)
                    .getWorkers(worker.getID()))
                    .withRel(&quot;worker &#39;&quot; + worker.getWorkerName() + &quot;&#39; @ &quot; + appropriationPercent);
            projectResource.add(workerLink);
        }
    }


    public void addLinks(Worker worker, Resource&lt;Worker&gt; workerResource, List&lt;Project&gt; projects, Link link)
    {
        NumberFormat percentageFormat = NumberFormat.getPercentInstance();
        percentageFormat.setMinimumFractionDigits(2);

        workerResource.add(link);

        for(Project project : projects)
        {
            double appropriation = 1.0;

            Optional&lt;ProjectWorkerPair&gt; projectWorkerPairOptional = projectWorkerPairs.stream()
                    .filter(p -&gt; p.getProject().equals(project))
                    .filter(p -&gt; p.getWorker().equals(worker))
                    .findAny();
            if(projectWorkerPairOptional.isPresent())
            {
                ProjectWorkerPair projectWorkerPair = projectWorkerPairOptional.get();
                appropriation = projectWorkerPair.getAppropriation();
            }
            String appropriationPercent = percentageFormat.format(appropriation);

            Link projectLink = linkTo(methodOn(ProjectController.class)
                    .getProjects(project.getID()))
                    .withRel(&quot;project &#39;&quot; + project.getProjectName() + &quot;&#39; @ &quot; + appropriationPercent);
            workerResource.add(projectLink);
        }
    }
}

@Component
public class SubscriptionLinks
{
    public void addLinks(SubscriptionDTO subscriptionDTO, Link link)
    {
        subscriptionDTO.add(link);
        addWorkerLinks(subscriptionDTO, subscriptionDTO.getSubscriptionID());
    }

    public void addLinks(Subscription subscription, Link link)
    {
        subscription.add(link);
        addWorkerLinks(subscription, subscription.getID());
    }

    private void addWorkerLinks(ResourceSupport resource, int id)
    {
        Link workersLink = linkTo(methodOn(WorkerSubscriptionController.class)
                .getSubscriptionsWorkers(id))
                .withRel(&quot;workers&quot;);
        resource.add(workersLink);
    }
}

@Component
public class WorkerLinks
{
    public void addLinks(WorkerDTO workerDTO, Link link)
    {
        workerDTO.add(link);
        addProjectLinks(workerDTO, workerDTO.getWorkerID());
        addSubscriptionLinks(workerDTO, workerDTO.getWorkerID());
    }

    public void addLinks(Worker worker, Link link)
    {
        worker.add(link);
        addProjectLinks(worker, worker.getID());
        addSubscriptionLinks(worker, worker.getID());
    }

    private void addProjectLinks(ResourceSupport resource, int id)
    {
        Link projectLink = linkTo(methodOn(ProjectWorkerController.class)
                .getWorkersProjects(id))
                .withRel(&quot;projects&quot;);
        resource.add(projectLink);
    }

    private void addSubscriptionLinks(ResourceSupport resource, int id)
    {
        Link subscriptionLink = linkTo(methodOn(WorkerSubscriptionController.class)
                .getWorkersSubscriptions(id))
                .withRel(&quot;subscriptions&quot;);
        resource.add(subscriptionLink);
    }
}

@Component
public class WorkerSubscriptionLinks
{
    public List&lt;Resource&lt;Worker&gt;&gt; createWorkerSubscriptionResources(Map&lt;Worker, List&lt;Subscription&gt;&gt; workerSubscriptionMap,
                                                                    WorkerSubscriptionBaseController baseController)
    {
        List&lt;Resource&lt;Worker&gt;&gt; workerResources = new ArrayList&lt;&gt;();

        for(Map.Entry&lt;Worker, List&lt;Subscription&gt;&gt; e : workerSubscriptionMap.entrySet())
        {
            Worker worker = e.getKey();
            List&lt;Subscription&gt; subscriptions = e.getValue();

            Resource&lt;Worker&gt; workerResource = baseController.createWorkerSubscriptionResource(worker, subscriptions);

            workerResources.add(workerResource);
        }

        return workerResources;
    }

    public List&lt;Resource&lt;Subscription&gt;&gt; createSubscriptionWorkerResources(Map&lt;Subscription, List&lt;Worker&gt;&gt; subscriptionWorkerMap,
                                                                          WorkerSubscriptionBaseController baseController)
    {
        List&lt;Resource&lt;Subscription&gt;&gt; subscriptionResources = new ArrayList&lt;&gt;();

        for(Map.Entry&lt;Subscription, List&lt;Worker&gt;&gt; e : subscriptionWorkerMap.entrySet())
        {
            Subscription subscription = e.getKey();
            List&lt;Worker&gt; workers = e.getValue();

            Resource&lt;Subscription&gt; subscriptionResource = baseController.createSubscriptionWorkerResource(subscription, workers);

            subscriptionResources.add(subscriptionResource);
        }

        return subscriptionResources;
    }

    public void addLinks(Worker worker, Resource&lt;Worker&gt; workerResource, List&lt;Subscription&gt; subscriptions, Link link)
    {
        workerResource.add(link);

        for(Subscription subscription : subscriptions)
        {
            Link subscriptionLink = linkTo(methodOn(SubscriptionController.class)
                    .getSubscriptions(subscription.getID()))
                    .withRel(&quot;subscription&quot;)
                    .withTitle(subscription.getSubscriptionName());
            workerResource.add(subscriptionLink);
        }
    }

    public void addLinks(Subscription subscription, Resource&lt;Subscription&gt; subscriptionResource, List&lt;Worker&gt; workers, Link link)
    {
        subscriptionResource.add(link);

        for(Worker worker : workers)
        {
            Link workerLink = linkTo(methodOn(WorkerController.class)
                    .getWorkers(worker.getID()))
                    .withRel(&quot;worker&quot;)
                    .withTitle(worker.getWorkerName());
            subscriptionResource.add(workerLink);
        }
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-Base">Base</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public abstract class ProjectWorkerBaseController
{
    abstract public Resource&lt;Project&gt; createProjectWorkerResource(Project project, List&lt;Worker&gt; workers);
    abstract public Resource&lt;Worker&gt; createWorkerProjectResource(Worker worker, List&lt;Project&gt; projects);
}

public abstract class WorkerSubscriptionBaseController
{
    abstract public Resource&lt;Worker&gt; createWorkerSubscriptionResource(Worker worker, List&lt;Subscription&gt; subscriptions);
    abstract public Resource&lt;Subscription&gt; createSubscriptionWorkerResource(Subscription subscription, List&lt;Worker&gt; workers);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-AuditControllers">Audit Controllers</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RequestMapping(value = &quot;/audit&quot;)
@RestController
public class ProjectAuditController
{
    @Autowired
    private ProjectRepository projectRepository;
    @Autowired
    private ProjectLinks projectLinks;

    @GetMapping(&quot;/projects&quot;)
    public ResponseEntity&lt;List&lt;Project&gt;&gt; getProjects(@RequestParam(defaultValue = &quot;false&quot;) boolean showAuditOnly)
    {
        List&lt;Project&gt; projects;

        if(showAuditOnly)
        {
            projects = projectRepository.findOnlyAudit();
        }
        else
        {
            projects = projectRepository.findAllWithAudit();
        }

        addLinksToProjects(projects);

        return ResponseEntity.ok(projects);
    }

    @GetMapping(&quot;/projects/{id}&quot;)
    public ResponseEntity&lt;List&lt;Project&gt;&gt; getProjects(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Project&gt; projectOptional = projectRepository.findAllById(id);
        if(!projectOptional.isPresent())
        {
            throw new NotFoundException(&quot;project-&quot; + id);
        }
        Project liveProject = projectOptional.get();

        List&lt;Project&gt; projects = projectRepository.findByAuditId(liveProject.getAuditId());

        addLinksToProjects(projects);

        return ResponseEntity.ok(projects);
    }


    private void addLinksToProjects(List&lt;Project&gt; projects)
    {
        List&lt;Resource&lt;Project&gt;&gt; projectResources = new ArrayList&lt;&gt;();

        for(Project project : projects)
        {
            Resource&lt;Project&gt; projectResource = new Resource&lt;&gt;(project);

            Link link = linkTo(methodOn(getClass()).getProjects(project.getID())).withSelfRel();
            projectLinks.addLinks(project, link);

            projectResources.add(projectResource);
        }
    }
}

@RequestMapping(value = &quot;/audit&quot;)
@RestController
public class ProjectWorkerAuditController extends ProjectWorkerBaseController
{
    @Autowired
    private ProjectWorkerMapRepository projectWorkerMapRepository;
    @Autowired
    private ProjectWorkerLinks projectWorkerLinks;


    @GetMapping(&quot;/projects/workers&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Project&gt;&gt;&gt; getProjectsWorkers()
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findAllWithAudit();
        List&lt;Resource&lt;Project&gt;&gt; projectResources = projectWorkerLinks.createProjectWorkerResources(projectWorkerPairs, this);
        return ResponseEntity.ok(projectResources);
    }

    @GetMapping(&quot;/projects/{id}/workers&quot;)
    public ResponseEntity&lt;Resource&lt;Project&gt;&gt; getProjectsWorkers(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findByProjectIdWithAudit(id);
        if(projectWorkerPairs.isEmpty())
        {
            throw new NotFoundException(&quot;project-&quot; + id);
        }

        Optional&lt;Project&gt; projectOptional = projectWorkerPairs.stream().map(ProjectWorkerPair::getProject).findFirst();
        List&lt;Worker&gt; workers = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getWorker)
                .collect(Collectors.toList());

        Project project = projectOptional.get();
        project.setWorkers(workers);

        Resource&lt;Project&gt; projectResource = createProjectWorkerResource(project, workers);
        projectResource.add(linkTo(methodOn(getClass()).getProjectsWorkers()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(projectResource);
    }

    @GetMapping(&quot;/workers/projects&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Worker&gt;&gt;&gt; getWorkersProjects()
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findAllWithAudit();

        List&lt;Resource&lt;Worker&gt;&gt; workerResources = projectWorkerLinks.createWorkerProjectResources(projectWorkerPairs, this);

        return ResponseEntity.ok(workerResources);
    }

    @GetMapping(&quot;/workers/{id}/projects&quot;)
    public ResponseEntity&lt;Resource&lt;Worker&gt;&gt; getWorkersProjects(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findByWorkerIdWithAudit(id);
        if(projectWorkerPairs.isEmpty())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }

        Optional&lt;Worker&gt; workerOptional = projectWorkerPairs.stream().map(ProjectWorkerPair::getWorker).findFirst();
        List&lt;Project&gt; projects = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getProject)
                .collect(Collectors.toList());

        Worker worker = workerOptional.get();
        worker.setProjects(projects);

        Resource&lt;Worker&gt; workerResource = createWorkerProjectResource(worker, projects);
        workerResource.add(linkTo(methodOn(getClass()).getWorkersProjects()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(workerResource);
    }


    @Override
    public Resource&lt;Project&gt; createProjectWorkerResource(Project project, List&lt;Worker&gt; workers)
    {
        Resource&lt;Project&gt; projectResource = new Resource&lt;&gt;(project);
        Link link = linkTo(methodOn(getClass()).getProjectsWorkers(project.getID())).withSelfRel();
        projectWorkerLinks.addLinks(project, projectResource, workers, link);
        return projectResource;
    }


    public Resource&lt;Worker&gt; createWorkerProjectResource(Worker worker, List&lt;Project&gt; projects)
    {
        Resource&lt;Worker&gt; workerResource = new Resource&lt;&gt;(worker);
        Link link = linkTo(methodOn(getClass()).getWorkersProjects(worker.getID())).withSelfRel();
        projectWorkerLinks.addLinks(worker, workerResource, projects, link);
        return workerResource;
    }
}

@RequestMapping(value = &quot;/audit&quot;)
@RestController
public class SubscriptionAuditController
{
    @Autowired
    private SubscriptionRepository subscriptionRepository;
    @Autowired
    private SubscriptionLinks subscriptionLinks;

    @GetMapping(&quot;/subscriptions&quot;)
    public ResponseEntity&lt;List&lt;Subscription&gt;&gt; getSubscriptions(@RequestParam(defaultValue = &quot;false&quot;) boolean showAuditOnly)
    {
        List&lt;Subscription&gt; subscriptions;

        if(showAuditOnly)
        {
            subscriptions = subscriptionRepository.findOnlyAudit();
        }
        else
        {
            subscriptions = subscriptionRepository.findAllWithAudit();
        }

        createSubscriptionResources(subscriptions);

        return ResponseEntity.ok(subscriptions);
    }


    @GetMapping(&quot;/subscriptions/{id}&quot;)
    public ResponseEntity&lt;List&lt;Subscription&gt;&gt; getSubscriptions(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Subscription&gt; subscriptionOptional = subscriptionRepository.findAllById(id);
        if(!subscriptionOptional.isPresent())
        {
            throw new NotFoundException(&quot;subscription-&quot; + id);
        }
        Subscription liveSubscription = subscriptionOptional.get();

        List&lt;Subscription&gt; subscriptions = subscriptionRepository.findByAuditId(liveSubscription.getAuditId());

        createSubscriptionResources(subscriptions);

        return ResponseEntity.ok(subscriptions);
    }

    private void createSubscriptionResources(List&lt;Subscription&gt; subscriptions)
    {

        for(Subscription subscription : subscriptions)
        {
            Link link = linkTo(methodOn(getClass()).getSubscriptions(subscription.getID())).withSelfRel();
            subscriptionLinks.addLinks(subscription, link);
        }
    }
}

@RequestMapping(value = &quot;/audit&quot;)
@RestController
public class WorkerAuditController
{
    @Autowired
    private WorkerRepository workerRepository;
    @Autowired
    private WorkerLinks workerLinks;

    @GetMapping(&quot;/workers&quot;)
    public ResponseEntity&lt;List&lt;Worker&gt;&gt; getWorkers(@RequestParam(defaultValue = &quot;false&quot;) boolean showAuditOnly)
    {
        List&lt;Worker&gt; workers;

        if(showAuditOnly)
        {
            workers = workerRepository.findOnlyAudit();
        }
        else
        {
            workers = workerRepository.findAllWithAudit();
        }

        createWorkerResources(workers);

        return ResponseEntity.ok(workers);
    }

    @GetMapping(&quot;/workers/{id}&quot;)
    public ResponseEntity&lt;List&lt;Worker&gt;&gt; getWorkers(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Worker&gt; workerOptional = workerRepository.findAllById(id);
        if(!workerOptional.isPresent())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }
        Worker liveWorker = workerOptional.get();

        List&lt;Worker&gt; workers = workerRepository.findByAuditId(liveWorker.getAuditId());

        createWorkerResources(workers);

        return ResponseEntity.ok(workers);
    }

    private void createWorkerResources(List&lt;Worker&gt; workers)
    {
        for(Worker worker : workers)
        {
            Link link = linkTo(methodOn(getClass()).getWorkers(worker.getID())).withSelfRel();
            workerLinks.addLinks(worker, link);
        }
    }
}

@RequestMapping(value = &quot;/audit&quot;)
@RestController
public class WorkerSubscriptionAuditController extends WorkerSubscriptionBaseController
{
    @Autowired
    private WorkerSubscriptionMapRepository workerSubscriptionMapRepository;
    @Autowired
    private WorkerSubscriptionLinks workerSubscriptionLinks;


    @GetMapping(&quot;/workers/subscriptions&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Worker&gt;&gt;&gt; getWorkersSubscriptions()
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findAllWithAudit();
        Map&lt;Worker, List&lt;Subscription&gt;&gt; groupedMap = workerSubscriptionPairs.stream()
                .collect(Collectors
                        .groupingBy(WorkerSubscriptionPair::getWorker,
                                Collectors.mapping(WorkerSubscriptionPair::getSubscription, Collectors.toList())));

        List&lt;Resource&lt;Worker&gt;&gt; workerResources = workerSubscriptionLinks.createWorkerSubscriptionResources(groupedMap, this);

        return ResponseEntity.ok(workerResources);
    }

    @GetMapping(&quot;/workers/{id}/subscriptions&quot;)
    public ResponseEntity&lt;Resource&lt;Worker&gt;&gt; getWorkersSubscriptions(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findByWorkerIdWithAudit(id);
        if(workerSubscriptionPairs.isEmpty())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }

        Optional&lt;Worker&gt; workerOptional = workerSubscriptionPairs.stream().map(WorkerSubscriptionPair::getWorker).findFirst();
        List&lt;Subscription&gt; subscriptions = workerSubscriptionPairs
                .stream()
                .map(WorkerSubscriptionPair::getSubscription)
                .collect(Collectors.toList());

        Worker worker = workerOptional.get();
        worker.setSubscriptions(subscriptions);

        Resource&lt;Worker&gt; workerResource = createWorkerSubscriptionResource(worker, subscriptions);
        workerResource.add(linkTo(methodOn(getClass()).getWorkersSubscriptions()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(workerResource);
    }

    @GetMapping(&quot;/subscriptions/workers&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Subscription&gt;&gt;&gt; getSubscriptionsWorkers()
    {
        List&lt;WorkerSubscriptionPair&gt; projectWorkersPairs = workerSubscriptionMapRepository.findAllWithAudit();
        Map&lt;Subscription, List&lt;Worker&gt;&gt; groupedMap = projectWorkersPairs.stream()
                .collect(Collectors
                        .groupingBy(WorkerSubscriptionPair::getSubscription,
                                Collectors.mapping(WorkerSubscriptionPair::getWorker, Collectors.toList())));

        List&lt;Resource&lt;Subscription&gt;&gt; subscriptionResources = workerSubscriptionLinks.createSubscriptionWorkerResources(groupedMap, this);

        return ResponseEntity.ok(subscriptionResources);
    }

    @GetMapping(&quot;/subscriptions/{id}/workers&quot;)
    public ResponseEntity&lt;Resource&lt;Subscription&gt;&gt; getSubscriptionsWorkers(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findBySubscriptionIdWithAudit(id);
        if(workerSubscriptionPairs.isEmpty())
        {
            throw new NotFoundException(&quot;subscription-&quot; + id);
        }

        Optional&lt;Subscription&gt; subscriptionOptional = workerSubscriptionPairs.stream().map(WorkerSubscriptionPair::getSubscription).findFirst();
        List&lt;Worker&gt; workers = workerSubscriptionPairs
                .stream()
                .map(WorkerSubscriptionPair::getWorker)
                .collect(Collectors.toList());

        Subscription subscription = subscriptionOptional.get();
        subscription.setWorkers(workers);

        Resource&lt;Subscription&gt; subscriptionResource = createSubscriptionWorkerResource(subscription, workers);
        subscriptionResource.add(linkTo(methodOn(getClass()).getSubscriptionsWorkers()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(subscriptionResource);
    }


    @Override
    public Resource&lt;Worker&gt; createWorkerSubscriptionResource(Worker worker, List&lt;Subscription&gt; subscriptions)
    {
        Resource&lt;Worker&gt; workerResource = new Resource&lt;&gt;(worker);
        Link link = linkTo(methodOn(getClass()).getWorkersSubscriptions(worker.getID())).withSelfRel();
        workerSubscriptionLinks.addLinks(worker, workerResource, subscriptions, link);
        return workerResource;
    }


    @Override
    public Resource&lt;Subscription&gt; createSubscriptionWorkerResource(Subscription subscription, List&lt;Worker&gt; workers)
    {
        Resource&lt;Subscription&gt; subscriptionResource = new Resource&lt;&gt;(subscription);
        Link link = linkTo(methodOn(getClass()).getSubscriptionsWorkers(subscription.getID())).withSelfRel();
        workerSubscriptionLinks.addLinks(subscription, subscriptionResource, workers, link);
        return subscriptionResource;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ConsultantController">ConsultantController</h2><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class ConsultantController
{
    @Autowired
    private ConsultantRepository consultantRepository;
    @Autowired
    private WorkerLinks workerLinks;
    @Autowired
    private WorkerController workerController;

    @GetMapping(&quot;/consultants&quot;)
    public ResponseEntity&lt;List&lt;ConsultantDTO&gt;&gt; getConsultants()
    {
        List&lt;Consultant&gt; consultants = consultantRepository.findAll();

        List&lt;ConsultantDTO&gt; consultantDTOs = createConsultantResources(consultants);

        return ResponseEntity.ok(consultantDTOs);
    }

    @GetMapping(&quot;/consultants/{id}&quot;)
    public ResponseEntity&lt;ConsultantDTO&gt; getConsultants(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Consultant&gt; consultantOptional = consultantRepository.findById(id);
        if(!consultantOptional.isPresent())
        {
            throw new NotFoundException(&quot;consultant-&quot; + id);
        }
        Consultant consultant = consultantOptional.get();

        ConsultantDTO consultantDTO = new ConsultantDTO(consultant);
        Link link = linkTo(methodOn(getClass()).getConsultants(consultantDTO.getWorkerID())).withSelfRel();
        workerLinks.addLinks(consultantDTO, link);
        consultantDTO.add(linkTo(methodOn(getClass()).getConsultants()).withRel(&quot;all&quot;));

        return ResponseEntity.ok(consultantDTO);
    }

    @PostMapping(&quot;/consultants&quot;)
    public ResponseEntity&lt;?&gt; createConsultant(@RequestBody Consultant consultant)
    {
        consultantRepository.save(consultant);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path(&quot;/{id}&quot;)
                .buildAndExpand(consultant.getID()).toUri();

        return ResponseEntity.created(location).build();
    }

    @Transactional
    @PutMapping(&quot;/consultants/{id}&quot;)
    public ResponseEntity&lt;?&gt; updateConsultant(@PathVariable(&quot;id&quot;) int id, @RequestBody Consultant consultant)
    {
        Optional&lt;Consultant&gt; existingConsultantOptional = consultantRepository.findById(id);
        if(!existingConsultantOptional.isPresent())
        {
            throw new NotFoundException(&quot;consultant-&quot; + id);
        }

        Consultant existingConsultant = existingConsultantOptional.get();
        Consultant auditConsultant = new Consultant(existingConsultant);
        existingConsultant.setInUtc(new Date());

        if(StringUtils.hasText(consultant.getWorkerCode()))
        {
            existingConsultant.setWorkerCode(consultant.getWorkerCode());
        }
        if(StringUtils.hasText(consultant.getWorkerName()))
        {
            existingConsultant.setWorkerName(consultant.getWorkerName());
        }
        if(StringUtils.hasText(consultant.getAgencyCode()))
        {
            existingConsultant.setAgencyCode(consultant.getAgencyCode());
        }

        consultantRepository.save(existingConsultant);
        consultantRepository.save(auditConsultant);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(existingConsultant).toUri();

        return ResponseEntity.created(location).build();
    }

    @DeleteMapping(&quot;/consultants/{id}&quot;)
    public ResponseEntity&lt;?&gt; deleteEmployee(@PathVariable(&quot;id&quot;) int id)
    {
        workerController.deleteWorker(id);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand().toUri();

        return ResponseEntity.created(location).build();
    }

    private List&lt;ConsultantDTO&gt; createConsultantResources(List&lt;Consultant&gt; consultants)
    {
        List&lt;ConsultantDTO&gt; consultantDTOs = new ArrayList&lt;&gt;();

        for(Consultant consultant : consultants)
        {
            ConsultantDTO consultantDTO = new ConsultantDTO(consultant);
            Link link = linkTo(methodOn(getClass()).getConsultants(consultantDTO.getWorkerID())).withSelfRel();
            workerLinks.addLinks(consultantDTO, link);
            consultantDTOs.add(consultantDTO);
        }
        return consultantDTOs;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-EmployeeController">EmployeeController</h2><div class="table-wrap"><table data-layout="wide" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class EmployeeController
{
    @Autowired
    private EmployeeRepository employeeRepository;
    @Autowired
    private WorkerLinks workerLinks;
    @Autowired
    private WorkerController workerController;

    @GetMapping(&quot;/employees&quot;)
    public ResponseEntity&lt;List&lt;EmployeeDTO&gt;&gt; getEmployees()
    {
        List&lt;Employee&gt; employees = employeeRepository.findAll();

        List&lt;EmployeeDTO&gt; employeeDTOs = createEmployeeResources(employees);

        return ResponseEntity.ok(employeeDTOs);
    }

    @GetMapping(&quot;/employees/{id}&quot;)
    public ResponseEntity&lt;EmployeeDTO&gt; getEmployees(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Employee&gt; employeeOptional = employeeRepository.findById(id);
        if(!employeeOptional.isPresent())
        {
            throw new NotFoundException(&quot;employee-&quot; + id);
        }
        Employee employee = employeeOptional.get();

        EmployeeDTO employeeDTO = new EmployeeDTO(employee);
        Link link = linkTo(methodOn(getClass()).getEmployees(employeeDTO.getWorkerID())).withSelfRel();
        workerLinks.addLinks(employeeDTO, link);
        employeeDTO.add(linkTo(methodOn(getClass()).getEmployees()).withRel(&quot;all&quot;));

        return ResponseEntity.ok(employeeDTO);
    }

    @PostMapping(&quot;/employees&quot;)
    public ResponseEntity&lt;?&gt; createEmployee(@RequestBody Employee employee)
    {
        employeeRepository.save(employee);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path(&quot;/{id}&quot;)
                .buildAndExpand(employee.getID()).toUri();

        return ResponseEntity.created(location).build();
    }

    @Transactional
    @PutMapping(&quot;/employees/{id}&quot;)
    public ResponseEntity&lt;?&gt; updateEmployee(@PathVariable(&quot;id&quot;) int id, @RequestBody Employee employee)
    {
        Optional&lt;Employee&gt; existingEmployeeOptional = employeeRepository.findById(id);
        if(!existingEmployeeOptional.isPresent())
        {
            throw new NotFoundException(&quot;employee-&quot; + id);
        }

        Employee existingEmployee = existingEmployeeOptional.get();
        Employee auditEmployee = new Employee(existingEmployee);
        existingEmployee.setInUtc(new Date());

        if(StringUtils.hasText(employee.getWorkerCode()))
        {
            existingEmployee.setWorkerCode(employee.getWorkerCode());
        }
        if(StringUtils.hasText(employee.getWorkerName()))
        {
            existingEmployee.setWorkerName(employee.getWorkerName());
        }
        if(StringUtils.hasText(employee.getBeneCode()))
        {
            existingEmployee.setBeneCode(employee.getBeneCode());
        }

        employeeRepository.save(existingEmployee);
        employeeRepository.save(auditEmployee);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(existingEmployee).toUri();

        return ResponseEntity.created(location).build();
    }

    @DeleteMapping(&quot;/employees/{id}&quot;)
    public ResponseEntity&lt;?&gt; deleteEmployee(@PathVariable(&quot;id&quot;) int id)
    {
        workerController.deleteWorker(id);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand().toUri();

        return ResponseEntity.created(location).build();
    }

    private List&lt;EmployeeDTO&gt; createEmployeeResources(List&lt;Employee&gt; employees)
    {
        List&lt;EmployeeDTO&gt; employeeDTOs = new ArrayList&lt;&gt;();

        for(Employee employee : employees)
        {
            EmployeeDTO employeeDTO = new EmployeeDTO(employee);
            Link link = linkTo(methodOn(getClass()).getEmployees(employeeDTO.getWorkerID())).withSelfRel();
            workerLinks.addLinks(employeeDTO, link);
            employeeDTOs.add(employeeDTO);
        }
        return employeeDTOs;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ProfitController">ProfitController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/*
    Representation of data from data.sql
    ====================================
    Project Revenue:
    ----------------
    P1  -   1,200,000
    P2  -   700,000
    P3  -   2,300,000

    Worker Salaries
    -----------------
    Worker    Salary
    ------------------
    1           120000
    2           240000
    3           190000
    4           185000

    Project Worker Appropriation
    ------------------------------
    Project Revenue Worker Appropriation          Calculation
    --------------------------------------------------------------------------------------------------
    1       1200000 1(.8) + 3(.9)                   1200000 - .8 * 120000 - .9 * 190000 = 933000
    2       700000  2(.6) + 4(.3)                   700000 - .6 * 240000 - .3 * 185000  = 500500
    3       2300000 1(.2) + 2(.4) + 3(.1) + 4(.7)   2300000 - .2 * 120000 - .4 * 240000 - .1 * 190000 - .7 * 185000 = 2031500
*/
@RestController
public class ProfitController
{
    @Autowired
    private WorkerSubscriptionMapRepository workerSubscriptionMapRepository;
    @Autowired
    private ProjectWorkerMapRepository projectWorkerMapRepository;

    @TrackTime
    @GetMapping(&quot;/profits&quot;)
    public ResponseEntity&lt;List&lt;ProfitDTO&gt;&gt; getProfits()
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findAll();

        //  Collection of live projects with their original revenue
        List&lt;ProfitDTO&gt; profitDTOs = projectWorkerMapRepository
                .findAll()
                .stream()
                .map(ProjectWorkerPair::getProject)
                .distinct()
                .map(ProfitDTO::new)
                .map(p -&gt; { p.add(linkTo(methodOn(ProjectController.class).getProjects(p.getProjectID())).withRel(&quot;project&quot;)); return p;})
                .collect(Collectors.toList());

        //  Worker to project appropriation map
        Map&lt;Worker, List&lt;Double&gt;&gt; workerProjectsAppropriationMap = projectWorkerPairs
                .stream()
                .collect(Collectors.groupingBy(ProjectWorkerPair::getWorker,
                        Collectors.mapping(ProjectWorkerPair::getAppropriation, Collectors.toList())));

        //  Find assigned workers
        Map&lt;Worker, List&lt;Project&gt;&gt; workerProjectsMap = projectWorkerPairs
                .stream()
                .collect(Collectors.groupingBy(ProjectWorkerPair::getWorker,
                        Collectors.mapping(ProjectWorkerPair::getProject, Collectors.toList())));

        for(Map.Entry&lt;Worker, List&lt;Project&gt;&gt; entry : workerProjectsMap.entrySet())
        {
            Worker worker = entry.getKey();
            List&lt;Project&gt; projects = entry.getValue();

            List&lt;Double&gt; projectAppropriations = workerProjectsAppropriationMap.get(worker);
            for(int i = 0; i &lt; projects.size(); ++i)
            {
                Project project = projects.get(i);
                ProfitDTO profitDTO = new ProfitDTO(project);
                double appropriation = projectAppropriations.get(i);
                double workerCompensation = worker.getCompensation();
                Optional&lt;ProfitDTO&gt; profitDTOOptional = profitDTOs.stream().filter(profitDTO::equals).findAny();
                if(profitDTOOptional.isPresent())
                {
                    profitDTO = profitDTOOptional.get();
                    double compensationCost = appropriation * workerCompensation;
                    double subscriptionCost = appropriation * getWorkerSubscriptionCosts(worker);
                    double adjustedProfit = profitDTO.getProfit() - compensationCost - subscriptionCost;
                    profitDTO.setProfit(adjustedProfit);
                    profitDTO.setProfitability(adjustedProfit / profitDTO.getRevenue());
                    profitDTO.setCompensationCost(profitDTO.getCompensationCost() + compensationCost);
                    profitDTO.setSubscriptionCost(profitDTO.getSubscriptionCost() + subscriptionCost);
                }
            }
        }

        return ResponseEntity.ok(profitDTOs);
    }

    private double getWorkerSubscriptionCosts(Worker worker)
    {
        List&lt;Subscription&gt; subscriptions = workerSubscriptionMapRepository
                .findByWorkerId(worker.getID())
                .stream()
                .map(WorkerSubscriptionPair::getSubscription)
                .collect(Collectors.toList());

        double sum = subscriptions.stream().collect(Collectors.summingDouble(x -&gt; x.getFees() / x.getDivisor()));
        return sum;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ProjectController">ProjectController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class ProjectController
{
    @Autowired
    private ProjectRepository projectRepository;
    @Autowired
    private ProjectWorkerMapRepository projectWorkerMapRepository;
    @Autowired
    private ProjectLinks projectLinks;

    @GetMapping(&quot;/projects&quot;)
    public ResponseEntity&lt;List&lt;ProjectDTO&gt;&gt; getProjects()
    {
        List&lt;Project&gt; projects = projectRepository.findAll();

        List&lt;ProjectDTO&gt; projectResources = createProjectResources(projects);

        return ResponseEntity.ok(projectResources);
    }

    @GetMapping(&quot;/projects/{id}&quot;)
    public ResponseEntity&lt;ProjectDTO&gt; getProjects(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Project&gt; projectOptional = projectRepository.findById(id);
        if(!projectOptional.isPresent())
        {
            throw new NotFoundException(&quot;project-&quot; + id);
        }
        Project project = projectOptional.get();

        ProjectDTO projectDTO = new ProjectDTO(project);
        Link link = linkTo(methodOn(getClass()).getProjects(projectDTO.getProjectID())).withSelfRel();
        projectLinks.addLinks(projectDTO, link);
        projectDTO.add(linkTo(methodOn(getClass()).getProjects()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(projectDTO);
    }

    @LogInputOutput
    @PostMapping(&quot;/projects&quot;)
    public ResponseEntity&lt;?&gt; createProject(@RequestBody @Valid Project project)
    {
        projectRepository.save(project);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path(&quot;/{id}&quot;)
                .buildAndExpand(project.getID()).toUri();

        return ResponseEntity.created(location).build();
    }

    @Transactional
    @PutMapping(&quot;/projects/{id}&quot;)
    public ResponseEntity&lt;?&gt; updateProject(@PathVariable(&quot;id&quot;) int id, @RequestBody Project project)
    {
        Optional&lt;Project&gt; existingProjectOptional = projectRepository.findById(id);
        if(!existingProjectOptional.isPresent())
        {
            throw new NotFoundException(&quot;project-&quot; + id);
        }

        Project existingProject = existingProjectOptional.get();
        Project autitProject = new Project(existingProject);
        existingProject.setInUtc(new Date());

        if(StringUtils.hasText(project.getProjectName()))
        {
            existingProject.setProjectName(project.getProjectName());
        }
        if(StringUtils.hasText(project.getProjectDescription()))
        {
            existingProject.setProjectDescription(project.getProjectDescription());
        }

        projectRepository.save(existingProject);
        projectRepository.save(autitProject);


        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(existingProject).toUri();

        return ResponseEntity.created(location).build();
    }

    @DeleteMapping(&quot;/projects/{id}&quot;)
    public ResponseEntity&lt;?&gt; deleteProject(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findByProjectId(id);
        if(!projectWorkerPairs.isEmpty())
        {
            throw new ProjectViolationException(&quot;worker exist for project-&quot; + id);
        }

        Optional&lt;Project&gt; existingProjectOptional = projectRepository.findById(id);
        if(!existingProjectOptional.isPresent())
        {
            throw new NotFoundException(&quot;project-&quot; + id);
        }

        Project project = existingProjectOptional.get();
        project.setOutUtc(ZonedDateTime.now());
        projectRepository.save(project);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand().toUri();

        return ResponseEntity.created(location).build();
    }


    private List&lt;ProjectDTO&gt; createProjectResources(List&lt;Project&gt; projects)
    {
        List&lt;ProjectDTO&gt; projectResources = new ArrayList&lt;&gt;();

        for(Project project : projects)
        {
            ProjectDTO projectDTO = new ProjectDTO(project);
            Link link = linkTo(methodOn(getClass()).getProjects(projectDTO.getProjectID())).withSelfRel();
            projectLinks.addLinks(projectDTO, link);

            projectResources.add(projectDTO);
        }
        return projectResources;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ProjectCriteriaController">ProjectCriteriaController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class ProjectCriteriaController
{
    @Autowired
    private EntityManager entityManager;
    @Autowired
    private ProjectLinks projectLinks;

    @GetMapping(&quot;/criteria/projects&quot;)
    public ResponseEntity&lt;List&lt;ProjectDTO&gt;&gt; getProjects()
    {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Project&gt; readerQuery = cb.createQuery(Project.class);
        Root&lt;Project&gt; root = readerQuery.from(Project.class);
        readerQuery.select(root);
        TypedQuery&lt;Project&gt; typedQuery = entityManager.createQuery(readerQuery);
        List&lt;Project&gt; projects = typedQuery.getResultList();

        List&lt;ProjectDTO&gt; projectResources = createProjectResources(projects);
        return ResponseEntity.ok(projectResources);
    }

    @GetMapping(&quot;/criteria/projects/{id}&quot;)
    public ResponseEntity&lt;ProjectDTO&gt; getProjects(@PathVariable(&quot;id&quot;) int id)
    {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery&lt;Project&gt; readerQuery = cb.createQuery(Project.class);
        Root&lt;Project&gt; root = readerQuery.from(Project.class);

        ParameterExpression&lt;Integer&gt; idParam = cb.parameter(Integer.class);
        readerQuery.select(root).where(cb.equal(root.get(&quot;ID&quot;), idParam));

        TypedQuery&lt;Project&gt; typedQuery = entityManager.createQuery(readerQuery);
        typedQuery.setParameter(idParam, id);
        Project project = typedQuery.getSingleResult();

        ProjectDTO projectDTO = new ProjectDTO(project);

        Link link = linkTo(methodOn(getClass()).getProjects(projectDTO.getProjectID())).withSelfRel();
        projectLinks.addLinks(projectDTO, link);
        projectDTO.add(linkTo(methodOn(getClass()).getProjects()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(projectDTO);
    }

    private List&lt;ProjectDTO&gt; createProjectResources(List&lt;Project&gt; projects)
    {
        List&lt;ProjectDTO&gt; projectResources = new ArrayList&lt;&gt;();

        for(Project project : projects)
        {
            ProjectDTO projectDTO = new ProjectDTO(project);
            Link link = linkTo(methodOn(getClass()).getProjects(projectDTO.getProjectID())).withSelfRel();
            projectLinks.addLinks(projectDTO, link);

            projectResources.add(projectDTO);
        }
        return projectResources;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ProjectJpqlController">ProjectJpqlController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class ProjectJpqlController
{
    @Autowired
    private EntityManager entityManager;
    @Autowired
    private ProjectLinks projectLinks;

    @GetMapping(&quot;/jpql/projects&quot;)
    public ResponseEntity&lt;List&lt;ProjectDTO&gt;&gt; getProjects()
    {
        List&lt;Project&gt; projects = entityManager.createQuery(&quot;from Project where outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING,
                Project.class).getResultList();

        List&lt;ProjectDTO&gt; projectResources = createProjectResources(projects);
        return ResponseEntity.ok(projectResources);
    }

    @GetMapping(&quot;/jpql/projects/{id}&quot;)
    public ResponseEntity&lt;ProjectDTO&gt; getProjects(@PathVariable(&quot;id&quot;) int id)
    {
        TypedQuery&lt;Project&gt; readerQuery = entityManager.createQuery(&quot;from Project where id =:id and outUtc = &quot; + BaseEntity.DATE_INFINITY_STRING,
                Project.class);
        readerQuery.setParameter(&quot;id&quot;, id);
        Project project = readerQuery.getSingleResult();

        ProjectDTO projectDTO = new ProjectDTO(project);

        Link link = linkTo(methodOn(getClass()).getProjects(projectDTO.getProjectID())).withSelfRel();
        projectLinks.addLinks(projectDTO, link);
        projectDTO.add(linkTo(methodOn(getClass()).getProjects()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(projectDTO);
    }


    private List&lt;ProjectDTO&gt; createProjectResources(List&lt;Project&gt; projects)
    {
        List&lt;ProjectDTO&gt; projectResources = new ArrayList&lt;&gt;();

        for(Project project : projects)
        {
            ProjectDTO projectDTO = new ProjectDTO(project);
            Link link = linkTo(methodOn(getClass()).getProjects(projectDTO.getProjectID())).withSelfRel();
            projectLinks.addLinks(projectDTO, link);

            projectResources.add(projectDTO);
        }
        return projectResources;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ProjectWorkerController">ProjectWorkerController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class ProjectWorkerController extends ProjectWorkerBaseController
{
    @Autowired
    private ProjectWorkerMapRepository projectWorkerMapRepository;
    @Autowired
    private ProjectRepository projectRepository;
    @Autowired
    private WorkerRepository workerRepository;
    @Autowired
    private ProjectWorkerLinks projectWorkerLinks;


    @GetMapping(&quot;/projects/workers&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Project&gt;&gt;&gt; getProjectsWorkers()
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findAll();
        List&lt;Resource&lt;Project&gt;&gt; projectResources = projectWorkerLinks.createProjectWorkerResources(projectWorkerPairs, this);
        return ResponseEntity.ok(projectResources);
    }

    @GetMapping(&quot;/projects/{id}/workers&quot;)
    public ResponseEntity&lt;Resource&lt;Project&gt;&gt; getProjectsWorkers(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findByProjectId(id);
        if(projectWorkerPairs.isEmpty())
        {
            throw new NotFoundException(&quot;project-&quot; + id);
        }

        Optional&lt;Project&gt; projectOptional = projectWorkerPairs.stream().map(ProjectWorkerPair::getProject).findFirst();
        List&lt;Worker&gt; workers = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getWorker)
                .collect(Collectors.toList());

        Project project = projectOptional.get();
        project.setWorkers(workers);


        Resource&lt;Project&gt; projectResource = projectWorkerLinks.createProjectWorkerResource(projectWorkerPairs, this);

        projectResource.add(linkTo(methodOn(getClass()).getProjectsWorkers()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(projectResource);
    }

    @PostMapping(&quot;/projects/{projectId}/workers/{workerId}/appropriation/{appropriation}&quot;)
    public ResponseEntity&lt;?&gt; addWorkerToProject(@PathVariable(&quot;projectId&quot;) int projectId,
                                                  @PathVariable(&quot;workerId&quot;) int workerId,
                                                  @PathVariable(&quot;appropriation&quot;) int appropriation)
    {
        return createAssociation(projectId, workerId, appropriation);
    }

    @DeleteMapping(&quot;/projects/{projectId}/workers/{workerId}&quot;)
    public ResponseEntity&lt;?&gt; deleteWorkerFromProject(@PathVariable(&quot;projectId&quot;) int projectId,
                                                        @PathVariable(&quot;workerId&quot;) int workerId)
    {
        return deleteAssociation(projectId, workerId);
    }


    @GetMapping(&quot;/workers/projects&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Worker&gt;&gt;&gt; getWorkersProjects()
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findAll();

        List&lt;Resource&lt;Worker&gt;&gt; workerResources = projectWorkerLinks.createWorkerProjectResources(projectWorkerPairs, this);

        return ResponseEntity.ok(workerResources);
    }

    @GetMapping(&quot;/workers/{id}/projects&quot;)
    public ResponseEntity&lt;Resource&lt;Worker&gt;&gt; getWorkersProjects(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findByWorkerId(id);
        if(projectWorkerPairs.isEmpty())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }


        Optional&lt;Worker&gt; workerOptional = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getWorker)
                .findFirst();
        List&lt;Project&gt; projects = projectWorkerPairs
                .stream()
                .map(ProjectWorkerPair::getProject)
                .collect(Collectors.toList());

        Worker worker = workerOptional.get();
        worker.setProjects(projects);


        Resource&lt;Worker&gt; workerResource = projectWorkerLinks.createWorkerProjectResource(projectWorkerPairs, this);

        workerResource.add(linkTo(methodOn(getClass()).getWorkersProjects()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(workerResource);
    }

    @PostMapping(&quot;/workers/{workerId}/projects/{projectId}/appropriation/{appropriation}&quot;)
    public ResponseEntity&lt;?&gt; addProjectToWorker(@PathVariable(&quot;workerId&quot;) int workerId,
                                                  @PathVariable(&quot;projectId&quot;) int projectId,
                                                  @PathVariable(&quot;appropriation&quot;) int appropriation)
    {
        return createAssociation(projectId, workerId, appropriation);
    }

    @DeleteMapping(&quot;/workers/{workerId}/projects/{projectId}&quot;)
    public ResponseEntity&lt;?&gt; deleteProjectFromWorker(@PathVariable(&quot;workerId&quot;) int workerId,
                                                     @PathVariable(&quot;projectId&quot;) int projectId)
    {
        return deleteAssociation(projectId, workerId);
    }


    private ResponseEntity&lt;?&gt; createAssociation(int projectId, int workerId, double appropriation)
    {
        Optional&lt;Project&gt; projectOptional = projectRepository.findById(projectId);
        if (!projectOptional.isPresent())
        {
            throw new NotFoundException(&quot;project-&quot; + projectId);
        }
        Optional&lt;Worker&gt; workerOptional = workerRepository.findById(workerId);
        if (!workerOptional.isPresent())
        {
            throw new NotFoundException(&quot;worker-&quot; + workerId);
        }

        Project project = projectOptional.get();
        Worker worker = workerOptional.get();

        //  Check to make sure this association does not already exists
        List&lt;Worker&gt; workers = project.getProjectWorkerPairs().stream().map(ProjectWorkerPair::getWorker).collect(Collectors.toList());
        if(!workers.contains(worker))
        {
            ProjectWorkerPair projectWorkerPair = new ProjectWorkerPair(project, worker, appropriation);
            projectWorkerMapRepository.save(projectWorkerPair);

            URI location = ServletUriComponentsBuilder
                    .fromCurrentRequest()
                    .buildAndExpand(project.getID(), worker.getID())
                    .toUri();
            return ResponseEntity.created(location).build();
        }

        throw new AlreadyExistsException(&quot;projectId-&quot; + projectId + &quot;, workerId-&quot; + workerId);
    }

    private ResponseEntity&lt;?&gt; deleteAssociation(int projectId, int workerId)
    {
        Optional&lt;ProjectWorkerPair&gt; projectWorkerPairOptional =
                projectWorkerMapRepository.findByProjectIdWorkerId(projectId, workerId);
        if(!projectWorkerPairOptional.isPresent())
        {
            throw new NotFoundException(&quot;projectId-&quot; + projectId + &quot;, workerId-&quot; + workerId);
        }

        ProjectWorkerPair projectWorkerPair = projectWorkerPairOptional.get();
        projectWorkerPair.setOutUtc(ZonedDateTime.now());
        projectWorkerMapRepository.save(projectWorkerPair);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(projectWorkerPair).toUri();

        return ResponseEntity.created(location).build();
    }


    public Resource&lt;Project&gt; createProjectWorkerResource(Project project, List&lt;Worker&gt; workers)
    {
        Resource&lt;Project&gt; projectResource = new Resource&lt;&gt;(project);
        Link link = linkTo(methodOn(getClass()).getProjectsWorkers(project.getID())).withSelfRel();
        projectWorkerLinks.addLinks(project, projectResource, workers, link);
        return projectResource;
    }

    public Resource&lt;Worker&gt; createWorkerProjectResource(Worker worker, List&lt;Project&gt; projects)
    {
        Resource&lt;Worker&gt; workerResource = new Resource&lt;&gt;(worker);
        Link link = linkTo(methodOn(getClass()).getWorkersProjects(worker.getID())).withSelfRel();
        projectWorkerLinks.addLinks(worker, workerResource, projects, link);
        return workerResource;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-SubscriptionController">SubscriptionController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class SubscriptionController
{
    @Autowired
    private SubscriptionRepository subscriptionRepository;
    @Autowired
    private WorkerSubscriptionMapRepository workerSubscriptionMapRepository;
    @Autowired
    private SubscriptionLinks subscriptionLinks;

    @GetMapping(&quot;/subscriptions&quot;)
    public ResponseEntity&lt;List&lt;SubscriptionDTO&gt;&gt; getSubscriptions()
    {
        List&lt;Subscription&gt; subscriptions = subscriptionRepository.findAll();

        List&lt;SubscriptionDTO&gt; subscriptionDTOs = createSubscriptionResources(subscriptions);

        return ResponseEntity.ok(subscriptionDTOs);
    }

    @GetMapping(&quot;/subscriptions/{id}&quot;)
    public ResponseEntity&lt;SubscriptionDTO&gt; getSubscriptions(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Subscription&gt; subscriptionOptional = subscriptionRepository.findById(id);
        if(!subscriptionOptional.isPresent())
        {
            throw new NotFoundException(&quot;subscription-&quot; + id);
        }
        Subscription subscription = subscriptionOptional.get();

        SubscriptionDTO subscriptionDTO = new SubscriptionDTO(subscription);
        Link link = linkTo(methodOn(getClass()).getSubscriptions(subscriptionDTO.getSubscriptionID())).withSelfRel();
        subscriptionLinks.addLinks(subscriptionDTO, link);
        subscriptionDTO.add(linkTo(methodOn(getClass()).getSubscriptions()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(subscriptionDTO);
    }

    @PostMapping(&quot;/subscriptions&quot;)
    public ResponseEntity&lt;?&gt; createSubscription(@RequestBody Subscription subscription)
    {
        subscriptionRepository.save(subscription);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path(&quot;/{id}&quot;)
                .buildAndExpand(subscription.getID()).toUri();

        return ResponseEntity.created(location).build();
    }

    @Transactional
    @PutMapping(&quot;/subscriptions/{id}&quot;)
    public ResponseEntity&lt;?&gt; updateSubscription(@PathVariable(&quot;id&quot;) int id, @RequestBody Subscription subscription)
    {
        Optional&lt;Subscription&gt; existingSubscriptionOptional = subscriptionRepository.findById(id);
        if(!existingSubscriptionOptional.isPresent())
        {
            throw new NotFoundException(&quot;subscription-&quot; + id);
        }

        Subscription existingSubscription = existingSubscriptionOptional.get();
        Subscription autitSubscription = new Subscription(existingSubscription);
        existingSubscription.setInUtc(new Date());

        if(StringUtils.hasText(subscription.getSubscriptionCode()))
        {
            existingSubscription.setSubscriptionCode(subscription.getSubscriptionCode());
        }
        if(StringUtils.hasText(subscription.getSubscriptionName()))
        {
            existingSubscription.setSubscriptionName(subscription.getSubscriptionName());
        }

        subscriptionRepository.save(existingSubscription);
        subscriptionRepository.save(autitSubscription);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(existingSubscription).toUri();

        return ResponseEntity.created(location).build();
    }

    @DeleteMapping(&quot;/subscriptions/{id}&quot;)
    public ResponseEntity&lt;?&gt; deleteSubscription(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findBySubscriptionId(id);
        if(!workerSubscriptionPairs.isEmpty())
        {
            throw new ProjectViolationException(&quot;subscription exist for worker-&quot; + id);
        }

        Optional&lt;Subscription&gt; existingSubscriptionOptional = subscriptionRepository.findById(id);
        if(!existingSubscriptionOptional.isPresent())
        {
            throw new NotFoundException(&quot;subscription-&quot; + id);
        }

        Subscription subscription = existingSubscriptionOptional.get();
        subscription.setOutUtc(ZonedDateTime.now());
        subscriptionRepository.save(subscription);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand().toUri();

        return ResponseEntity.created(location).build();
    }

    private List&lt;SubscriptionDTO&gt; createSubscriptionResources(List&lt;Subscription&gt; subscriptions)
    {
        List&lt;SubscriptionDTO&gt; subscriptionDTOs = new ArrayList&lt;&gt;();

        for(Subscription subscription : subscriptions)
        {
            SubscriptionDTO subscriptionDTO = new SubscriptionDTO(subscription);
            Link link = linkTo(methodOn(getClass()).getSubscriptions(subscriptionDTO.getSubscriptionID())).withSelfRel();
            subscriptionLinks.addLinks(subscriptionDTO, link);

            subscriptionDTOs.add(subscriptionDTO);
        }
        return subscriptionDTOs;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-WorkerController">WorkerController</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class WorkerController
{
    @Autowired
    private WorkerRepository workerRepository;
    @Autowired
    private WorkerSubscriptionMapRepository workerSubscriptionMapRepository;
    @Autowired
    private ProjectWorkerMapRepository projectWorkerMapRepository;
    @Autowired
    private WorkerLinks workerLinks;

    @GetMapping(&quot;/workers&quot;)
    public ResponseEntity&lt;List&lt;WorkerDTO&gt;&gt; getWorkers()
    {
        List&lt;Worker&gt; workers = workerRepository.findAll();

        List&lt;WorkerDTO&gt; workerDTOs = createWorkerResources(workers);

        return ResponseEntity.ok(workerDTOs);
    }

    @GetMapping(&quot;/workers/{id}&quot;)
    public ResponseEntity&lt;WorkerDTO&gt; getWorkers(@PathVariable(&quot;id&quot;) int id)
    {
        Optional&lt;Worker&gt; workerOptional = workerRepository.findById(id);
        if(!workerOptional.isPresent())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }
        Worker worker = workerOptional.get();

        WorkerDTO workerDTO = new WorkerDTO(worker);
        Link link = linkTo(methodOn(getClass()).getWorkers(workerDTO.getWorkerID())).withSelfRel();
        workerLinks.addLinks(workerDTO, link);
        workerDTO.add(linkTo(methodOn(getClass()).getWorkers()).withRel(&quot;all&quot;));

        return ResponseEntity.ok(workerDTO);
    }


    @PostMapping(&quot;/workers&quot;)
    public ResponseEntity&lt;?&gt; createWorker(@RequestBody Worker worker)
    {
        workerRepository.save(worker);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path(&quot;/{id}&quot;)
                .buildAndExpand(worker.getID()).toUri();

        return ResponseEntity.created(location).build();
    }

    @Transactional
    @PutMapping(&quot;/workers/{id}&quot;)
    public ResponseEntity&lt;?&gt; updateWorker(@PathVariable(&quot;id&quot;) int id, @RequestBody Worker worker)
    {
        Optional&lt;Worker&gt; existingWorkerOptional = workerRepository.findById(id);
        if(!existingWorkerOptional.isPresent())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }

        Worker existingWorker = existingWorkerOptional.get();
        Worker auditWorker = new Worker(existingWorker);
        existingWorker.setInUtc(new Date());

        if(StringUtils.hasText(worker.getWorkerCode()))
        {
            existingWorker.setWorkerCode(worker.getWorkerCode());
        }
        if(StringUtils.hasText(worker.getWorkerName()))
        {
            existingWorker.setWorkerName(worker.getWorkerName());
        }

        workerRepository.save(existingWorker);
        workerRepository.save(auditWorker);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(existingWorker).toUri();

        return ResponseEntity.created(location).build();
    }

    @DeleteMapping(&quot;/workers/{id}&quot;)
    public ResponseEntity&lt;?&gt; deleteWorker(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;ProjectWorkerPair&gt; projectWorkerPairs = projectWorkerMapRepository.findByWorkerId(id);
        if(!projectWorkerPairs.isEmpty())
        {
            throw new ProjectViolationException(&quot;projects exist for worker-&quot; + id);
        }

        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findByWorkerId(id);
        if(!workerSubscriptionPairs.isEmpty())
        {
            throw new SubscriptionViolationException(&quot;subscription exist for worker-&quot; + id);
        }

        Optional&lt;Worker&gt; existingWorkerOptional = workerRepository.findById(id);
        if(!existingWorkerOptional.isPresent())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }

        Worker worker = existingWorkerOptional.get();
        worker.setOutUtc(ZonedDateTime.now());
        workerRepository.save(worker);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand().toUri();

        return ResponseEntity.created(location).build();
    }

    private List&lt;WorkerDTO&gt; createWorkerResources(List&lt;Worker&gt; workers)
    {
        List&lt;WorkerDTO&gt; workerDTOs = new ArrayList&lt;&gt;();

        for(Worker worker : workers)
        {
            WorkerDTO workerDTO = new WorkerDTO(worker);
            Link link = linkTo(methodOn(getClass()).getWorkers(workerDTO.getWorkerID())).withSelfRel();
            workerLinks.addLinks(workerDTO, link);
            workerDTOs.add(workerDTO);
        }
        return workerDTOs;
    }
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 1539.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RestController
public class WorkerSubscriptionController extends WorkerSubscriptionBaseController
{
    @Autowired
    private WorkerSubscriptionMapRepository workerSubscriptionMapRepository;
    @Autowired
    private WorkerRepository workerRepository;
    @Autowired
    private SubscriptionRepository subscriptionRepository;
    @Autowired
    private WorkerSubscriptionLinks workerSubscriptionLinks;

    @GetMapping(&quot;/workers/subscriptions&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Worker&gt;&gt;&gt; getWorkersSubscriptions()
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findAll();
        Map&lt;Worker, List&lt;Subscription&gt;&gt; groupedMap = workerSubscriptionPairs.stream()
                .collect(Collectors
                        .groupingBy(WorkerSubscriptionPair::getWorker,
                                Collectors.mapping(WorkerSubscriptionPair::getSubscription, Collectors.toList())));

        List&lt;Resource&lt;Worker&gt;&gt; workerResources = workerSubscriptionLinks.createWorkerSubscriptionResources(groupedMap, this);

        return ResponseEntity.ok(workerResources);
    }


    @GetMapping(&quot;/workers/{id}/subscriptions&quot;)
    public ResponseEntity&lt;Resource&lt;Worker&gt;&gt; getWorkersSubscriptions(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findByWorkerId(id);
        if(workerSubscriptionPairs.isEmpty())
        {
            throw new NotFoundException(&quot;worker-&quot; + id);
        }

        Optional&lt;Worker&gt; workerOptional = workerSubscriptionPairs.stream().map(WorkerSubscriptionPair::getWorker).findFirst();
        List&lt;Subscription&gt; subscriptions = workerSubscriptionPairs
                .stream()
                .map(WorkerSubscriptionPair::getSubscription)
                .collect(Collectors.toList());

        Worker worker = workerOptional.get();
        worker.setSubscriptions(subscriptions);

        Resource&lt;Worker&gt; workerResource = createWorkerSubscriptionResource(worker, subscriptions);
        workerResource.add(linkTo(methodOn(getClass()).getWorkersSubscriptions()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(workerResource);
    }

    @PostMapping(&quot;/workers/{workerId}/subscriptions/{subscriptionId}&quot;)
    public ResponseEntity&lt;?&gt; addSubscriptionToWorker(@PathVariable(&quot;workerId&quot;) int workerId,
                                                       @PathVariable(&quot;subscriptionId&quot;) int subscriptionId)
    {
        return createAssociation(workerId, subscriptionId);
    }

    @DeleteMapping(&quot;/workers/{workerId}/subscriptions/{subscriptionId}&quot;)
    public ResponseEntity&lt;?&gt; deleteSubscriptionFromWorker(@PathVariable(&quot;workerId&quot;) int workerId,
                                                          @PathVariable(&quot;subscriptionId&quot;) int subscriptionId)
    {
        return deleteAssociation(workerId, subscriptionId);
    }



    @GetMapping(&quot;/subscriptions/workers&quot;)
    public ResponseEntity&lt;List&lt;Resource&lt;Subscription&gt;&gt;&gt; getSubscriptionsWorkers()
    {
        //  localhost.gs.com:8081/subscriptions/workers

        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findAll();
        Map&lt;Subscription, List&lt;Worker&gt;&gt; groupedMap = workerSubscriptionPairs.stream()
                .collect(Collectors
                        .groupingBy(WorkerSubscriptionPair::getSubscription,
                                Collectors.mapping(WorkerSubscriptionPair::getWorker, Collectors.toList())));

        List&lt;Resource&lt;Subscription&gt;&gt; subscriptionResources = workerSubscriptionLinks
                .createSubscriptionWorkerResources(groupedMap, this);

        return ResponseEntity.ok(subscriptionResources);
    }

    @GetMapping(&quot;/subscriptions/{id}/workers&quot;)
    public ResponseEntity&lt;Resource&lt;Subscription&gt;&gt; getSubscriptionsWorkers(@PathVariable(&quot;id&quot;) int id)
    {
        List&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairs = workerSubscriptionMapRepository.findBySubscriptionId(id);
        if(workerSubscriptionPairs.isEmpty())
        {
            throw new NotFoundException(&quot;subscription-&quot; + id);
        }

        Optional&lt;Subscription&gt; subscriptionOptional = workerSubscriptionPairs
                .stream()
                .map(WorkerSubscriptionPair::getSubscription)
                .findFirst();
        List&lt;Worker&gt; workers = workerSubscriptionPairs
                .stream()
                .map(WorkerSubscriptionPair::getWorker)
                .collect(Collectors.toList());

        Subscription subscription = subscriptionOptional.get();
        subscription.setWorkers(workers);

        Resource&lt;Subscription&gt; subscriptionResource = createSubscriptionWorkerResource(subscription, workers);
        subscriptionResource.add(linkTo(methodOn(getClass()).getSubscriptionsWorkers()).withRel(&quot;all&quot;));
        return ResponseEntity.ok(subscriptionResource);
    }

    @PostMapping(&quot;/subscriptions/{subscriptionId}/workers/{workerId}&quot;)
    public ResponseEntity&lt;?&gt; addWorkerToSubscription(@PathVariable(&quot;subscriptionId&quot;) int subscriptionId,
                                                       @PathVariable(&quot;workerId&quot;) int workerId)
    {
        return createAssociation(workerId, subscriptionId);
    }

    @DeleteMapping(&quot;/subscriptions/{subscriptionId}/workers/{workerId}&quot;)
    public ResponseEntity&lt;?&gt; deleteWorkerFromSubscription(@PathVariable(&quot;subscriptionId&quot;) int subscriptionId,
                                                            @PathVariable(&quot;workerId&quot;) int workerId)
    {
        return deleteAssociation(workerId, subscriptionId);
    }

    private ResponseEntity&lt;?&gt; createAssociation(int workerId, int subscriptionId)
    {
        Optional&lt;Worker&gt; workerOptional = workerRepository.findById(workerId);
        if (!workerOptional.isPresent())
        {
            throw new NotFoundException(&quot;worker-&quot; + workerId);
        }
        Optional&lt;Subscription&gt; subscriptionOptional = subscriptionRepository.findById(subscriptionId);
        if (!subscriptionOptional.isPresent())
        {
            throw new NotFoundException(&quot;subscription-&quot; + workerId);
        }

        Worker worker = workerOptional.get();
        Subscription subscription = subscriptionOptional.get();

        //  Check to make sure this association does not already exists
        List&lt;Subscription&gt; subscriptions = worker.getWorkerSubscriptionPairs()
                .stream()
                .map(WorkerSubscriptionPair::getSubscription)
                .collect(Collectors.toList());
        if(!subscriptions.contains(subscription))
        {
            WorkerSubscriptionPair workerSubscriptionPair = new WorkerSubscriptionPair(worker, subscription);
            workerSubscriptionMapRepository.save(workerSubscriptionPair);

            URI location = ServletUriComponentsBuilder
                    .fromCurrentRequest()
                    .buildAndExpand(worker.getID(), subscription.getID())
                    .toUri();
            return ResponseEntity.created(location).build();
        }

        throw new AlreadyExistsException(&quot;workerId-&quot; + workerId + &quot;, subscriptionId-&quot; + subscriptionId);
    }

    private ResponseEntity&lt;?&gt; deleteAssociation(int workerId, int subscriptionId)
    {
        Optional&lt;WorkerSubscriptionPair&gt; workerSubscriptionPairOptional =
                workerSubscriptionMapRepository.findByWorkerIdSubscriptionId(workerId, subscriptionId);
        if(!workerSubscriptionPairOptional.isPresent())
        {
            throw new NotFoundException(&quot;workerId-&quot; + workerId + &quot;, subscriptionId-&quot; + subscriptionId);
        }

        WorkerSubscriptionPair workerSubscriptionPair = workerSubscriptionPairOptional.get();
        workerSubscriptionPair.setOutUtc(ZonedDateTime.now());
        workerSubscriptionMapRepository.save(workerSubscriptionPair);

        URI location = ServletUriComponentsBuilder
                .fromCurrentRequest()
                .buildAndExpand(workerSubscriptionPair).toUri();

        return ResponseEntity.created(location).build();
    }

    public Resource&lt;Worker&gt; createWorkerSubscriptionResource(Worker worker, List&lt;Subscription&gt; subscriptions)
    {
        Resource&lt;Worker&gt; workerResource = new Resource&lt;&gt;(worker);
        Link link = linkTo(methodOn(getClass()).getWorkersSubscriptions(worker.getID())).withSelfRel();
        workerSubscriptionLinks.addLinks(worker, workerResource, subscriptions, link);
        return workerResource;
    }

    public Resource&lt;Subscription&gt; createSubscriptionWorkerResource(Subscription subscription, List&lt;Worker&gt; workers)
    {
        Resource&lt;Subscription&gt; subscriptionResource = new Resource&lt;&gt;(subscription);
        Link link = linkTo(methodOn(getClass()).getSubscriptionsWorkers(subscription.getID())).withSelfRel();
        workerSubscriptionLinks.addLinks(subscription, subscriptionResource, workers, link);
        return subscriptionResource;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Other">Other</h1><h2 id="SubscriptionTrackerFinal-SecurityEncoder">SecurityEncoder</h2><div class="table-wrap"><table data-layout="full-width" class="confluenceTable"><colgroup><col style="width: 960.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">public class SecurityEncoder
{
    private static final String SECRET = &quot;Ym55bWVsbG9uc2VjdXJpdHltYXN0ZXI=&quot;;
    private static final byte [] SALT = { (byte)0xc3, (byte)0x8a, (byte)0xfc, (byte)0x2b,	(byte)0xb1, (byte)0x3c, (byte)0xf2, (byte)0xee };
    private static final int ITERATIONS = 20;

    public static String encrypt(String input)
    {
        byte [] text = encrypt(input.getBytes());
        return encodeToBase64(text);
    }

    public static String  decrypt(String input)
    {
        byte [] encrypted = decodeBase64ForBytes(input);
        byte [] decrypted = decrypt(encrypted);
        return new String(decrypted);
    }

    private static byte[] encrypt(byte[] input)
    {
        try
        {
            PBEParameterSpec pbeParamSpec = new PBEParameterSpec(SALT, ITERATIONS);
            PBEKeySpec pbeKeySpec = new PBEKeySpec(decodeBase64(SECRET).toCharArray());

            SecretKeyFactory keyFac = SecretKeyFactory.getInstance(&quot;PBEWithMD5AndDES&quot;);
            SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
            Cipher pbeCipher = Cipher.getInstance(&quot;PBEWithMD5AndDES&quot;);

            pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);

            byte[] cipherText = pbeCipher.doFinal(input);

            return cipherText;
        }
        catch(Exception e)
        {
            throw new RuntimeException(&quot;Failed to encrypt&quot;, e);
        }
    }

    private static byte[] decrypt(byte[] input)
    {
        try
        {
            PBEParameterSpec  pbeParameterSpec = new PBEParameterSpec(SALT, ITERATIONS);
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBEWithMD5AndDES&quot;);
            SecretKey key = secretKeyFactory.generateSecret(new PBEKeySpec(decodeBase64(SECRET).toCharArray()));
            Cipher cipher = Cipher.getInstance(&quot;PBEWithMD5AndDES&quot;);
            cipher.init(Cipher.DECRYPT_MODE, key, pbeParameterSpec);
            return cipher.doFinal(input);
        }
        catch(Exception e)
        {
            throw new RuntimeException(&quot;Failed to decrypt&quot;, e);
        }
    }


    private static String encodeToBase64(byte [] input)
    {
      return Base64.getEncoder().encodeToString(input);
    }

    private static String decodeBase64(String input)
    {
        return new String(Base64.getDecoder().decode(input.getBytes()));
    }

    private static byte [] decodeBase64ForBytes(String input)
    {
      return Base64.getDecoder().decode(input.getBytes());
    }

    public static void main(String [] args)
    {
        SecurityEncoder encoder = new SecurityEncoder();

        String encrypted = encoder.encrypt(args[0]);
        System.out.println(encrypted);

        String decrypted = encoder.decrypt(encrypted);
        System.out.println(decrypted);
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-ProjectRepositoryCommandRunner">ProjectRepositoryCommandRunner</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@Component
public class ProjectRepositoryCommandLineRunner implements CommandLineRunner
{
    private Logger logger = LoggerFactory.getLogger(getClass());

    @Autowired
    private ProjectRepository projectRepository;


    @Override
    public void run(String... args) throws Exception
    {
        List&lt;Project&gt; projects = projectRepository.findAll();
        logger.info(&quot;All projects: {}&quot;, projects);
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-SubscriptionTrackerApplication">SubscriptionTrackerApplication</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@SpringBootApplication
public class SubscriptionTrackerApplication
{
	public static void main(String[] args)
	{
		TimeZone.setDefault(TimeZone.getTimeZone(&quot;UTC&quot;));
		SpringApplication.run(SubscriptionTrackerApplication.class, args);
	}
}

</pre>
</div></div></td></tr></tbody></table></div><h1 id="SubscriptionTrackerFinal-Tests">Tests</h1><h2 id="SubscriptionTrackerFinal-Unit">Unit</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class ProjectControllerTest
{
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private ProjectRepository projectRepository;

    @Test
    public void getProjectById() throws Exception
    {
        Project mockProject = new Project(1, &quot;P-1&quot;, &quot;Project one&quot;, 1_000_000.00);
        Mockito.when(projectRepository.findById(Mockito.anyInt())).thenReturn(Optional.of(mockProject));

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/projects/1&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONObject jsonObject = new JSONObject(resultAsString);

        assertEquals(1, jsonObject.get(&quot;projectID&quot;));
        assertEquals(&quot;P-1&quot;, jsonObject.get(&quot;projectName&quot;));
        assertEquals(&quot;Project one&quot;, jsonObject.get(&quot;projectDescription&quot;));
        assertEquals(1_000_000.00, jsonObject.get(&quot;revenue&quot;));
    }

    @Test
    public void getAllSubscriptions() throws Exception
    {
        List&lt;Project&gt; mockProjects = Arrays.asList(
                new Project(1, &quot;P-1&quot;, &quot;Project one&quot;, 1_000_000.00),
                new Project(2, &quot;P-2&quot;, &quot;Project two&quot;, 1_100_000.00),
                new Project(3, &quot;P-3&quot;, &quot;Project three&quot;, 1_200_000.00),
                new Project(4, &quot;P-4&quot;, &quot;Project four&quot;, 1_300_000.00)
        );
        Mockito.when(projectRepository.findAll()).thenReturn(mockProjects);

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/projects&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONArray jsonArray = new JSONArray(resultAsString);

        assertEquals(4, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        assertEquals(1, jsonObject.get(&quot;projectID&quot;));
        assertEquals(&quot;P-1&quot;, jsonObject.get(&quot;projectName&quot;));
        assertEquals(&quot;Project one&quot;, jsonObject.get(&quot;projectDescription&quot;));
        assertEquals(1_000_000.00, jsonObject.get(&quot;revenue&quot;));

        jsonObject = (JSONObject) jsonArray.get(1);
        assertEquals(2, jsonObject.get(&quot;projectID&quot;));
        assertEquals(&quot;P-2&quot;, jsonObject.get(&quot;projectName&quot;));
        assertEquals(&quot;Project two&quot;, jsonObject.get(&quot;projectDescription&quot;));
        assertEquals(1_100_000.00, jsonObject.get(&quot;revenue&quot;));

        jsonObject = (JSONObject) jsonArray.get(2);
        assertEquals(3, jsonObject.get(&quot;projectID&quot;));
        assertEquals(&quot;P-3&quot;, jsonObject.get(&quot;projectName&quot;));
        assertEquals(&quot;Project three&quot;, jsonObject.get(&quot;projectDescription&quot;));
        assertEquals(1_200_000.00, jsonObject.get(&quot;revenue&quot;));

        jsonObject = (JSONObject) jsonArray.get(3);
        assertEquals(4, jsonObject.get(&quot;projectID&quot;));
        assertEquals(&quot;P-4&quot;, jsonObject.get(&quot;projectName&quot;));
        assertEquals(&quot;Project four&quot;, jsonObject.get(&quot;projectDescription&quot;));
        assertEquals(1_300_000.00, jsonObject.get(&quot;revenue&quot;));
    }
}

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class SubscriptionControllerTest
{
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private SubscriptionRepository subscriptionRepository;

    @Test
    public void getSubscriptionById1() throws Exception
    {
        Subscription mockSubscription = new Subscription(1, &quot;SUB-X&quot;, &quot;Subscription X&quot;, 10_000.00, 1);
        Mockito.when(subscriptionRepository.findById(Mockito.eq(1))).thenReturn(Optional.of(mockSubscription));

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/subscriptions/1&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONObject jsonObject = new JSONObject(resultAsString);

        assertEquals(1, jsonObject.get(&quot;subscriptionID&quot;));
        assertEquals(&quot;SUB-X&quot;, jsonObject.get(&quot;subscriptionCode&quot;));
        assertEquals(&quot;Subscription X&quot;, jsonObject.get(&quot;subscriptionName&quot;));
        assertEquals(10_000.00, jsonObject.get(&quot;fees&quot;));
    }

    @Test
    public void getSubscriptionById2() throws Exception
    {
        Subscription mockSubscription = new Subscription(2, &quot;SUB-Y&quot;, &quot;Subscription Y&quot;, 20_000.00, 1);
        Mockito.when(subscriptionRepository.findById(Mockito.eq(2))).thenReturn(Optional.of(mockSubscription));

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/subscriptions/2&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONObject jsonObject = new JSONObject(resultAsString);

        assertEquals(2, jsonObject.get(&quot;subscriptionID&quot;));
        assertEquals(&quot;SUB-Y&quot;, jsonObject.get(&quot;subscriptionCode&quot;));
        assertEquals(&quot;Subscription Y&quot;, jsonObject.get(&quot;subscriptionName&quot;));
        assertEquals(20_000.00, jsonObject.get(&quot;fees&quot;));
    }

    @Test
    public void getAllSubscriptions() throws Exception
    {
        List&lt;Subscription&gt; mockSubscriptions = Arrays.asList(
                new Subscription(1, &quot;SUB-1&quot;, &quot;Subscription 1&quot;, 1000.00, 1),
                new Subscription(2, &quot;SUB-2&quot;, &quot;Subscription 2&quot;, 2000.00, 1),
                new Subscription(3, &quot;SUB-3&quot;, &quot;Subscription 3&quot;, 3000.00, 1),
                new Subscription(4, &quot;SUB-4&quot;, &quot;Subscription 4&quot;, 4000.00, 1)
        );
        Mockito.when(subscriptionRepository.findAll()).thenReturn(mockSubscriptions);

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/subscriptions&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONArray jsonArray = new JSONArray(resultAsString);

        assertEquals(4, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        assertEquals(1, jsonObject.get(&quot;subscriptionID&quot;));
        assertEquals(&quot;SUB-1&quot;, jsonObject.get(&quot;subscriptionCode&quot;));
        assertEquals(&quot;Subscription 1&quot;, jsonObject.get(&quot;subscriptionName&quot;));
        assertEquals(1_000.00, jsonObject.get(&quot;fees&quot;));

        jsonObject = (JSONObject) jsonArray.get(1);
        assertEquals(2, jsonObject.get(&quot;subscriptionID&quot;));
        assertEquals(&quot;SUB-2&quot;, jsonObject.get(&quot;subscriptionCode&quot;));
        assertEquals(&quot;Subscription 2&quot;, jsonObject.get(&quot;subscriptionName&quot;));
        assertEquals(2_000.00, jsonObject.get(&quot;fees&quot;));

        jsonObject = (JSONObject) jsonArray.get(2);
        assertEquals(3, jsonObject.get(&quot;subscriptionID&quot;));
        assertEquals(&quot;SUB-3&quot;, jsonObject.get(&quot;subscriptionCode&quot;));
        assertEquals(&quot;Subscription 3&quot;, jsonObject.get(&quot;subscriptionName&quot;));
        assertEquals(3_000.00, jsonObject.get(&quot;fees&quot;));

        jsonObject = (JSONObject) jsonArray.get(3);
        assertEquals(4, jsonObject.get(&quot;subscriptionID&quot;));
        assertEquals(&quot;SUB-4&quot;, jsonObject.get(&quot;subscriptionCode&quot;));
        assertEquals(&quot;Subscription 4&quot;, jsonObject.get(&quot;subscriptionName&quot;));
        assertEquals(4_000.00, jsonObject.get(&quot;fees&quot;));
    }
}

@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class WorkerControllerTest
{
    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private WorkerRepository workerRepository;

    @Test
    public void getWorkerById() throws Exception
    {
        Worker mockWorker = new Worker(1, &quot;CODE-1&quot;, &quot;Worker One&quot;, 100000.00);
        Mockito.when(workerRepository.findById(Mockito.anyInt())).thenReturn(Optional.of(mockWorker));

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/workers/1&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONObject jsonObject = new JSONObject(resultAsString);

        assertEquals(1, jsonObject.get(&quot;workerID&quot;));
        assertEquals(&quot;CODE-1&quot;, jsonObject.get(&quot;workerCode&quot;));
        assertEquals(&quot;Worker One&quot;, jsonObject.get(&quot;workerName&quot;));
        assertEquals(100000.00, jsonObject.get(&quot;compensation&quot;));
    }

    @Test
    public void getAllWorkers() throws Exception
    {
        List&lt;Worker&gt; mockWorkers = Arrays.asList(
                new Worker(1, &quot;CODE-1&quot;, &quot;One First&quot;, 100000.00),
                new Worker(2, &quot;CODE-2&quot;, &quot;Two Second&quot;, 110000.00),
                new Worker(3, &quot;CODE-3&quot;, &quot;Three Third&quot;, 120000.00),
                new Worker(4, &quot;CODE-4&quot;, &quot;Four Forth&quot;, 130000.00)
        );
        Mockito.when(workerRepository.findAll()).thenReturn(mockWorkers);

        RequestBuilder requestBuilder = MockMvcRequestBuilders.get(&quot;/workers&quot;).accept(MediaType.APPLICATION_JSON);
        MvcResult result = mockMvc.perform(requestBuilder).andReturn();

        String resultAsString = result.getResponse().getContentAsString();
        JSONArray jsonArray = new JSONArray(resultAsString);

        assertEquals(4, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        assertEquals(1, jsonObject.get(&quot;workerID&quot;));
        assertEquals(&quot;CODE-1&quot;, jsonObject.get(&quot;workerCode&quot;));
        assertEquals(&quot;One First&quot;, jsonObject.get(&quot;workerName&quot;));
        assertEquals(100000.00, jsonObject.get(&quot;compensation&quot;));

        jsonObject = (JSONObject) jsonArray.get(1);
        assertEquals(2, jsonObject.get(&quot;workerID&quot;));
        assertEquals(&quot;CODE-2&quot;, jsonObject.get(&quot;workerCode&quot;));
        assertEquals(&quot;Two Second&quot;, jsonObject.get(&quot;workerName&quot;));
        assertEquals(110000.00, jsonObject.get(&quot;compensation&quot;));

        jsonObject = (JSONObject) jsonArray.get(2);
        assertEquals(3, jsonObject.get(&quot;workerID&quot;));
        assertEquals(&quot;CODE-3&quot;, jsonObject.get(&quot;workerCode&quot;));
        assertEquals(&quot;Three Third&quot;, jsonObject.get(&quot;workerName&quot;));
        assertEquals(120000.00, jsonObject.get(&quot;compensation&quot;));

        jsonObject = (JSONObject) jsonArray.get(3);
        assertEquals(4, jsonObject.get(&quot;workerID&quot;));
        assertEquals(&quot;CODE-4&quot;, jsonObject.get(&quot;workerCode&quot;));
        assertEquals(&quot;Four Forth&quot;, jsonObject.get(&quot;workerName&quot;));
        assertEquals(130000.00, jsonObject.get(&quot;compensation&quot;));
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-Integration">Integration</h2><h3 id="SubscriptionTrackerFinal-ConsultantControllerTest">ConsultantControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class ConsultantControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getConsultants() throws IOException
    {
        List&lt;Integer&gt; expectedIDs = IntStream.rangeClosed(4, 6).boxed().collect(Collectors.toList());

        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/consultants&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        String content = response.getBody();
        ObjectMapper objectMapper = new ObjectMapper();
        List&lt;ConsultantDTO&gt; consultantDTOs = objectMapper.readValue(content, new TypeReference&lt;List&lt;ConsultantDTO&gt;&gt;(){});

        List&lt;Integer&gt; actualIDs = consultantDTOs.stream().map(ConsultantDTO::getWorkerID).sorted().collect(Collectors.toList());
        assertArrayEquals(expectedIDs.toArray(new Integer[0]), actualIDs.toArray(new Integer[0]));
    }

    @Test
    public void testB_getConsultant() throws JSONException
    {
        ResponseEntity&lt;ConsultantDTO&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/consultants/4&quot;), ConsultantDTO.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        ConsultantDTO consultantDTO = response.getBody();

        assertEquals(4, consultantDTO.getWorkerID());
        assertEquals(&quot;CODE-4&quot;, consultantDTO.getWorkerCode());
        assertEquals(&quot;Four Forth&quot;, consultantDTO.getWorkerName());
        assertEquals(&quot;AGENCY-1&quot;, consultantDTO.getAgencyCode());
    }

    @Test
    public void testC_createConsultant()
    {
        //  Create new consultant
        Consultant consultant = new Consultant();
        consultant.setWorkerCode(&quot;CODE-C&quot;);
        consultant.setWorkerName(&quot;New Consultant&quot;);
        consultant.setAgencyCode(&quot;AGENCY-CODE&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/consultants&quot;), consultant, Consultant.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created consultant
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;ConsultantDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/consultants/&quot; + idString), ConsultantDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        ConsultantDTO consultantDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, consultantDTO.getWorkerID());
        assertEquals(&quot;CODE-C&quot;, consultantDTO.getWorkerCode());
        assertEquals(&quot;New Consultant&quot;, consultantDTO.getWorkerName());
        assertEquals(&quot;AGENCY-CODE&quot;, consultantDTO.getAgencyCode());
    }

    @Test
    public void testD_updateConsultant()
    {
        //  Create new consultant
        Consultant consultant = new Consultant();
        consultant.setWorkerCode(&quot;CODE-C&quot;);
        consultant.setWorkerName(&quot;New Consultant&quot;);
        consultant.setAgencyCode(&quot;AGENCY-CODE&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/consultants&quot;), consultant, Consultant.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created consultant
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;ConsultantDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/consultants/&quot; + idString), ConsultantDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        ConsultantDTO consultantDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, consultantDTO.getWorkerID());
        assertEquals(&quot;CODE-C&quot;, consultantDTO.getWorkerCode());
        assertEquals(&quot;New Consultant&quot;, consultantDTO.getWorkerName());
        assertEquals(&quot;AGENCY-CODE&quot;, consultantDTO.getAgencyCode());

        //  Update this employee
        consultant.setWorkerCode(&quot;CODE-X&quot;);
        consultant.setWorkerName(&quot;NEW CONSULTANT&quot;);
        consultant.setAgencyCode(&quot;AGENCY-CODE-NEW&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Consultant&gt; entity = new HttpEntity&lt;&gt;(consultant, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/consultants/&quot; + idString), HttpMethod.PUT, entity, Consultant.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified consultant
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/consultants/&quot; + idString), ConsultantDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        consultantDTO = getResponse.getBody();

        assertEquals(&quot;CODE-X&quot;, consultantDTO.getWorkerCode());
        assertEquals(&quot;NEW CONSULTANT&quot;, consultantDTO.getWorkerName());
        assertEquals(&quot;AGENCY-CODE-NEW&quot;, consultantDTO.getAgencyCode());
    }

    @Test
    public void testE_deleteConsultant()
    {
        //  Consultant ID=6 is not associated with any projects or subscriptions
        //  delete this consultant
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/consultants/6&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/consultants/6&quot;));

        //  Try reading deleted consultant
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/consultants/6&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.NOT_FOUND));
    }


    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-EmployeeControllerTest">EmployeeControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class EmployeeControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

    @Test
    public void testA_getEmployees() throws JSONException, IOException
    {
        List&lt;Integer&gt; expectedIDs = IntStream.rangeClosed(1, 3).boxed().collect(Collectors.toList());

        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/employees&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        String content = response.getBody();
        ObjectMapper objectMapper = new ObjectMapper();
        List&lt;EmployeeDTO&gt; employeeDTOs = objectMapper.readValue(content, new TypeReference&lt;List&lt;EmployeeDTO&gt;&gt;(){});

        List&lt;Integer&gt; actualIDs = employeeDTOs.stream().map(EmployeeDTO::getWorkerID).sorted().collect(Collectors.toList());
        assertArrayEquals(expectedIDs.toArray(new Integer[0]), actualIDs.toArray(new Integer[0]));
    }

    @Test
    public void testB_getEmployee()
    {
        ResponseEntity&lt;EmployeeDTO&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/employees/1&quot;), EmployeeDTO.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        EmployeeDTO employeeDTO = response.getBody();

        assertEquals(1, employeeDTO.getWorkerID());
        assertEquals(&quot;CODE-1&quot;, employeeDTO.getWorkerCode());
        assertEquals(&quot;One First&quot;, employeeDTO.getWorkerName());
        assertEquals(&quot;BENE-1&quot;, employeeDTO.getBeneCode());
    }

    @Test
    public void testC_createEmployee()
    {
        //  Create new employee
        Employee employee = new Employee();
        employee.setWorkerCode(&quot;CODE-E&quot;);
        employee.setWorkerName(&quot;New Employee&quot;);
        employee.setBeneCode(&quot;BENE-CODE&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/employees&quot;), employee, Employee.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created employee
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;EmployeeDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/employees/&quot; + idString), EmployeeDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        EmployeeDTO employeeDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, employeeDTO.getWorkerID());
        assertEquals(&quot;CODE-E&quot;, employeeDTO.getWorkerCode());
        assertEquals(&quot;New Employee&quot;, employeeDTO.getWorkerName());
        assertEquals(&quot;BENE-CODE&quot;, employeeDTO.getBeneCode());
    }

    @Test
    public void testD_updateEmployee()
    {
        //  Create new employee
        Employee employee = new Employee();
        employee.setWorkerCode(&quot;CODE-E&quot;);
        employee.setWorkerName(&quot;New Employee&quot;);
        employee.setBeneCode(&quot;BENE-CODE&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/employees&quot;), employee, Employee.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created employee
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;EmployeeDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/employees/&quot; + idString), EmployeeDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        EmployeeDTO employeeDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, employeeDTO.getWorkerID());
        assertEquals(&quot;CODE-E&quot;, employeeDTO.getWorkerCode());
        assertEquals(&quot;New Employee&quot;, employeeDTO.getWorkerName());
        assertEquals(&quot;BENE-CODE&quot;, employeeDTO.getBeneCode());

        //  Update this employee
        employee.setWorkerCode(&quot;CODE-X&quot;);
        employee.setWorkerName(&quot;NEW EMPLOYEE&quot;);
        employee.setBeneCode(&quot;BENE-CODE-NEW&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Employee&gt; entity = new HttpEntity&lt;&gt;(employee, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/employees/&quot; + idString), HttpMethod.PUT, entity, Employee.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified employee
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/employees/&quot; + idString), EmployeeDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        employeeDTO = getResponse.getBody();

        assertEquals(&quot;CODE-X&quot;, employeeDTO.getWorkerCode());
        assertEquals(&quot;NEW EMPLOYEE&quot;, employeeDTO.getWorkerName());
        assertEquals(&quot;BENE-CODE-NEW&quot;, employeeDTO.getBeneCode());
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-ProjectAuditControllerTest">ProjectAuditControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class ProjectAuditControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getProjects() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/audit/projects&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);

            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testB_getProject() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/audit/projects/1&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        assertEquals(1, jsonArray.length());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);

            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testC_biTemporalProjectUpdate() throws JSONException
    {
        //  Create new project
        Project project = new Project();
        project.setProjectName(&quot;P-x&quot;);
        project.setProjectDescription(&quot;Project x&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/projects&quot;), project, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created project
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;String&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/projects/&quot; + idString), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(1, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
        ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());


        //  Update this project
        project.setProjectName(&quot;P-X&quot;);
        project.setProjectDescription(&quot;PROJECT X&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Project&gt; entity = new HttpEntity&lt;&gt;(project, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/&quot; + idString), HttpMethod.PUT, entity, Subscription.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified project
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/projects/&quot; + idString), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));
        jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(2, jsonArray.length());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            jsonObject = (JSONObject) jsonArray.get(i);
            outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            outUtcDate = ZonedDateTime.parse(outUtcString);

            int id = (int)jsonObject.get(&quot;ID&quot;);
            if(id == Integer.valueOf(idString))
            {
                assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
                assertEquals(&quot;P-X&quot;, (String)jsonObject.get(&quot;projectName&quot;));
                assertEquals(&quot;PROJECT X&quot;, (String)jsonObject.get(&quot;projectDescription&quot;));
            }
            else
            {
                assertNotEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
                assertEquals(&quot;P-x&quot;, (String)jsonObject.get(&quot;projectName&quot;));
                assertEquals(&quot;Project x&quot;, (String)jsonObject.get(&quot;projectDescription&quot;));
            }
        }
    }

    @Test
    public void testD_biTemporalProjectDelete() throws JSONException
    {
        //  Project 4 is not associated with any Worker
        //  delete project
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/4&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/projects/4&quot;));

        ResponseEntity&lt;String&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/projects/4&quot;), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(1, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
        ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
        assertNotEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
    }

    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-ProjectControllerTest">ProjectControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class ProjectControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getProjects() throws IOException
    {
        List&lt;Integer&gt; expectedIDs = IntStream.rangeClosed(1, 4).boxed().collect(Collectors.toList());

        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/projects&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        String content = response.getBody();
        ObjectMapper objectMapper = new ObjectMapper();
        List&lt;ProjectDTO&gt; projectDTOs = objectMapper.readValue(content, new TypeReference&lt;List&lt;ProjectDTO&gt;&gt;(){});

        List&lt;Integer&gt; actualIDs = projectDTOs.stream().map(ProjectDTO::getProjectID).sorted().collect(Collectors.toList());
        assertArrayEquals(expectedIDs.toArray(new Integer[0]), actualIDs.toArray(new Integer[0]));
    }

    @Test
    public void testB_getProject()
    {
        ResponseEntity&lt;ProjectDTO&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/projects/1&quot;), ProjectDTO.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        ProjectDTO projectDTO = response.getBody();

        assertEquals(1, projectDTO.getProjectID());
        assertEquals(&quot;P-1&quot;, projectDTO.getProjectName());
        assertEquals(&quot;Project one&quot;, projectDTO.getProjectDescription());
    }

    @Test
    public void testC_createProject()
    {
        //  Create new project
        Project project = new Project();
        project.setProjectName(&quot;P-x&quot;);
        project.setProjectDescription(&quot;Project x&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/projects&quot;), project, Project.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created project
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;ProjectDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/&quot; + idString), ProjectDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        ProjectDTO projectDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, projectDTO.getProjectID());
        assertEquals(&quot;P-x&quot;, projectDTO.getProjectName());
        assertEquals(&quot;Project x&quot;, projectDTO.getProjectDescription());
    }

    @Test
    public void testD_updateProject()
    {
        //  Create new project
        Project project = new Project();
        project.setProjectName(&quot;P-x&quot;);
        project.setProjectDescription(&quot;Project x&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/projects&quot;), project, Project.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created project
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;ProjectDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/&quot; + idString), ProjectDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        ProjectDTO projectDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, projectDTO.getProjectID());
        assertEquals(&quot;P-x&quot;, projectDTO.getProjectName());
        assertEquals(&quot;Project x&quot;, projectDTO.getProjectDescription());

        //  Update this project
        project.setProjectName(&quot;P-X&quot;);
        project.setProjectDescription(&quot;PROJECT X&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Project&gt; entity = new HttpEntity&lt;&gt;(project, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/&quot; + idString), HttpMethod.PUT, entity, Project.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified project
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/&quot; + idString), ProjectDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        projectDTO = getResponse.getBody();

        assertEquals(&quot;P-X&quot;, projectDTO.getProjectName());
        assertEquals(&quot;PROJECT X&quot;, projectDTO.getProjectDescription());
    }

    @Test
    public void testE_deleteProject()
    {
        //  Project 4 is not associated with any Worker
        //  delete project
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/4&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/projects/4&quot;));

        //  Try reading deleted project
        ResponseEntity&lt;String&gt; response = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/4&quot;), HttpMethod.GET, null, String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.NOT_FOUND));
    }


    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-ProjectWorkerControllerTest">ProjectWorkerControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class ProjectWorkerControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getProjectsWorkers() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/workers&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);
            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testB_getProjectsWorkers()
    {
        ResponseEntity&lt;Project&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/1/workers&quot;),
                Project.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        Project project = response.getBody();

        assertEquals(&quot;00000000-0000-0000-0000-000000000001&quot;, project.getAuditId());
        assertEquals(&quot;P-1&quot;, project.getProjectName());
        assertEquals(&quot;Project one&quot;, project.getProjectDescription());
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), project.getOutUtc().toInstant().toEpochMilli());

        List&lt;String&gt; workerCodes = project.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());
        List&lt;String&gt; allWorkerCodes = Arrays.asList(&quot;CODE-1&quot;, &quot;CODE-2&quot;, &quot;CODE-3&quot;, &quot;CODE-4&quot;, &quot;CODE-5&quot;, &quot;CODE-6&quot;);
        assertTrue(allWorkerCodes.containsAll(workerCodes));
    }

    @Test
    public void testC_getWorkersProjects()
    {
        ResponseEntity&lt;List&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/projects&quot;), List.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        List&lt;LinkedHashMap&lt;String,Object&gt;&gt; responseBody = response.getBody();

        for(LinkedHashMap&lt;String,Object&gt; map : responseBody)
        {
            String outUtcString = (String)map.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testD_getWorkersProject()
    {
        ResponseEntity&lt;Worker&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/projects&quot;),
                Worker.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        Worker worker = response.getBody();

        assertEquals(&quot;00000000-0000-0000-0000-000000000001&quot;, worker.getAuditId());
        assertEquals(&quot;CODE-1&quot;, worker.getWorkerCode());
        assertEquals(&quot;One First&quot;, worker.getWorkerName());
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), worker.getOutUtc().toInstant().toEpochMilli());

        List&lt;String&gt; projectCodes = worker.getProjects().stream().map(Project::getProjectName).collect(Collectors.toList());
        List&lt;String&gt; alProjectCodes = Arrays.asList(&quot;P-1&quot;, &quot;P-2&quot;, &quot;P-3&quot;, &quot;P-4&quot;);
        assertTrue(alProjectCodes.containsAll(projectCodes));
    }

    @Test
    public void testE_postWorkersToProject()
    {
        //  Verify that worker 2 is not assigned to project 1
        ResponseEntity&lt;Project&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/1/workers&quot;), Project.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Project project = getResponse.getBody();

        List&lt;String&gt; workerCodes = project.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertFalse(workerCodes.contains(&quot;CODE-2&quot;));

        //  Assign worker 2 to project 1
        ResponseEntity&lt;String&gt; postResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/1/workers/2/appropriation/1&quot;),
                HttpMethod.POST, null, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/projects/1/workers/2&quot;));

        //  Read newly added worker to project 1
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/1/workers&quot;), Project.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        project = getResponse.getBody();

        workerCodes = project.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertTrue(workerCodes.contains(&quot;CODE-2&quot;));
    }

    @Test
    public void testF_postProjectToWorker()
    {
        //  Verify that project 1 does not have worker 4
        ResponseEntity&lt;Worker&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/4/projects&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Worker worker = getResponse.getBody();

        List&lt;String&gt; projectNames = worker.getProjects().stream().map(Project::getProjectName).collect(Collectors.toList());

        assertFalse(projectNames.contains(&quot;P-1&quot;));

        //  Assign worker 2 to project 1
        ResponseEntity&lt;String&gt; postResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/4/projects/1/appropriation/1&quot;),
                HttpMethod.POST, null, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/workers/4/projects/1&quot;));

        //  Read newly assigned worker to project
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;workers/4/projects&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        worker = getResponse.getBody();

        projectNames = worker.getProjects().stream().map(Project::getProjectName).collect(Collectors.toList());

        assertTrue(projectNames.contains(&quot;P-1&quot;));
    }

    @Test
    public void testG_deleteWorkerFromProject()
    {
        //  Verify that worker 3 is assigned to project 1
        ResponseEntity&lt;Project&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/1/workers&quot;), Project.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Project project = getResponse.getBody();

        List&lt;String&gt; workerCodes = project.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertTrue(workerCodes.contains(&quot;CODE-3&quot;));

        //  Delete worker 3 from project 1
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/projects/1/workers/3&quot;),
                HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/projects/1/workers/3&quot;));

        //  Verify that worker 3 is no longer assigned to project 1
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/projects/1/workers&quot;), Project.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        project = getResponse.getBody();

        workerCodes = project.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertFalse(workerCodes.contains(&quot;CODE-3&quot;));
    }

    @Test
    public void testH_deleteProjectFromWorker()
    {
        //  Worker 1 is currently working on projects 1 &amp; 3
        ResponseEntity&lt;Worker&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/projects&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Worker worker = getResponse.getBody();

        List&lt;String&gt; projectNames = worker.getProjects().stream().map(Project::getProjectName).collect(Collectors.toList());

        assertTrue(projectNames.contains(&quot;P-3&quot;));

        //  Remove worker 1 from project 3
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/1/projects/3&quot;),
                HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/workers/1/projects/3&quot;));

        //  Verify that project 3 no longer has worker 1
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/projects&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        worker = getResponse.getBody();

        projectNames = worker.getProjects().stream().map(Project::getProjectName).collect(Collectors.toList());

        assertFalse(projectNames.contains(&quot;P-3&quot;));
    }


    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-SubscriptionAuditControllerTest">SubscriptionAuditControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class SubscriptionAuditControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getSubscriptions() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/audit/subscriptions&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);

            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testB_getSubscription() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/audit/subscriptions/1&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        assertEquals(1, jsonArray.length());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);

            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testC_biTemporalSubscriptionUpdate() throws JSONException
    {
        //  Create new subscription
        Subscription subscription = new Subscription();
        subscription.setSubscriptionCode(&quot;Code-Test&quot;);
        subscription.setSubscriptionName(&quot;Code-Test Name&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/subscriptions&quot;), subscription, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created subscription
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;String&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/subscriptions/&quot; + idString), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(1, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
        ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());


        //  Update this subscription
        subscription.setSubscriptionCode(&quot;CODE-TEST&quot;);
        subscription.setSubscriptionName(&quot;CODE-TEST NAME&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Subscription&gt; entity = new HttpEntity&lt;&gt;(subscription, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/&quot; + idString), HttpMethod.PUT, entity, Subscription.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified subscription
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/subscriptions/&quot; + idString), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));
        jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(2, jsonArray.length());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            jsonObject = (JSONObject) jsonArray.get(i);
            outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            outUtcDate = ZonedDateTime.parse(outUtcString);

            int id = (int)jsonObject.get(&quot;ID&quot;);
            if(id == Integer.valueOf(idString))
            {
                assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
                assertEquals(&quot;CODE-TEST&quot;, (String)jsonObject.get(&quot;subscriptionCode&quot;));
                assertEquals(&quot;CODE-TEST NAME&quot;, (String)jsonObject.get(&quot;subscriptionName&quot;));
            }
            else
            {
                assertNotEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
                assertEquals(&quot;Code-Test&quot;, (String)jsonObject.get(&quot;subscriptionCode&quot;));
                assertEquals(&quot;Code-Test Name&quot;, (String)jsonObject.get(&quot;subscriptionName&quot;));
            }
        }
    }

    @Test
    public void testD_biTemporalSubscriptionDelete() throws JSONException
    {
        //  Subscription 7 is not associated with any Worker
        //  delete subscription
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/7&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/subscriptions/7&quot;));

        ResponseEntity&lt;String&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/subscriptions/7&quot;), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(1, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
        ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
        assertNotEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
    }


    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-SubscriptionControllerTest">SubscriptionControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class SubscriptionControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getSubscriptions() throws IOException
    {
        List&lt;Integer&gt; expectedIDs = IntStream.rangeClosed(1, 7).boxed().collect(Collectors.toList());

        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/subscriptions&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        String content = response.getBody();
        ObjectMapper objectMapper = new ObjectMapper();
        List&lt;SubscriptionDTO&gt; subscriptionDTOs = objectMapper.readValue(content, new TypeReference&lt;List&lt;SubscriptionDTO&gt;&gt;(){});

        List&lt;Integer&gt; actualIDs = subscriptionDTOs.stream().map(SubscriptionDTO::getSubscriptionID).sorted().collect(Collectors.toList());
        assertArrayEquals(expectedIDs.toArray(new Integer[0]), actualIDs.toArray(new Integer[0]));
    }

    @Test
    public void testB_getSubscriptions1()
    {
         Set&lt;Integer&gt; subscriptionIDs = new HashSet(Arrays.asList(1, 2, 3, 4, 5, 6, 7));

        ResponseEntity&lt;?&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions&quot;), List.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        ResponseEntity&lt;List&lt;LinkedHashMap&lt;String,Object&gt;&gt;&gt; subscriptionsResponse = (ResponseEntity&lt;List&lt;LinkedHashMap&lt;String,Object&gt;&gt;&gt;)response;

        List&lt;LinkedHashMap&lt;String,Object&gt;&gt; subscriptions = subscriptionsResponse.getBody();

        for(LinkedHashMap&lt;String,Object&gt; subscription : subscriptions)
        {
            int id = (Integer)subscription.get(&quot;subscriptionID&quot;);
            subscriptionIDs.remove(Integer.valueOf(id));
        }

        assertTrue(subscriptionIDs.isEmpty());
    }

    @Test
    public void testC_getSubscription() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/subscriptions/1&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONObject jsonObject = new JSONObject(response.getBody());

        int subscriptionID = (int)jsonObject.get(&quot;subscriptionID&quot;);
        assertEquals(1, subscriptionID);

        String subscriptionCode = (String)jsonObject.get(&quot;subscriptionCode&quot;);
        assertEquals(&quot;SUB-1&quot;, subscriptionCode);

        String subscriptionName = (String)jsonObject.get(&quot;subscriptionName&quot;);
        assertEquals(&quot;Subscription 1&quot;, subscriptionName);
    }

    @Test
    public void testD_getSubscription1()
    {
        ResponseEntity&lt;SubscriptionDTO&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/1&quot;), SubscriptionDTO.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        SubscriptionDTO subscriptionDTO = response.getBody();

        assertEquals(1, subscriptionDTO.getSubscriptionID());
        assertEquals(&quot;SUB-1&quot;, subscriptionDTO.getSubscriptionCode());
        assertEquals(&quot;Subscription 1&quot;, subscriptionDTO.getSubscriptionName());
    }


    @Test
    public void testE_createSubscription()
    {
        //  Create new subscription
        Subscription subscription = new Subscription();
        subscription.setSubscriptionCode(&quot;Code-Test&quot;);
        subscription.setSubscriptionName(&quot;Code-Test Name&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/subscriptions&quot;), subscription, Subscription.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created subscription
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;SubscriptionDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/&quot; + idString), SubscriptionDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        SubscriptionDTO subscriptionDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, subscriptionDTO.getSubscriptionID());
        assertEquals(&quot;Code-Test&quot;, subscriptionDTO.getSubscriptionCode());
        assertEquals(&quot;Code-Test Name&quot;, subscriptionDTO.getSubscriptionName());
    }

    @Test
    public void testF_updateSubscription()
    {
        //  Create new subscription
        Subscription subscription = new Subscription();
        subscription.setSubscriptionCode(&quot;Code-Test&quot;);
        subscription.setSubscriptionName(&quot;Code-Test Name&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/subscriptions&quot;), subscription, Subscription.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created subscription
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;SubscriptionDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/&quot; + idString), SubscriptionDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        SubscriptionDTO subscriptionDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, subscriptionDTO.getSubscriptionID());
        assertEquals(&quot;Code-Test&quot;, subscriptionDTO.getSubscriptionCode());
        assertEquals(&quot;Code-Test Name&quot;, subscriptionDTO.getSubscriptionName());

        //  Update this subscription
        subscription.setSubscriptionCode(&quot;CODE-TEST&quot;);
        subscription.setSubscriptionName(&quot;CODE-TEST NAME&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Subscription&gt; entity = new HttpEntity&lt;&gt;(subscription, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/&quot; + idString), HttpMethod.PUT, entity, Subscription.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified subscription
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/&quot; + idString), SubscriptionDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        subscriptionDTO = getResponse.getBody();

        assertEquals(&quot;CODE-TEST&quot;, subscriptionDTO.getSubscriptionCode());
        assertEquals(&quot;CODE-TEST NAME&quot;, subscriptionDTO.getSubscriptionName());
    }

    @Test
    public void testG_deleteSubscription()
    {
        //  Subscription 7 is not associated with any Worker
        //  delete subscription
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/7&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/subscriptions/7&quot;));

        //  Try reading deleted subscription
        ResponseEntity&lt;String&gt; response = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/7&quot;), HttpMethod.GET, null, String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.NOT_FOUND));
    }


    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-WorkerAuditControllerTest">WorkerAuditControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class WorkerAuditControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getworkers() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/audit/workers&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);

            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testB_getworker() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/audit/workers/1&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        assertEquals(1, jsonArray.length());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);

            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testC_biTemporalworkerUpdate() throws JSONException
    {
        //  Create new worker
        Worker worker = new Worker();
        worker.setWorkerCode(&quot;CODE-x&quot;);
        worker.setWorkerName(&quot;New worker&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/workers&quot;), worker, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created worker
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;String&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/workers/&quot; + idString), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(1, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
        ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());


        //  Update this worker
        worker.setWorkerCode(&quot;CODE-X&quot;);
        worker.setWorkerName(&quot;NEW worker&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Worker&gt; entity = new HttpEntity&lt;&gt;(worker, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/&quot; + idString), HttpMethod.PUT, entity, Subscription.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified worker
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/workers/&quot; + idString), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));
        jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(2, jsonArray.length());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            jsonObject = (JSONObject) jsonArray.get(i);
            outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            outUtcDate = ZonedDateTime.parse(outUtcString);

            int id = (int)jsonObject.get(&quot;ID&quot;);
            if(id == Integer.valueOf(idString))
            {
                assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
                assertEquals(&quot;CODE-X&quot;, (String)jsonObject.get(&quot;workerCode&quot;));
                assertEquals(&quot;NEW worker&quot;, (String)jsonObject.get(&quot;workerName&quot;));
            }
            else
            {
                assertNotEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
                assertEquals(&quot;CODE-x&quot;, (String)jsonObject.get(&quot;workerCode&quot;));
                assertEquals(&quot;New worker&quot;, (String)jsonObject.get(&quot;workerName&quot;));
            }
        }
    }

    @Test
    public void testD_biTemporalworkerDelete() throws JSONException
    {
        //  worker 6 is not associated with any project or subscription
        //  delete worker
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/6&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/workers/6&quot;));

        ResponseEntity&lt;String&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/audit/workers/6&quot;), String.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(getResponse.getBody());
        assertEquals(1, jsonArray.length());

        JSONObject jsonObject = (JSONObject) jsonArray.get(0);
        String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
        ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
        assertNotEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
    }

    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="SubscriptionTrackerFinal-WorkerControllerTest">WorkerControllerTest</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class WorkerControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getWorkers() throws IOException
    {
        List&lt;Integer&gt; expectedIDs = IntStream.rangeClosed(1, 6).boxed().collect(Collectors.toList());

        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/workers&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        String content = response.getBody();
        ObjectMapper objectMapper = new ObjectMapper();
        List&lt;WorkerDTO&gt; workderDTOs = objectMapper.readValue(content, new TypeReference&lt;List&lt;WorkerDTO&gt;&gt;(){});

        List&lt;Integer&gt; actualIDs = workderDTOs.stream().map(WorkerDTO::getWorkerID).sorted().collect(Collectors.toList());
        assertArrayEquals(expectedIDs.toArray(new Integer[0]), actualIDs.toArray(new Integer[0]));
    }

    @Test
    public void testB_getWorker() throws JSONException
    {
        ResponseEntity&lt;WorkerDTO&gt; response = testRestTemplate.getForEntity(createUrlWithPort( &quot;/workers/1&quot;), WorkerDTO.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        WorkerDTO workerDTO = response.getBody();

        assertEquals(1, workerDTO.getWorkerID());
        assertEquals(&quot;CODE-1&quot;, workerDTO.getWorkerCode());
        assertEquals(&quot;One First&quot;, workerDTO.getWorkerName());
    }


    @Test
    public void testC_createWorker()
    {
        //  Create new worker
        Worker worker = new Worker();
        worker.setWorkerCode(&quot;CODE-x&quot;);
        worker.setWorkerName(&quot;New Worker&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/workers&quot;), worker, Worker.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created worker
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;WorkerDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/&quot; + idString), WorkerDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        WorkerDTO workerDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, workerDTO.getWorkerID());
        assertEquals(&quot;CODE-x&quot;, workerDTO.getWorkerCode());
        assertEquals(&quot;New Worker&quot;, workerDTO.getWorkerName());
    }

    @Test
    public void testD_updateWorker()
    {
        //  Create new worker
        Worker worker = new Worker();
        worker.setWorkerCode(&quot;CODE-x&quot;);
        worker.setWorkerName(&quot;New Worker&quot;);

        ResponseEntity&lt;?&gt; postResponse = testRestTemplate.postForEntity(createUrlWithPort(&quot;/workers&quot;), worker, Worker.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read newly created worker
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        String idString = actual.substring(actual.lastIndexOf(&quot;/&quot;) + 1);

        ResponseEntity&lt;WorkerDTO&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/&quot; + idString), WorkerDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        WorkerDTO workerDTO = getResponse.getBody();

        int id = Integer.valueOf(idString);

        assertEquals(id, workerDTO.getWorkerID());
        assertEquals(&quot;CODE-x&quot;, workerDTO.getWorkerCode());
        assertEquals(&quot;New Worker&quot;, workerDTO.getWorkerName());

        //  Update this worker
        worker.setWorkerCode(&quot;CODE-X&quot;);
        worker.setWorkerName(&quot;NEW WORKER&quot;);

        HttpHeaders headers = new HttpHeaders();
        HttpEntity&lt;Worker&gt; entity = new HttpEntity&lt;&gt;(worker, headers);
        ResponseEntity&lt;?&gt; putResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/&quot; + idString), HttpMethod.PUT, entity, Worker.class);
        assertThat(putResponse.getStatusCode(), equalTo(HttpStatus.CREATED));

        //  Read modified worker
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/&quot; + idString), WorkerDTO.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        workerDTO = getResponse.getBody();

        assertEquals(&quot;CODE-X&quot;, workerDTO.getWorkerCode());
        assertEquals(&quot;NEW WORKER&quot;, workerDTO.getWorkerName());
    }

    @Test
    public void testE_deleteWorker()
    {
        //  Worker 6 is not associated with any projects or subscriptions
        //  delete worker
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/6&quot;), HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/workers/6&quot;));

        //  Try reading deleted worker
        ResponseEntity&lt;String&gt; response = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/6&quot;), HttpMethod.GET, null, String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.NOT_FOUND));
    }

    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

}</pre>
</div></div></td></tr></tbody></table></div><h3 id="SubscriptionTrackerFinal-WorkerSubscriptionControllerTest">WorkerSubscriptionControllerTest</h3><div class="table-wrap"><table data-layout="default" class="confluenceTable"><colgroup><col style="width: 680.0px;"/></colgroup><tbody><tr><td class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@FixMethodOrder(MethodSorters.NAME_ASCENDING)
@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)
public class WorkerSubscriptionControllerTest
{
    @LocalServerPort
    private int port;

    @Autowired
    private TestRestTemplate testRestTemplate;

    @Test
    public void testA_getWorkersSubscriptions() throws JSONException
    {
        ResponseEntity&lt;String&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/subscriptions&quot;), String.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        JSONArray jsonArray = new JSONArray(response.getBody());

        for (int i = 0; i &lt; jsonArray.length(); ++i)
        {
            JSONObject jsonObject = (JSONObject) jsonArray.get(i);
            String outUtcString = (String)jsonObject.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testB_getWorkersSubscription()
    {
        ResponseEntity&lt;Worker&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/subscriptions&quot;),
                Worker.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        Worker worker = response.getBody();

        assertEquals(&quot;00000000-0000-0000-0000-000000000001&quot;, worker.getAuditId());
        assertEquals(&quot;CODE-1&quot;, worker.getWorkerCode());
        assertEquals(&quot;One First&quot;, worker.getWorkerName());
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), worker.getOutUtc().toInstant().toEpochMilli());

        List&lt;String&gt; subscriptionCodes = worker.getSubscriptions().stream().map(Subscription::getSubscriptionCode).collect(Collectors.toList());
        List&lt;String&gt; allSubscriptionCodes = Arrays.asList(&quot;SUB-1&quot;, &quot;SUB-2&quot;, &quot;SUB-3&quot;, &quot;SUB-4&quot;, &quot;SUB-5&quot;, &quot;SUB-6&quot;, &quot;SUB-7&quot;);
        assertTrue(allSubscriptionCodes.containsAll(subscriptionCodes));
    }



    @Test
    public void testC_getSubscriptionsWorkers()
    {
        ResponseEntity&lt;List&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/workers&quot;), List.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        List&lt;LinkedHashMap&lt;String,Object&gt;&gt; responseBody = response.getBody();

        for(LinkedHashMap&lt;String,Object&gt; map : responseBody)
        {
            String outUtcString = (String)map.get(&quot;outUtc&quot;);
            ZonedDateTime outUtcDate = ZonedDateTime.parse(outUtcString);
            assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), outUtcDate.toInstant().toEpochMilli());
        }
    }

    @Test
    public void testD_getSubscriptionsWorker()
    {
        ResponseEntity&lt;Subscription&gt; response = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/1/workers&quot;),
                Subscription.class);
        assertThat(response.getStatusCode(), equalTo(HttpStatus.OK));

        Subscription subscription = response.getBody();

        assertEquals(&quot;00000000-0000-0000-0000-000000000001&quot;, subscription.getAuditId());
        assertEquals(&quot;SUB-1&quot;, subscription.getSubscriptionCode());
        assertEquals(&quot;Subscription 1&quot;, subscription.getSubscriptionName());
        assertEquals(BaseEntity.DATE_INFINITY.toInstant().toEpochMilli(), subscription.getOutUtc().toInstant().toEpochMilli());

        List&lt;String&gt; workerCodes = subscription.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());
        List&lt;String&gt; allworkerCodes = Arrays.asList(&quot;CODE-1&quot;, &quot;CODE-2&quot;, &quot;CODE-3&quot;, &quot;CODE-4&quot;, &quot;CODE-5&quot;, &quot;CODE-6&quot;);
        assertTrue(allworkerCodes.containsAll(workerCodes));
    }

    @Test
    public void testE_postSubscriptionToWorker()
    {
        //  Verify that worker 1 does not have subscription 7
        ResponseEntity&lt;Worker&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/subscriptions&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Worker worker = getResponse.getBody();

        List&lt;String&gt; subscriptionCodes = worker.getSubscriptions().stream().map(Subscription::getSubscriptionCode).collect(Collectors.toList());

        assertFalse(subscriptionCodes.contains(&quot;SUB-7&quot;));

        //  Assign subscription 7 to worker 1
        ResponseEntity&lt;String&gt; postResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/1/subscriptions/7&quot;),
                HttpMethod.POST, null, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/workers/1/subscriptions/7&quot;));

        //  Read newly added subscription to worker
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/subscriptions&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        worker = getResponse.getBody();

        subscriptionCodes = worker.getSubscriptions().stream().map(Subscription::getSubscriptionCode).collect(Collectors.toList());

        assertTrue(subscriptionCodes.contains(&quot;SUB-7&quot;));
    }

    @Test
    public void testF_postWorkerToSubscription()
    {
        //  Verify that subscription 1 does not have worker 6
        ResponseEntity&lt;Subscription&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/1/workers&quot;), Subscription.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Subscription subscription = getResponse.getBody();

        List&lt;String&gt; workerCodes = subscription.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertFalse(workerCodes.contains(&quot;CODE-6&quot;));

        //  Assign worker 6 to subscription 1
        ResponseEntity&lt;String&gt; postResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/1/workers/6&quot;),
                HttpMethod.POST, null, String.class);
        assertThat(postResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = postResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/subscriptions/1/workers/6&quot;));

        //  Read newly added worker to subscription
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/1/workers&quot;), Subscription.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        subscription = getResponse.getBody();

        workerCodes = subscription.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertTrue(workerCodes.contains(&quot;CODE-6&quot;));
     }

    @Test
    public void testG_deleteSubscriptionFromWorker()
    {
        //  Verify that worker 1 has subscription 3
        ResponseEntity&lt;Worker&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/subscriptions&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Worker worker = getResponse.getBody();

        List&lt;String&gt; subscriptionCodes = worker.getSubscriptions().stream().map(Subscription::getSubscriptionCode).collect(Collectors.toList());

        assertTrue(subscriptionCodes.contains(&quot;SUB-3&quot;));

        //  Delete subscription 3 from worker
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/workers/1/subscriptions/3&quot;),
                HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/workers/1/subscriptions/3&quot;));

        //  Verify that worker 1 does not have subscription 3
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/workers/1/subscriptions&quot;), Worker.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        worker = getResponse.getBody();

        subscriptionCodes = worker.getSubscriptions().stream().map(Subscription::getSubscriptionCode).collect(Collectors.toList());

        assertFalse(subscriptionCodes.contains(&quot;SUB-3&quot;));
    }

    @Test
    public void testH_deleteWorkerFromSubscription()
    {
        //  Verify that subscription 1 has worker 1
        ResponseEntity&lt;Subscription&gt; getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/1/workers&quot;), Subscription.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        Subscription subscription = getResponse.getBody();

        List&lt;String&gt; workerCodes = subscription.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertTrue(workerCodes.contains(&quot;CODE-1&quot;));

        //  Delete worker 1 from subscription 1
        ResponseEntity&lt;String&gt; deleteResponse = testRestTemplate.exchange(createUrlWithPort(&quot;/subscriptions/1/workers/1&quot;),
                HttpMethod.DELETE, null, String.class);
        assertThat(deleteResponse.getStatusCode(), equalTo(HttpStatus.CREATED));
        String actual = deleteResponse.getHeaders().get(HttpHeaders.LOCATION).get(0);
        assertTrue(actual.contains(&quot;/subscriptions/1/workers/1&quot;));

        //  Verify that subscription 1 does not have worker 1
        getResponse = testRestTemplate.getForEntity(createUrlWithPort(&quot;/subscriptions/1/workers&quot;), Subscription.class);
        assertThat(getResponse.getStatusCode(), equalTo(HttpStatus.OK));

        subscription = getResponse.getBody();

        workerCodes = subscription.getWorkers().stream().map(Worker::getWorkerCode).collect(Collectors.toList());

        assertFalse(workerCodes.contains(&quot;CODE-1&quot;));
    }


    private String createUrlWithPort(String url)
    {
        return &quot;http://localhost:&quot; + port + url;
    }

}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><p><br/></p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Feb 12, 2021 23:36</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
