<!DOCTYPE html>
<html>
    <head>
        <title>DevOps : JavaScript CoderPad</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">DevOps</a></span>
                            </li>
                                                    <li>
                                <span><a href="DevOps-Home_603226548.html">DevOps Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Learn_522715137.html">Learn</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            DevOps : JavaScript CoderPad
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Nicholas Guner</span>, last modified on Oct 07, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <style type='text/css'>/*<![CDATA[*/
div.rbtoc1613190923367 {padding: 0px;}
div.rbtoc1613190923367 ul {list-style: disc;margin-left: 0px;}
div.rbtoc1613190923367 li {margin-left: 0px;padding-left: 0px;}

/*]]>*/</style><div class='toc-macro rbtoc1613190923367'>
<ul class='toc-indentation'>
<li><a href='#JavaScriptCoderPad-Easy'>Easy</a>
<ul class='toc-indentation'>
<li><a href='#JavaScriptCoderPad-CountLengthofCycle'>Count Length of Cycle</a></li>
<li><a href='#JavaScriptCoderPad-Election'>Election</a></li>
<li><a href='#JavaScriptCoderPad-LongestUniformString'>Longest Uniform String</a></li>
<li><a href='#JavaScriptCoderPad-RunLengthEncoding'>Run Length Encoding</a></li>
<li><a href='#JavaScriptCoderPad-SearchTree'>Search Tree</a></li>
<li><a href='#JavaScriptCoderPad-SecondSmallest'>Second Smallest</a></li>
<li><a href='#JavaScriptCoderPad-WalkingRobot'>Walking Robot</a></li>
</ul>
</li>
<li><a href='#JavaScriptCoderPad-Moderate'>Moderate</a>
<ul class='toc-indentation'>
<li><a href='#JavaScriptCoderPad-BestAverageGrade'>Best Average Grade</a></li>
<li><a href='#JavaScriptCoderPad-LongestWord'>Longest Word</a></li>
<li><a href='#JavaScriptCoderPad-MedianTwoSortedArrays'>Median Two Sorted Arrays</a></li>
<li><a href='#JavaScriptCoderPad-Snowpack'>Snowpack</a></li>
<li><a href='#JavaScriptCoderPad-StairCase'>Stair Case</a></li>
</ul>
</li>
<li><a href='#JavaScriptCoderPad-Hard'>Hard</a>
<ul class='toc-indentation'>
<li><a href='#JavaScriptCoderPad-HashMap'>HashMap</a></li>
<li><a href='#JavaScriptCoderPad-LowestPrice'>Lowest Price</a></li>
<li><a href='#JavaScriptCoderPad-PrefixSearch'>Prefix Search</a></li>
</ul>
</li>
</ul>
</div><h1 id="JavaScriptCoderPad-Easy">Easy</h1><h2 id="JavaScriptCoderPad-CountLengthofCycle">Count Length of Cycle</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * Instructions to candidate.
 *  1) Run this code in the REPL to observe its behaviour. The
 *     execution entry point is main().
 *  2) Consider adding some additional tests in doTestsPass().
 *  3) Implement countLengthOfCycle() correctly.
 *  4) If time permits, try to improve your implementation.
 */

var _ = require(&#39;lodash&#39;);

/**
 * countLengthOfCycle(arr, startIndex)
 *
 * You are given an integer array of size N. 
 * Every element of the array is greater than or equal to 0.
 * Starting from arr[startIndex], follow each element to the index it points to. 
 * Continue to do this until you find a cycle. 
 * Return the length of the cycle. If no cycle is found return -1
 *
 * Examples:
 * countLengthOfCycle([1, 0], 0) == 2
 * countLengthOfCycle([1, 2, 0], 0) == 3
*/
const countLengthOfCycle = function(arr, startIndex) {
  //TODO: Implement Solution
  
  return -1;
}

/**
 * boolean doTestsPass()
 * Returns true if all the tests pass. Otherwise returns false.
 */
const doTestsPass = () =&gt; {
  let testsPassed = true;
  let testCases = [
	[[1, 0], 0, 2],
	[[1, 2, 0], 0,  3]
  ];
  
  _.forEach(testCases, (testCase) =&gt;{
	testsPassed &amp;= 
	  countLengthOfCycle(testCase[0], testCase[1]) === testCase[2];
  })
  
  return testsPassed;
}

/**
 * Main execution entry.
 */
if(doTestsPass())
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">const countLengthOfCycle = function(arr, startIndex) {
  let visited = {};
  let index = startIndex;
  let count = 1;
  while(!(index in visited)){
	if(arr[index] &gt; arr.length) return -1;
	visited[index] = count;
	count++;
	index = arr[index];
  }
  
  return count - visited[index];
}

/**
 * boolean doTestsPass()
 * Returns true if all the tests pass. Otherwise returns false.
 */
const doTestsPass = () =&gt; {
  let testsPassed = true;
  let testCases = [
	[[1, 0], 0, 2],
	[[1, 2, 0], 0,  3],    
	/* additional test cases
	[[1, 1], 0, 1 ],
	[[1, 3, 0, 1], 0, 2],
	[[7], 0, -1],
	[[1, 2, 4], 0, -1]
	*/
  ];
  
  _.forEach(testCases, (testCase) =&gt;{
	testsPassed &amp;= 
	  countLengthOfCycle(testCase[0], testCase[1]) === testCase[2];
  })
  
  return testsPassed;
}

/**
 * Main execution entry.
 */
if(doTestsPass())
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-Election">Election</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">var _ = require(&#39;underscore&#39;);
/**
 * Instructions to candidate.
 * 1) Run this code in the REPL to observe its behaviour. The
 * execution entry point is main().
 * 2) Consider adding some additional tests in doTestsPass().
 * 3) Implement whoIsElected() correctly.
 * 4) If time permits, try to improve your implementation.
 */
var solution = (function(){

	/**
	 * A group of students are sitting in a circle. The teacher is electing a new class president. 
	 * The teacher does this by singing a song while walking around the circle. After the song is 
	 * finished the student at which the teacher stopped is removed from the circle. 
	 * 
	 * Starting at the student next to the one that was just removed, the teacher resumes singing and walking around the circle.
	 * After the teacher is done singing, the next student is removed. The teacher repeats this until only one student is left. 
	 *
	 * A song of length k will result in the teacher walking past k students on each round. The students are numbered 1 to n. The teacher starts at student 1.
	 * 
	 * For example, suppose the song length is two (k=2). And there are four students to start with (1,2,3,4). The first 
	 * student to go would be `2`, after that `4`, and after that `3`. Student `1` would be the next president in this example.
	 *
	 * @param n the number of students sitting in a circle.
	 * @param k the length (in students) of each song.
	 * @return the number of the student that is elected.
	 */
	function whoIsElected(n, k) {
		return -1;
	}
	
	
   /*
	* This function runs all of the tests in the &#39;testCases&#39; object (where keys are the input string and values are the expected integer array).
	*/
	function doTestsPass(testCases) {
	  var passes = true;
	  for(var i=0; i&lt;testCases.length; i++){
		const testCase = testCases[i];
		const expectedResult = testCase[2];
		const actualResult = whoIsElected(testCase[0], testCase[1]);
		passes = passes &amp;&amp; (expectedResult === actualResult);
	  }
	  return passes;
	}
	
	return {
		doTestsPass: doTestsPass,
		whoIsElected: whoIsElected
	};

})();

/*
  todo: add more test cases please!
*/
const testCases = [
	[1, 1, 1],
	[2, 2, 1],
	[4, 2, 1],
	[100, 2, 73]
]

if(solution.doTestsPass(testCases)){
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;Not all tests pass :(&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">var solution = (function(){

	/**
	 * A group of students are sitting in a circle. The teacher is electing a new class president. 
	 * The teacher does this by singing a song while walking around the circle. After the song is 
	 * finished the student at which the teacher stopped is removed from the circle. 
	 * 
	 * Starting at the student next to the one that was just removed, the teacher resumes singing and walking around the circle.
	 * After the teacher is done singing, the next student is removed. The teacher repeats this until only one student is left. 
	 *
	 * A song of length k will result in the teacher walking past k students on each round. The students are numbered 1 to n. The teacher starts at student 1.
	 * 
	 * For example, suppose the song length is two (k=2). And there are four students to start with (1,2,3,4). The first 
	 * student to go would be `2`, after that `4`, and after that `3`. Student `1` would be the next president in this example.
	 *
	 * @param n the number of students sitting in a circle.
	 * @param k the length (in students) of each song.
	 * @return the number of the student that is elected.
	 */
	function whoIsElected(n, k) {
	  if(n===1) return 1;
	  return (whoIsElected(n - 1, k) + k - 1) % n + 1;
	}
  
	function whoIsElected2(n, k) {
	  var l = _.range(1, n + 1);
	  var i = -1;
	  while( l.length &gt; 1) {
		l.splice((i+k)%l.length, 1);
		i = (i+k)%(l.length + 1) -1;
	  }
	  return l[0];
	}
  
	
   /*
	* This function runs all of the tests in the &#39;testCases&#39; object (where keys are the input string and values are the expected integer array).
	*/
	function doTestsPass(testCases) {
	  var passes = true;
	  for(var i=0; i&lt;testCases.length; i++){
		const testCase = testCases[i];
		const expectedResult = testCase[2];
		const actualResult = whoIsElected(testCase[0], testCase[1]);
		passes = passes &amp;&amp; (expectedResult === actualResult);
	  }
	  return passes;
	}
	
	return {
		doTestsPass: doTestsPass,
		whoIsElected: whoIsElected
	};

})();

/*
  todo: add more test cases please!
*/
const testCases = [
	[1, 1, 1],
	[2, 2, 1],
	[4, 2, 1],
	[100, 2, 73],
	[5, 3, 4],
	[6, 4, 5],
	[1000, 5, 763]
]

if(solution.doTestsPass(testCases)){
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;Not all tests pass :(&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-LongestUniformString">Longest Uniform String</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * Instructions to candidate:
 * 
 *  1) Run this code in the REPL to observe its behaviour. The
 *     execution entry point is main().
 *
 *  2) Your task is to implement the following function (&#39;longestUniformSubstring&#39;)
 *   
 *  This function should return an array with exactly two elements that describe the location of the longest
 *  uniform substring of a string input. The first element of the array should be the start index and the second 
 *  element is the length
 *  
 *  e.g.
 *      
 *      for the input: &quot;abbbccda&quot; the longest uniform substring is &quot;bbb&quot; 
 *      (which starts at index 1 and is 3 characters long).
 *      
 *      Therefore the return value would be the array: [1, 3]
 *  
 *  3) If time permits, consider adding additional test cases.
 */
var solution = (function(){

	function longestUniformSubstring(input){
		return [ -1, 0 ];
	}
	
	
   /*
	* This function runs all of the tests in the &#39;testCases&#39; object (where keys are the input string and values are the expected integer array).
	*/
	function doTestsPass(testCases) {
	  var passes = true;
	  for(var testCase in testCases){
		if(testCases.hasOwnProperty(testCase)){
		  var expectedResult = testCases[testCase];
		  var actualResult = longestUniformSubstring(testCase);
		  passes = passes &amp;&amp; (expectedResult[0] == actualResult[0] &amp;&amp; expectedResult[1] == actualResult[1]);
		}
	  }
	  return passes;
	}
	
	return {
		doTestsPass: doTestsPass,
		longestUniformSubstring: longestUniformSubstring
	};

})();

/*
  todo: add more test cases please!
*/
var testCases = {
  &quot;&quot;:             [ -1, 0  ],
  &quot;10000111&quot;:     [  1, 4  ],
  &quot;aabbbbbCdAA&quot;:  [  2, 5  ],
}

if(solution.doTestsPass(testCases)){
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;Not all tests pass :(&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">var solution = (function(){

	function longestUniformSubstring(input){
		var ix = 1;
		var longestLength = 0;
		var longestStart = -1;
		while (ix &lt; input.length){
			var start = ix - 1;
			var currentLength = 1;
			while (ix &lt; input.length &amp;&amp; input[ix] == input[ix - 1]){
				ix++;
				currentLength++;
			}
			if (currentLength &gt; longestLength){
				longestStart = start;
				longestLength = currentLength;
			}
			ix++;
		}
		return[ longestStart, longestLength ];
	}
	
	
   /*
	* You don&#39;t need to modify &#39;doTestsPass&#39;.
	*   This function runs all of the tests in the &#39;testCases&#39; object (where keys are the input string and values are the expected integer array).
	*/
	function doTestsPass(testCases) {
	  var passes = true;
	  for(var testCase in testCases){
		if(testCases.hasOwnProperty(testCase)){
		  var expectedResult = testCases[testCase];
		  var actualResult = longestUniformSubstring(testCase);
		  passes = passes &amp;&amp; (expectedResult[0] == actualResult[0] &amp;&amp; expectedResult[1] == actualResult[1]);
		}
	  }
	  return passes;
	}
	
	return {
		doTestsPass: doTestsPass,
		longestUniformSubstring: longestUniformSubstring
	};

})();

/*
  todo: add more test cases please!
*/
var testCases = {
  &quot;&quot;:             [ -1, 0  ],
  &quot;10000111&quot;:     [  1, 4  ],
  &quot;aabbbbbCdAA&quot;:  [  2, 5  ],
  &quot;1000011010101110110100010010011111111&quot;: [ 29, 8 ]
}

if(solution.doTestsPass(testCases)){
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;Not all tests pass :(&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-RunLengthEncoding">Run Length Encoding</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * Instructions to candidate.
 *  1) Run this code in the REPL to observe its behaviour.
 *  2) Consider adding some additional tests in doTestsPass().
 *  3) Implement rle() correctly.
 *  4) If time permits, try to improve your implementation.
 */


/**
 * rle ( testString )
 *
 * Implement a run length encoding function.
 *
 * For a string input the function returns output encoded as follows:
 *
 * &quot;a&quot;     -&gt; &quot;a1&quot;
 * &quot;aa&quot;    -&gt; &quot;a2&quot;
 * &quot;aabbb&quot; -&gt; &quot;a2b3&quot;
 * &quot;aabbbaa&quot; -&gt; &quot;a2b3a2&quot;
 * &quot;&quot;      -&gt; &quot;&quot;
 *
 */

const _ = require(&quot;underscore&quot;);

const rle = ( input ) =&gt; {
	// TODO: Implement solution
}

/**
 * boolean doTestsPass()
 * Returns true if all the tests pass. Otherwise returns false.
 */
/**
 * Returns true if all tests pass; otherwise, returns false.
 */
const doTestsPass = () =&gt; {

  const VALID_COMBOS = {&quot;aaa&quot;: &quot;a3&quot;, &quot;aaabbc&quot;:&quot;a3b2c1&quot;};

  let testPassed = true;

  _.forEach(VALID_COMBOS, function(value, key) {
	console.log(key, rle(key));
	if (value !== rle(key)) {
		testPassed = false;
	}
  });

  return testPassed;
}


/**
 * Main execution entry.
 */
if(doTestsPass())
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">const _ = require(&quot;underscore&quot;);

const rle = ( input ) =&gt; {
  if (_.isEmpty(input)) {
	return &quot;&quot;;
  }

  let result = &quot;&quot;;

  let lastSeen = &quot;&quot;;
  let count = 1;

  for(let i = 0; i &lt; input.length; i++){
	  let current = input.substring(i, i + 1);
	  if(lastSeen === current){
		count++;
	  } else {
		if(!_.isEmpty(lastSeen)){
		  result += lastSeen + count;
		}
		count = 1;
		lastSeen = current;
	  }
  }
  result += lastSeen + count;
  return result;
}

/**
 * boolean doTestsPass()
 * Returns true if all the tests pass. Otherwise returns false.
 */
/**
 * Returns true if all tests pass; otherwise, returns false.
 */
const doTestsPass = () =&gt; {

  const VALID_COMBOS = {&quot;&quot;: &quot;&quot;, &quot;a&quot;: &quot;a1&quot;, &quot;aaa&quot; : &quot;a3&quot; , &quot;aaabbbaad&quot;:&quot;a3b3a2d1&quot;};

  let testPassed = true;

  _.forEach(VALID_COMBOS, function(value, key) {
	console.log(key, rle(key));
	if (value !== rle(key)) {
		testPassed = false;
	}
  });

  return testPassed;
}


/**
 * Main execution entry.
 */
if(doTestsPass())
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-SearchTree">Search Tree</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/*
 Instructions to candidate.
  1) Run this code in the REPL to observe its behaviour. The
   execution entry point is main().
  2) Implement the &quot;put&quot; and &quot;contains&quot; methods.
  3) Fix the &quot;inOrderTraversal&quot; method.
  4) Add additional relevant tests
  5) If time permits, try to improve your implementation.
*/

var _ = require(&quot;underscore&quot;);

class Node
{

}


function put(node, value)
{
  // TODO implement me
}


function contains(node, value)
{
  // TODO implement me
}

function inOrderTraversal(node)
{
  return inOrderTraversalAcc(node, []);
}


function inOrderTraversalAcc(node, acc)
{
  if (!node.value)
  {
  return acc;
  }

  inOrderTraversalAcc(node.left, acc);
  acc.push(node.value);
  inOrderTraversalAcc(node.right, acc);
  return acc;

}


function assert(condition)
{
  if (! condition)
	throw new Error();
}

function testTree()
{
  var tree = new Node();
  put(tree, 3);
  put(tree, 1);
  put(tree, 2);
  put(tree, 5);
  assert(!contains(tree, 0));
  assert(contains(tree, 1));
  assert(contains(tree, 2));
  assert(contains(tree, 3));
  assert(!contains(tree, 4));
  assert(contains(tree, 5));
  assert(!contains(tree, 6));
  assert(_.isEqual(inOrderTraversal(tree), [1,2,3,5]));

}

function doTestsPass()
{
   testTree();
   // TODO add more tests
}


/**
 * Main execution entry.
 */
doTestsPass();
console.log(&quot;Success!&quot;);</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">var _ = require(&quot;underscore&quot;);

class Node
{

}


function put(node, value)
{
  if (!value)
  {
	return;
  }

  if (!node.value)
  {
	  node.value = value;
	  node.left = new Node();
	  node.right = new Node();
  }
  else
  {
	if (value &lt; node.value)
	{
	  put(node.left, value);
	}
	else
	{
	  put(node.right, value);
	}

  }
}


function contains(node, value)
{
  if (!node || !value)
  {
	return false;
  }
  else if (node.value === value)
  {
	return true;
  }
  else if (node.value &amp;&amp; value &lt; node.value)
  {
	return contains(node.left, value);
  }
  else
  {
	return contains(node.right, value);
  }

}

function inOrderTraversal(node)
{
  return inOrderTraversalAcc(node, []);
}


function inOrderTraversalAcc(node, acc)
{
  if (!node.value)
  {
	return acc;
  }

  inOrderTraversalAcc(node.left, acc);
  acc.push(node.value);
  inOrderTraversalAcc(node.right, acc);
  return acc;

}


function assert(condition)
{
  if (! condition)
  {
	throw new Error();

  }
}

function testTree()
{
  var tree = new Node();
  put(tree, 3);
  put(tree, 1);
  put(tree, 2);
  put(tree, 5);
  assert(!contains(tree, 0));
  assert(contains(tree, 1));
  assert(contains(tree, 2));
  assert(contains(tree, 3));
  assert(!contains(tree, 4));
  assert(contains(tree, 5));
  assert(!contains(tree, 6));
  assert(_.isEqual(inOrderTraversal(tree), [1,2,3,5]));

}


function testEmptyTree()
{
  var emptyTree = new Node();
  assert(_.isEqual(inOrderTraversal(emptyTree), []));

}

function testNegative()
{
  var negativeTree = new Node();
  put(negativeTree, -1);
  put(negativeTree, 11);
  put(negativeTree, -10);
  put(negativeTree, 50);
  assert(contains(negativeTree, -10));
  assert(contains(negativeTree, -1));
  assert(contains(negativeTree, 11));
  assert(contains(negativeTree, 50));
  assert(_.isEqual(inOrderTraversal(negativeTree), [-10, -1, 11, 50]));

}

function testDupes()
{
  var dupeTree = new Node();
  put(dupeTree, 1);
  put(dupeTree, 2);
  put(dupeTree, 1);
  put(dupeTree, 2);
  assert(contains(dupeTree, 1));
  assert(contains(dupeTree, 2));
  assert(_.isEqual(inOrderTraversal(dupeTree), [1, 1, 2, 2]));

}

function testUndefined()
{
  var undefinedTree = new Node();
  put(undefinedTree, undefined);
  assert(!contains(undefinedTree, undefined));
  assert(_.isEqual(inOrderTraversal(undefinedTree), []));

}

function testNull()
{
  var nullTree = new Node();
  put(nullTree, null);
  assert(!contains(nullTree, null));
  assert(_.isEqual(inOrderTraversal(nullTree), []));

}

function doTestsPass()
{
  testTree();
  testEmptyTree();
  testNegative();
  testDupes();
  testUndefined();
  testNull();

}


/**
 * Main execution entry.
 */
doTestsPass();
console.log(&quot;Success!&quot;);</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-SecondSmallest">Second Smallest</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * Returns the second smallest element in the array x.
 * Returns 0 if the array has fewer than 2 elements.
 */
function secondSmallest(x)
{
  // todo: implement this function
  return 0;
}


/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass()
{
  // todo: add more test cases
  var testArrays  = [[0], [0, 1]];
  var testResults = [0, 1];
  
  // Run through the tests and make assertions
  for(var i = 0; i &lt; testArrays.length; i++)
  {
	if(secondSmallest(testArrays[i]) != testResults[i])
	{
	  return false;
	}
  }
  return true;
}


/**
 * Main execution entry.
 */
if(doTestsPass())
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">function secondSmallest(x)
{
  // First check if the array is large enough
  if(x.length &lt; 2)
  {
	return 0;
  }

  // Start these at infinity so that they&#39;re always bigger
  // than the input
  var smallest       = Number.POSITIVE_INFINITY;
  var secondSmallest = Number.POSITIVE_INFINITY;
  var current;


  // Loop through the input and keep updating our
  // smallest and second smallest
  for(var i = 0; i &lt; x.length; i++)
  {
	current = x[i];
	if(current &lt; smallest)
	{
	  secondSmallest = smallest;
	  smallest       = current;
	}
	else if(current &lt; secondSmallest)
	{
	  secondSmallest = current;
	}
  }
  return secondSmallest;
}


/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass()
{
  // todo: add more test cases
  var testArrays  = [[], [0], [0, 1], [-1,0,1,-2,2], [1,1,2]];
  var testResults = [0, 0, 1, -1, 1];

  // Run through the tests and make assertions
  for(var i = 0; i &lt; testArrays.length; i++)
  {
	if(secondSmallest(testArrays[i]) != testResults[i])
	{
	  return false;
	}
  }
  return true;
}


/**
 * Main execution entry.
 */
if(doTestsPass())
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-WalkingRobot">Walking Robot</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">// Instructions to candidate
//
// 1. Run this code in the REPL to observe its behaviour. The
//    execution entry point is main().
// 2. Implement the &#39;walk&#39; method. This method takes in a string, path,
//    where each character in the string corresponds to a potential movement
//    of the robot. The robot can move up, down, left, and right represented
//    by the characters &#39;U&#39;, &#39;D&#39;, &#39;L&#39;, and &#39;R&#39; respectively. All other
//    characters may be ignored. Assume the robot&#39;s initial position
//    is at (0,0). The output of this method is the robot&#39;s final x and y
//    coordinates relative to the initial position.
// 3. Consider adding more test cases

&#39;use strict&#39;;

var chai = require(&#39;chai&#39;);
var Mocha = require(&#39;mocha&#39;);
var mocha = new Mocha({ui: &#39;bdd&#39;});
var assert = chai.assert;

function walk(path) {
	//TODO: Implement walk function
	return undefined;
}

// Start CoderPad testing bootstrap - do not modify
mocha.suite.emit(&#39;pre-require&#39;, this, &#39;solution&#39;, mocha);
// End CoderPad testing bootstrap

describe(&#39;&quot;walk&quot; Test Suite&#39;, function() {

  it(&#39;go 3 times up&#39;, function() {
	var input = &#39;UUU&#39;;
	var result = walk(input);
	assert.deepEqual(result, [0, 3], &#39;&#39;);
  });

  it(&#39;simple test&#39;, function() {
	var input = &#39;ULDR&#39;;
	var result = walk(input);
	assert.deepEqual(result, [0, 0], &#39;simple test&#39;);
  });

  it(&#39;extensive test&#39;, function() {
	var input = &#39;ULLLDUDUURLRLR&#39;;
	var result = walk(input);
	assert.deepEqual(result, [-2, 2], &#39;extensive test&#39;);
  });

  it(&#39;another input&#39;, function() {
	var input = &#39;UP LEFT 2xDOWN DOWN RIGHT RIGHT UP UP&#39;;
	var result = walk(input);
	assert.deepEqual(result, [1, 1], &#39;another input&#39;);
  });
});


mocha.run(function() {});</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">&#39;use strict&#39;;

var chai = require(&#39;chai&#39;);
var Mocha = require(&#39;mocha&#39;);
var mocha = new Mocha({ui: &#39;bdd&#39;});
var assert = chai.assert;

function walk(path) {
  return path.split(&quot;&quot;).map(function(direction) {
	switch(direction) {
	  case &#39;U&#39;: return function(x, y) { return [x, y+1]; };
	  case &#39;D&#39;: return function(x, y) { return [x, y-1]; };
	  case &#39;L&#39;: return function(x, y) { return [x-1, y]; };
	  case &#39;R&#39;: return function(x, y) { return [x+1, y]; };
	  default: return function(x, y) { return [x, y]; };
	}
  }).reduce(function(acc, move) {
	return move.apply(move, acc);
  }, [0, 0]);
}

// Start CoderPad testing bootstrap - do not modify
mocha.suite.emit(&#39;pre-require&#39;, this, &#39;solution&#39;, mocha);
// End CoderPad testing bootstrap

describe(&#39;&quot;walk&quot; Test Suite&#39;, function() {

  it(&#39;stay&#39;, function() {
	var input = &#39;&#39;;
	var result = walk(input);
	assert.deepEqual(result, [0, 0], &#39;&#39;);
  });

  it(&#39;single test&#39;, function() {
	var input = &#39;L&#39;;
	var result = walk(input);
	assert.deepEqual(result, [-1, 0], &#39;simple test&#39;);
  });

  it(&#39;go 3 times up&#39;, function() {
	var input = &#39;UUU&#39;;
	var result = walk(input);
	assert.deepEqual(result, [0, 3], &#39;&#39;);
  });

  it(&#39;simple test&#39;, function() {
	var input = &#39;ULDR&#39;;
	var result = walk(input);
	assert.deepEqual(result, [0, 0], &#39;simple test&#39;);
  });

  it(&#39;extensive test&#39;, function() {
	var input = &#39;ULLLDUDUURLRLR&#39;;
	var result = walk(input);
	assert.deepEqual(result, [-2, 2], &#39;extensive test&#39;);
  });

  it(&#39;another input&#39;, function() {
	var input = &#39;UP LEFT 2xDOWN DOWN RIGHT RIGHT UP UP&#39;;
	var result = walk(input);
	assert.deepEqual(result, [1, 1], &#39;another input&#39;);
  });
});


mocha.run(function() {});</pre>
</div></div></td></tr></tbody></table></div><h1 id="JavaScriptCoderPad-Moderate">Moderate</h1><h2 id="JavaScriptCoderPad-BestAverageGrade">Best Average Grade</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/*
**  Instructions:
**
**  Given a list of student test scores, find the best average grade.
**  Each student may have more than one test score in the list.
**
**  Complete the bestAverageGrade function in the editor below.
**  It has one parameter, scores, which is an array of student test scores.
**  Each element in the array is a two-element array of the form [student name, test score]
**  e.g. [ &quot;Bobby&quot;, &quot;87&quot; ].
**  Test scores may be positive or negative integers.
**
**  If you end up with an average grade that is not an integer, you should
**  use a floor function to return the largest integer less than or equal to the average.
**  Return 0 for an empty input.
**
**  Example:
**
**  Input:
**  [ [ &quot;Bobby&quot;, &quot;87&quot; ],
**    [ &quot;Charles&quot;, &quot;100&quot; ],
**    [ &quot;Eric&quot;, &quot;64&quot; ],
**    [ &quot;Charles&quot;, &quot;22&quot; ] ].
**
**  Expected output: 87
**  Explanation: The average scores are 87, 61, and 64 for Bobby, Charles, and Eric,
**  respectively. 87 is the highest.
*/

function bestAverageGrade(scores) {

  // TODO: implement this function
  return 0;
}

/**
 * boolean doTestsPass()
 * Returns true if all the tests pass. Otherwise returns false.
 */
/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass() {

  const tc1 = [
	[ &#39;Bobby&#39;, &#39;87&#39; ],
	[ &#39;Charles&#39;, &#39;100&#39; ],
	[ &#39;Eric&#39;, &#39;64&#39; ],
	[ &#39;Charles&#39;, &#39;22&#39; ]
  ];

  return bestAverageGrade(tc1) === 87;
}

/**
 * Main execution entry.
 */
if(doTestsPass()) {
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">function bestAverageGrade(scores) {

  // Check for empty list
  if (!Array.isArray(scores) || scores.length === 0)
	return 0;
  
  // Build hashmap of students to list of scores
  const studentsToScores = new Object();
  scores.forEach(scoreRow =&gt; {
	
	// Check for well-formed input
	if (!Array.isArray(scoreRow) || scoreRow.length != 2)
	  return 0;
	
	const [student, score] = [scoreRow[0], parseFloat(scoreRow[1])];
	
	// Find student in list
	const currentScores = studentsToScores[student];
	if (!currentScores) {
	  studentsToScores[student] = [score];
	} else {
	  // append score to list
	  currentScores.push(score);
	}
  });
  
  // get averages and max
  let max = Number.NEGATIVE_INFINITY;
  Object.keys(studentsToScores).forEach(student =&gt; {
	const scores = studentsToScores[student];
	const sum = scores.reduce((a, b) =&gt; a + b, 0);
	const average = sum / scores.length;
	max = Math.max(max, average);
  });

  return Math.floor(max);
}

/**
 * boolean doTestsPass()
 * Returns true if all the tests pass. Otherwise returns false.
 */
/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass() {

  // test cases and expected results
  const testCases = [

	// example    
	{   
	  input: [
		[ &#39;Bobby&#39;, &#39;87&#39; ],
		[ &#39;Charles&#39;, &#39;100&#39; ],
		[ &#39;Eric&#39;, &#39;64&#39; ],
		[ &#39;Charles&#39;, &#39;22&#39; ]
	  ],
	  expectedOutput: 87
	},
	
	// empty
	{
	  input: [],
	  expectedOutput:  0
	},
	
	// multiple scores each
	{
	  input: [
		[ &#39;Sarah&#39;, &#39;91&#39; ],
		[ &#39;Goldie&#39;, &#39;92&#39; ],
		[ &#39;Elaine&#39;, &#39;93&#39; ],
		[ &#39;Elaine&#39;, &#39;95&#39; ],
		[ &#39;Goldie&#39;, &#39;94&#39; ],
		[ &#39;Sarah&#39;, &#39;93&#39; ]
	  ],
	  expectedOutput: 94
	},
	
	// negatives and zeros
	{
	  input: [
		[ &#39;Janie&#39;, &#39;-66&#39; ],
		[ &#39;Janie&#39;, &#39;0&#39; ],
		[ &#39;Gina&#39;, &#39;-88&#39; ],
		[ &#39;Bobby&#39;, &#39;0&#39; ],
		[ &#39;Gina&#39;, &#39;44&#39; ],
		[ &#39;Bobby&#39;, &#39;0&#39; ],
		[ &#39;Bobby&#39;, &#39;-6&#39; ]        
	  ],
	  expectedOutput: -2
	},
	
	// same value and average
	{
	  input: [
		[ &#39;Alpha&#39;, &#39;99&#39; ],
		[ &#39;Bravo&#39;, &#39;99&#39; ],
		[ &#39;Charlie&#39;, &#39;99&#39; ],
		[ &#39;Delta&#39;, &#39;99&#39; ],
		[ &#39;Echo&#39;, &#39;99&#39; ],
		[ &#39;Foxtrot&#39;, &#39;99&#39; ],
		[ &#39;Foxtrot&#39;, &#39;99&#39; ]      
	  ],
	  expectedOutput: 99
	},
	
	// non-integer average
	{
	  input: [
		[ &#39;Gerald&#39;, &#39;91&#39; ],
		[ &#39;Gerald&#39;, &#39;92&#39; ]
	  ],
	  expectedOutput: 91
	},
	
	// negative non-integer average
	{
	  input: [
		[ &#39;Barry&#39;, &#39;-66&#39; ],
		[ &#39;Barry&#39;, &#39;-65&#39; ],
		[ &#39;Alfred&#39;, &#39;-122&#39; ]
	  ],
	  expectedOutput: -66
	}    
  ];
  
  let passed = true; 
  testCases.forEach(testCase =&gt; {
	const actual = bestAverageGrade(testCase.input);
	if (actual != testCase.expectedOutput) {
	  passed = false;
	  console.error(`Failed for ${testCase.input}\n  expected ${testCase.expectedOutput}, actual ${actual}`);
	}
  });
  
  return passed;
}

/**
 * Main execution entry.
 */
if(doTestsPass()) {
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-LongestWord">Longest Word</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * Instructions to candidate.
 *  1) Given a a string of letters and a dictionary, the function longestWord should
 *     find the longest word or words in the dictionary that can be made from the letters
 *     Input: letters = &quot;oet&quot;, dictionary = {&quot;to&quot;,&quot;toe&quot;,&quot;toes&quot;}
 *     Output: {&quot;toe&quot;}
 *     Only lowercase letters will occur in the dictionary and the letters
 *     The length of letters will be between 1 and 10 characters
 *     The solution should work well for a dictionary of over 100,000 words
 *  2) Run this code in the REPL to observe its behaviour.
 *  3) Consider adding some additional tests in doTestsPass().
 *  4) Implement the longestWord() method correctly.
 *  5) If time permits, introduce &#39;?&#39; which can represent any letter.  &quot;to?&quot; could match to &quot;toe&quot;, &quot;ton&quot; etc
 */

var _ = require(&#39;underscore&#39;);

class Dictionary {
	constructor(words) {
		this.words = words
	}

	contains(word) {
		return _.contains(this.words, word);
	}
}

function longestWord(letters, dict) {
	return dict.contains(letters) ? [letters] : [];
}

function arraysEqual(arr1, arr2) {
  return _.difference(arr1, arr2).length == 0 &amp;&amp; _.difference(arr2, arr1) == 0
}

function doTestsPass() {
  var words = [&quot;to&quot;, &quot;toe&quot;, &quot;toes&quot;, &quot;doe&quot;, &quot;dog&quot;, &quot;god&quot;, &quot;dogs&quot;, &quot;book&quot;, &quot;banana&quot;];
  let dict = new Dictionary(words);

  var result = arraysEqual([&quot;toe&quot;], longestWord(&quot;toe&quot;, dict));
  result = result &amp;&amp; arraysEqual([&quot;toes&quot;, &quot;dogs&quot;], longestWord(&quot;osetdg&quot;, dict));
  
  return result;
}

/**
 * Main execution entry.
 */
if(doTestsPass()) {
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">var _ = require(&#39;underscore&#39;);

function dropChars(letters) {
	return _.range(0, letters.length).map(function (pos) {
		return (pos &gt; 0 ? letters.slice(0, pos) : &quot;&quot;) + letters.slice(pos + 1);
	}, []);
};

// For each string in set return a new set with all possibilities with 1 char dropped from lettersCombinations
function combinationsDroppingOneLetter(lettersCombinations) {
	return _.keys(lettersCombinations.reduce(function (memo, letters) {
		return dropChars(letters).reduce(function (memo, letters) {
			memo[letters] = true;
			return memo;
		}, memo);
	}, {}));
};

function sortLetters(letters) {
	return letters.split(&quot;&quot;).sort().join(&#39;&#39;);
};

class Dictionary {
	constructor(words) {
		this.processedWords = this.process(words);
	}

	// Pre-process dictionary so we have list of dictionary entries stored against a sorted string
	// e.g. &quot;dgo&quot;-&gt; {&quot;dog&quot;, &quot;god&quot;}
	process(words) {
		return words.reduce(function preProc(memo, letters) {
			var sortedLetters = sortLetters(letters);
			(memo[sortedLetters] || (memo[sortedLetters] = [])).push(letters);
			return memo;
		}, {});
	}

	getEntriesForSortedLetters(sortedLetters) {
		return this.processedWords[sortedLetters];
	}

}

function longestWord(letters, dict) {
	// To support ? wild card could expand all possibilites here.  A better solution would be Tree/Trie based
	// Set with one entry of letters sorted
	var considerLettersList = [sortLetters(letters)];
	while (considerLettersList.length &gt; 0) {
		// Get list of words in dictionary that match any of the set of sorted letters
		var allFoundInDict = considerLettersList.reduce(function (memo, letters) {
			var matchingWords = dict.getEntriesForSortedLetters(letters);
			if (!!matchingWords) {
				memo.push(matchingWords);
			}
			return memo;
		}, []);
		if (allFoundInDict.length &gt; 0) {
			return _.flatten(allFoundInDict);
		}
		// Next time round loop will consider combinations of sorted letters with one less character
		considerLettersList = combinationsDroppingOneLetter(considerLettersList);
	}
}

function arraysEqual(arr1, arr2) {
  return _.difference(arr1, arr2).length == 0 &amp;&amp; _.difference(arr2, arr1) == 0
}

function doTestsPass() {
  var result = arraysEqual([&quot;ab&quot;, &quot;bc&quot;, &quot;ac&quot;], combinationsDroppingOneLetter([&quot;abc&quot;]));
  result = result &amp;&amp; arraysEqual([&quot;ab&quot;, &quot;bb&quot;], combinationsDroppingOneLetter([&quot;abb&quot;]));
  result = result &amp;&amp; arraysEqual([&quot;a&quot;, &quot;b&quot;], combinationsDroppingOneLetter([&quot;ab&quot;,&quot;bb&quot;]));
  result = result &amp;&amp; arraysEqual([], combinationsDroppingOneLetter([&quot;a&quot;,&quot;b&quot;]));
  
  var words = [&quot;to&quot;, &quot;toe&quot;, &quot;toes&quot;, &quot;doe&quot;, &quot;dog&quot;, &quot;god&quot;, &quot;dogs&quot;, &quot;book&quot;, &quot;banana&quot;];
  let dict = new Dictionary(words);
  
  result = result &amp;&amp; arraysEqual([&quot;toe&quot;], longestWord(&quot;toe&quot;, dict));
  result = result &amp;&amp; arraysEqual([&quot;toes&quot;, &quot;dogs&quot;], longestWord(&quot;osetdg&quot;, dict));
  result = result &amp;&amp; arraysEqual([&quot;doe&quot;,&quot;toe&quot;, &quot;dog&quot;, &quot;god&quot;], longestWord(&quot;oetdg&quot;, dict));
  result = result &amp;&amp; arraysEqual([&quot;book&quot;], longestWord(&quot;obokt&quot;, dict));
  result = result &amp;&amp; arraysEqual([&quot;banana&quot;], longestWord(&quot;nanabaook&quot;, dict));
  result = result &amp;&amp; arraysEqual([], longestWord(&quot;aeiou&quot;, dict));
  result = result &amp;&amp; arraysEqual([], longestWord(&quot;a&quot;, dict));
  
  return result;
}

/**
 * Main execution entry.
 */
if(doTestsPass()) {
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-MedianTwoSortedArrays">Median Two Sorted Arrays</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * Instructions to candidate.
 *  1) Run this code in the REPL to observe its behaviour.
 *  2) Find the median of the two sorted arrays.
 */

function findMedianSortedArrays(A, B) {
	return -1;
  //todo
}

/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass(testCases)
{
  // todo: add more test cases
  return testCases.reduce((result, testCase) =&gt; {
	  const answer = findMedianSortedArrays(testCase.inputs[0], testCase.inputs[1]);
	  console.info(&quot;expected: &quot;, testCase.expected, &quot;, answer: &quot;, answer);
	  return result &amp;&amp; (answer === testCase.expected);
  }, true);
}


const testCases = [
  { expected: 2.5, inputs: [[1, 3], [2, 4]] },
  { expected: 2.0, inputs: [[1, 3], [2]] },
];

/**
 * Main execution entry.
 */
if(doTestsPass(testCases))
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">function findMedianSortedArrays(A, B) {
	var m = A.length;
	var n = B.length;

	if ((m + n) % 2 != 0) // odd
		return findKth(A, B, parseInt((m + n) / 2), 0, m - 1, 0, n - 1);
	else { // even
		return (findKth(A, B, parseInt((m + n) / 2), 0, m - 1, 0, n - 1)
			+ findKth(A, B, parseInt((m + n) / 2) - 1, 0, m - 1, 0, n - 1)) * 0.5;
	}
}

function findKth(A, B, k,
	aStart, aEnd, bStart, bEnd) {

	var aLen = aEnd - aStart + 1;
	var bLen = bEnd - bStart + 1;

	// Handle special cases
	if (aLen == 0)
		return B[bStart + k];
	if (bLen == 0)
		return A[aStart + k];
	if (k == 0)
		return A[aStart] &lt; B[bStart] ? A[aStart] : B[bStart];

	var aMid = parseInt(aLen * k / (aLen + bLen)); // a&#39;s middle count
	var bMid = parseInt(k - aMid - 1); // b&#39;s middle count

	// make aMid and bMid to be array index
	aMid = aMid + aStart;
	bMid = bMid + bStart;

	if (A[aMid] &gt; B[bMid]) {
		k = k - (bMid - bStart + 1);
		aEnd = aMid;
		bStart = bMid + 1;
	} else {
		k = k - (aMid - aStart + 1);
		bEnd = bMid;
		aStart = aMid + 1;
	}

	return findKth(A, B, k, aStart, aEnd, bStart, bEnd);
}

/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass(testCases)
{
  // todo: add more test cases
  return testCases.reduce((result, testCase) =&gt; {
	  const answer = findMedianSortedArrays(testCase.inputs[0], testCase.inputs[1]);
	  console.info(&quot;expected: &quot;, testCase.expected, &quot;, answer: &quot;, answer);
	  return result &amp;&amp; (answer === testCase.expected);
  }, true);
}


const testCases = [
  { expected: 2.5, inputs: [[1, 3], [2, 4]] },
  { expected: 2.0, inputs: [[1, 3], [2]] }
];

/**
 * Main execution entry.
 */
if(doTestsPass(testCases))
{
  console.log(&quot;All tests pass!&quot;);
}
else
{
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-Snowpack">Snowpack</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/*
** Instructions to candidate.
**  1) Given an array of non-negative integers representing the elevations
**     from the vertical cross section of a range of hills, determine how
**     many units of snow could be captured between the hills. 
**
**     See the example array and elevation map below.
**                                 ___
**             ___                |   |        ___
**            |   |        ___    |   |___    |   |
**         ___|   |    ___|   |   |   |   |   |   |
**     ___|___|___|___|___|___|___|___|___|___|___|___
**     {0,  1,  3,  0,  1,  2,  0,  4,  2,  0,  3,  0}
**                                 ___
**             ___                |   |        ___
**            |   | *   *  _*_  * |   |_*_  * |   |
**         ___|   | *  _*_|   | * |   |   | * |   |
**     ___|___|___|_*_|___|___|_*_|___|___|_*_|___|___
**     {0,  1,  3,  0,  1,  2,  0,  4,  2,  0,  3,  0}
**
**     Solution: In this example 13 units of snow (*) could be captured.
**  
**  2) Consider adding some additional tests.
**  3) Implement computeSnowpack() correctly.
*/

/**
* Find the amount that will be captured
* @returns {int}
**/
function computeSnowpack(heights = []) {
	// your code here
	return -1;
};

function doTestsPass() {
	const  testSet = [
		[0, 1, 3, 0, 1, 2, 0, 4, 2, 0, 3, 0],
		[1,3,2,4,1,3,1,4,5,2,2,1,4,2,2],
	];
	const expectedValues = [
		13,
		15,
	];
	let success = true;
	for (let i=0; i &lt; testSet.length; i++) {
		const testCase = testSet[i];
		const expected = expectedValues[i];
		const actual = computeSnowpack(testCase);
		if (expected !== actual) {
			console.error(`Expected ${expected}. Got ${actual}`);
			success = false;
		}
	}

	if (!success) {
		throw new Error(&quot;Tests failed&quot;);
	} else {
		console.log(&quot;Tests passed&quot;)
	}
}

doTestsPass();</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
* Find the amount that will be captured
* @returns {int}
**/
//function computeSnowpack(height = []){
//  const n = height.length;
//
//  const left = [];
//  const right = [];
//
//  let leftMax = 0;
//  let rightMax = 0;
//
//  for (let i = 0, j = n - 1; i &lt; n, j &gt;= 0; i++, j--) {
//    // Scan from left
//    left[i] = leftMax;
//    leftMax = Math.max(leftMax, height[i]);
//
//    // Scan from right
//    right[j] = rightMax;
//    rightMax = Math.max(rightMax, height[j]);
//  }
//
//  let total = 0;
//  for (let i = 0; i &lt; n; i++) {
//    let snow = Math.min(left[i], right[i]) - height[i];
//    total += snow &gt; 0 ? snow : 0;
//  }
//
//  return total;
//}


/**
* Find the amount that will be captured
* @returns {int}
**/
function computeSnowpack(heights = []) {
	const nHeights = heights.length;
	if (nHeights === 0) {
		return 0;
	}
	let total = 0;
	const leftHighest = new Array(nHeights).fill(0);
	let leftMax = 0;
	
	for(let i=0; i &lt; nHeights; i++) {
		if (heights[i] &gt; leftMax) {
			leftMax = heights[i];
		}
		leftHighest[i] = leftMax;
	}
	
	let rightMax = 0;
	for (let i = nHeights - 1; i &gt;=0; i--) {
		if (heights[i] &gt; rightMax) {
			rightMax = heights[i];
		}
		if (Math.min(rightMax, leftHighest[i]) &gt; heights[i] ) {
			total += Math.min(rightMax, leftHighest[i]) - heights[i];
		}
	}
	return total;
}


function doTestsPass() {
	const  testSet = [
		[0, 1, 3, 0, 1, 2, 0, 4, 2, 0, 3, 0],
		[1,3,2,4,1,3,1,4,5,2,2,1,4,2,2],
		[1,0,0,0,0,0,0,0,0,0,0,1],
		[1],
		[0,0,0,0,0],
		[0,0,1,0,0],
		[]
	];
	const expectedValues = [
		13,
		15,
		10,
		0,
		0,
		0,
		0,
	];
	let success = true;
	for (let i=0; i &lt; testSet.length; i++) {
		const testCase = testSet[i];
		const expected = expectedValues[i];
		const actual = computeSnowpack(testCase);
		if (expected !== actual) {
			console.error(`Expected ${expected}. Got ${actual}`);
			success = false;
		}
	}

	if (!success) {
		throw new Error(&quot;Tests failed&quot;);
	} else {
		console.log(&quot;All tests passed!&quot;)
	}
}

doTestsPass();</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-StairCase">Stair Case</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/*
== Instructions ==

** There is a staircase with &#39;n&#39; number of steps. A child
** walks by and wants to climb up the stairs, starting at
** the bottom step and ascending to the top.

** Of course, the child wants to have fun, too, so instead
** of taking 1 step at a time, it will vary between taking
** either 1, 2 or 3 steps at a time.

** Please complete the &#39;countSteps&#39; method below so that
** given &#39;n&#39; number of steps it will return the number of
** unique combinations the child could traverse.

** An example would be countSteps(3) == 4:

** 1 1 1
** 2 1
** 1 2
** 3
*/

/**
 * Given n steps, returns the number of possible permutations
 * to climb the staircase.
 *
 * Returns 0 when n is &lt;= 0.
 */
function countSteps(n)
{
	return 0;
}


/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass()
{
	// todo: add more test cases
	return countSteps(3) == 4
		&amp;&amp; countSteps(4) == 7;
}


/**
 * Execution entry.
 */
if(doTestsPass())
{
	console.log(&quot;All tests pass!&quot;);
}
else
{
	console.log(&quot;There are test failures.&quot;);
}

for(var n = 1; n &lt;= 5; n++)
   console.log(n, &quot; steps =&gt; &quot;, countSteps(n))</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">function countStepsRec(n)
{
	if(n &lt; 0) return 0;
	if(n === 0) return 1;

	return countStepsRec(n - 1) + countStepsRec(n - 2) + countStepsRec(n - 3);
}

function countSteps(n)
{
	if(n &lt;= 0) return 0;

	return countSteps(n);
}
*/

// Iterative linear solution
function countSteps(n)
{
	if(n &lt;= 0) return 0;
	if(n == 1) return 1;
	if(n == 2) return 2;
	if(n == 3) return 4;

	var counts = [0, 1, 2, 4];
	for(var i = 4; i &lt;= n; ++i)
	{
		counts.push(counts[i - 1] + counts[i - 2] + counts[i - 3]);
	}

	return counts[n];
}


/**
 * Returns true if all tests pass; otherwise, returns false.
 */
function doTestsPass()
{
	return countSteps(3) == 4
		&amp;&amp; countSteps(4) == 7
		&amp;&amp; countSteps(1) == 1
		&amp;&amp; countSteps(2) == 2
		&amp;&amp; countSteps(0) == 0
		&amp;&amp; countSteps(-5) == 0
		&amp;&amp; countSteps(10) == 274
		&amp;&amp; countSteps(36) == 2082876103; // Will cause naive solution to time-out
}


/**
 * Execution entry.
 */
if(doTestsPass())
{
	console.log(&quot;All tests pass!&quot;);
}
else
{
	console.log(&quot;There are test failures.&quot;);
}

for(var n = 1; n &lt;= 5; n++)
   console.log(n, &quot; steps =&gt; &quot;, countSteps(n))</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><h1 id="JavaScriptCoderPad-Hard">Hard</h1><h2 id="JavaScriptCoderPad-HashMap">HashMap</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * class MyHashMap
 *
 * Associates a key-value pair in memory such that lookups
 * and inserts can be performed in O(1) time for a reasonably
 * small set of data, and scales linearly (at worst) for larger
 * sets of key-value pairs.
 *
 * Each unique key is associated with one single value.
 */
class MyHashMap {
  
  constructor() {}
 
  put(key, value) {
	// todo: implement
  }
  
  get(key) {
	// todo: implement
	return null;
  }
}

/**
 * bool doTestsPass()
 * Runs various tests.
 */
function doTestsPass() {
  
  // todo: implement more tests, please
  // feel free to make testing more elegant
  const testCases = [[1, 2], [3, 4], [5, 6], [1, 7], [1, 8]];
  
  let passed = true;
  
  const map = new MyHashMap();
  
  for (const test of testCases) {

	const key = test[0];
	const value = test[1];  
	map.put(key, value);
	
	if (value !== map.get(key)) {
	  console.error(`Test failed [${key}, ${value}]`);
	  passed = false;
	}
  }

  return passed;
}

/**
 * Execution entry point.
 */
if (doTestsPass()) {
  console.log(&#39;All tests pass!&#39;);
} else {
  console.log(&#39;There are tests failures.&#39;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">/**
 * class MyHashMap
 *
 * Associates a key-value pair in memory such that lookups
 * and inserts can be performed in O(1) time for a reasonably
 * small set of data, and scales linearly (at worst) for larger
 * sets of key-value pairs.
 *
 * Each unique key is associated with one single value.
 */
class MyHashMap {
  
  constructor() {
	
	this.Entry = class {
	  constructor(key, value) {
		this.key = key;
		this.value = value;
	  }      
	}
	
	this._entries = [];
	// start with 10
	for (let i = 0; i &lt; 10; i++) {
	  // pre-populate the list
	  this._entries.push([]);
	}
  }
 
  // JavaScript has no built-in hash code function.
  _hashCode(value) {
	const strValue = String(value);
	let hash = 0;
	for (let i = 0; i &lt; strValue.length; i++) {
	  const charCode = strValue.charCodeAt(i);
	  hash = ((hash &lt;&lt; 5) - hash) + charCode;
	}
	return hash;
  }
  
  // The % operator in JS can return negative because % is remainder, not modulo.
  // However, none of the test keys are long enough to return a negative hash code,
  // so this can be left as an additional exercise for the candidate.
  _mod(x, n) {
	return ((x % n) + n) % n;
  }
  
  put(key, value) {

	if (key == null || value == null)
	  return;
	
	const idx = this._mod(this._hashCode(key), this._entries.length);
	const list = this._entries[idx];

	for (const entry of list) {
	  if (key === entry.key) {
		entry.value = value;
		return;
	  }
	}
	
	list.push(new this.Entry(key, value));   
  }
  
  get(key) {
	
	if (key == null)
	  return null;
	
	const idx = this._mod(this._hashCode(key), this._entries.length);
	const list = this._entries[idx];
	
	for (const entry of list)
	  if (key === entry.key)
		return entry.value;
	   
	return null;
  }
}

/**
 * bool doTestsPass()
 * Runs various tests.
 */
function doTestsPass() {
  
  // todo: implement more tests, please
  // feel free to make testing more elegant
  const testCases = [[1, 2], [3, 4], [5, 6], [1, 7], [1, 8]];
  
  let passed = true;
  
  const map = new MyHashMap();
  
  for (const test of testCases) {

	const key = test[0];
	const value = test[1];  
	map.put(key, value);
	
	if (value !== map.get(key)) {
	  console.error(`Test failed [${key}, ${value}]`);
	  passed = false;
	}
  }
  
  const strMap = new MyHashMap();
  const strTestCases = [[&quot;one&quot;, &quot;two&quot;], [&quot;three&quot;, &quot;four&quot;], [&quot;one&quot;, &quot;five&quot;]];
  
  for (const test of strTestCases) {

	const key = test[0];
	const value = test[1];
	strMap.put(key, value);
	
	if (value !== strMap.get(key)) {
	  console.error(`Test failed [${key}, ${value}]`);
	  passed = false;
	}    
  }

  return passed;
}

/**
 * Execution entry point.
 */
if (doTestsPass()) {
  console.log(&#39;All tests pass!&#39;);
} else {
  console.log(&#39;There are tests failures.&#39;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-LowestPrice">Lowest Price</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">Question: 
A popular online retailer allows vendors to specify different prices in advance 
for the same item throughout the day. We now need to design an algorithm that 
helps identify the lowest price for the item at any point of the day.
	  
Assumptions:
1) For the algorithm, assume all vendors are selling the same product
and there is only one product being sold. Given an array that has
vendor information - ( startTime, endTime, price ) of the deal,
return a sorted array with different possible intervals and 
the least price of the product during the interval.

2) The interval is inclusive of start and end time. 

3) All the 3 values passed by the vendor are integers.
*/

const _ = require(&#39;lodash&#39;);

class Interval {

  constructor(startTime, endTime, price) {
	this.startTime = startTime;
	this.endTime = endTime;
	this.price = price;
  }
}

function getLowestPrices(inputIntervals) { 
}

/**
   * Returns true if the tests pass. Otherwise, false.
   */
function doTestsPass() {
 
  const sampleInput = [ new Interval( 1, 5, 20 ), new Interval( 3, 8, 15 ), new Interval( 7, 10, 8 ) ];
  const expectedOutput = [ new Interval( 1, 3, 20 ), new Interval( 3, 7, 15 ), new Interval( 7, 10, 8 ) ];
	
  return _.isEqual(expectedOutput, getLowestPrices(sampleInput));
}

/**
 * Main execution entry.
 */
if(doTestsPass()) {
  console.log(&quot;All tests pass!&quot;);
} else {
  console.log(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">const _ = require(&#39;lodash&#39;);

class Interval {

  constructor(startTime, endTime, price) {
	
	if (!_.isInteger(startTime) || !_.isInteger(endTime) || !_.isInteger(price)) {
	  throw &#39;Interval constructor parameters must be integers&#39;
	} else if (startTime &gt;= endTime) {
	  throw &#39;startTime greater than or equal to endTime for an interval&#39;;
	} else if (startTime &lt; 0 || endTime &lt; 0 || price &lt; 0) {
	  throw &#39;vendor information has negative values&#39;;
	}
	
	this.startTime = startTime;
	this.endTime = endTime;
	this.price = price;
  }
}

class BinaryTree {
  
  constructor(interval) {   
	this.interval = interval;   
  }
  
  addNode(interval) {

	if (interval.startTime &lt; this.interval.startTime) {
	  
	  const newInterval = new Interval(interval.startTime,
									   Math.min(interval.endTime, this.interval.startTime),
									   interval.price);
	  
	  if (this.left) {
		this.left.addNode(newInterval);
	  } else {
		this.left = new BinaryTree(newInterval);
	  }
	}
	
	if (interval.endTime &gt; this.interval.endTime) {
	  
	  const newInterval = new Interval(Math.max(interval.startTime, this.interval.endTime),
									   interval.endTime,
									   interval.price);
	  
	  if (this.right) {
		this.right.addNode(newInterval);
	  } else {
		this.right = new BinaryTree(newInterval);
	  }
	}    
  }
  
  _traverse(results) {
	if (this.left) {
	  this.left._traverse(results);
	}
	results.push(this.interval);
	if (this.right) {
	  this.right._traverse(results);
	}
  }
  
  inOrder() {
	const results = [];
	this._traverse(results);
	return results;
  }
}

function getLowestPrices(inputIntervals) {
  
  if (!Array.isArray(inputIntervals) || inputIntervals.length === 0) {
	throw &#39;inputIntervals has 0 elements&#39;;
  }
  
  inputIntervals.forEach(element =&gt; {
	if (!(element instanceof Interval)) {
	  throw &#39;inputIntervals contains an invalid element&#39;;
	}
  });
  
  inputIntervals.sort((a, b) =&gt; a.price - b.price);
  
  const root = inputIntervals[0];
  const tree = new BinaryTree(root);
  for (let i = 1; i &lt; inputIntervals.length; i++) {
	tree.addNode(inputIntervals[i]);
  }
  
  return tree.inOrder();
}

/**
   * Returns true if the tests pass. Otherwise, false.
   *
   * Additional Test Cases:
   *   Input : ( 1, 20 13 ), ( 7, 10, 8 ), ( 3, 8, 15 ), ( 1, 5, 20 )
   *   Output: ( 1, 7, 13 ), ( 7, 10, 8 ), ( 10, 20, 13 )
   *
   *   Input : ( 7, 10, 8 ), ( 3, 8, 15 ), ( 1, 5, 20 ), ( 1, 20, 4 )
   *   Output: ( 1, 20, 4 )
   *
   *   Input : ( 3, 6, 2 ), ( 1, 9, 3 ), ( 5, 8, 1 )
   *   Output: ( 1, 3, 3 ), ( 3, 5, 2 ), ( 5, 8, 1 ), ( 8, 9, 3 )
   */
function doTestsPass() {
 
  try {
	const sampleInput = [ new Interval( 1, 5, 20 ), new Interval( 3, 8, 15 ), new Interval( 7, 10, 8 ) ];
	const expectedOutput = [ new Interval( 1, 3, 20 ), new Interval( 3, 7, 15 ), new Interval( 7, 10, 8 ) ];
	
	return _.isEqual(expectedOutput, getLowestPrices(sampleInput));

  } catch (e) {

	console.error(e);
  }
  
  return false;
}

/**
 * Main execution entry.
 */
if(doTestsPass()) {
  console.log(&quot;All tests pass!&quot;);
} else {
  console.error(&quot;There are test failures.&quot;);
}</pre>
</div></div></td></tr></tbody></table></div><h2 id="JavaScriptCoderPad-PrefixSearch">Prefix Search</h2><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">const _ = require(&#39;lodash&#39;);

class MyPrefixSearch {
 
  constructor(document) {
	this._document = document;
  }
  
  /*
   * findAll: Return a list of all locations in a document where the
   * (case insensitive) word begins with the given prefix.
   *
   * Example:  given the document &quot;a aa Aaa abca bca&quot;,
   *   1) findAll(&quot;a&quot;)   -&gt; [0, 2, 5, 9]
   *   2) findAll(&quot;bc&quot;)  -&gt; [14]
   *   3) findAll(&quot;aA&quot;)  -&gt; [2, 5]
   *   4) findAll(&quot;abc&quot;) -&gt; [9]
   *
   **/  
  findAll(prefix) {
	// TODO: Implement this function
	return null;
  }
}

/*********  Tests  *********/

/*
 * doTestsPass
 * Validate that the prefix search returns the correct results for the sample document.
 */
function doTestsPass() {
  
  const document =
	&quot;In publishing and graphic design, lorem ipsum is a &quot; +
	&quot;filler text commonly used to demonstrate the graphic elements of a &quot; +
	&quot;document or visual presentation. Replacing meaningful content that &quot; +
	&quot;could be distracting with placeholder text may allow viewers to focus &quot; +
	&quot;on graphic aspects such as font, typography, and page layout. It also &quot; +
	&quot;reduces the need for the designer to come up with meaningful text, as &quot; +
	&quot;they can instead use hastily generated lorem ipsum text. The lorem &quot; +
	&quot;ipsum text is typically a scrambled section of De finibus bonorum et &quot; +
	&quot;malorum, a 1st-century BC Latin text by Cicero, with words altered, &quot; +
	&quot;added, and removed to make it nonsensical, improper Latin. A variation &quot; +
	&quot;of the ordinary lorem ipsum text has been used in typesetting since &quot; +
	&quot;the 1960s or earlier, when it was popularized by advertisements for &quot; +
	&quot;Letraset transfer sheets. It was introduced to the Information Age in &quot; +
	&quot;the mid-1980s by Aldus Corporation, which employed it in graphics and &quot; +
	&quot;word processing templates for its desktop publishing program, &quot; +
	&quot;PageMaker, for the Apple Macintosh. A common form of lorem ipsum &quot; +
	&quot;reads: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do &quot; +
	&quot;eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad &quot; +
	&quot;minim veniam, quis nostrud exercitation ullamco laboris nisi ut &quot; +
	&quot;aliquip ex ea commodo consequat. Duis aute irure dolor in &quot; +
	&quot;reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla &quot; +
	&quot;pariatur. Excepteur sint occaecat cupidatat non proident, sunt in &quot; +
	&quot;culpa qui officia deserunt mollit anim id est laborum.&quot;;
   
  const prefixSearch = new MyPrefixSearch(document);

  return (
	_.isEqual(prefixSearch.findAll(&quot;demonstrate&quot;), [ 80 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;pub&quot;), [ 3, 988 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;publishing&quot;), [ 3, 988 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;lab&quot;), [ 1173, 1263, 1517 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;laborum&quot;), [ 1517 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;in&quot;), [ 0, 404, 717, 839, 857, 873, 930, 1159, 1334, 1351, 1468 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;lor&quot;), [ 34, 434, 456, 686, 1061, 1080 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;l&quot;), [ 34, 309, 434, 456, 557, 651, 686, 806, 1061, 1080, 1173, 1263, 1517 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;&quot;), []) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;hamburger&quot;), []));
}

/**
 * Execution entry point.
 */
if (doTestsPass()) {
  console.log(&#39;All tests pass!&#39;);
} else {
  console.log(&#39;There are tests failures.&#39;);
}</pre>
</div></div></td></tr></tbody></table></div><p><br/></p><div class="table-wrap"><table data-layout="default" class="confluenceTable"><tbody><tr><td data-highlight-colour="#ffffff" class="confluenceTd"><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Confluence" data-theme="Confluence">const _ = require(&#39;lodash&#39;);

class MyTrie {

  constructor(character) {
	this._character = character;
	this._locations = [];
	this._nodes = {};
  }

  // record a substring location.
  add(chars, location) {
	if (!_.isString(chars))
	  throw new TypeError(&#39;chars must be a string&#39;);
	if (!_.isNumber(location))
	  throw new TypeError(&#39;location must be a number&#39;);

	if (this._character != null)
	  // note: this trie variant records at each node, not just leaf nodes (simpler, less space efficient).
	  this._locations.push(location);
	if (chars.length &gt; 0) {
	  const c = chars.charAt(0);
	  if (!(c in this._nodes))
		this._nodes[c] = new MyTrie(c);
	  this._nodes[c].add(chars.substring(1), location);
	}
  }

  // retrieve locations for substring
  get(prefix) {
	if (!_.isString(prefix))
	  throw new TypeError(&#39;prefix must be a string&#39;);
	if (prefix.length &gt; 0) {
	  const c = prefix.charAt(0);
	  if (c in this._nodes)
		return this._nodes[c].get(prefix.substring(1));
	  else
		return [];
	} else {
	  return this._locations;
	}
  }
}

class MyPrefixSearch {
  // Note: Any indexed solution should be more performant on repeat calls.
  // Trade-offs arise on how to store the index efficiently while maintaining fast lookup.
  // This solution is indexed using a trie, which is also space efficient for certain use cases.
  // For a light discussion on tries and other alternative implementations see:
  //    https://www.toptal.com/java/the-trie-a-neglected-data-structure
 
  constructor(document) {

	if (!_.isString(document))
	  throw new TypeError(&#39;document must be a string&#39;);

	this._index = new MyTrie(null);
	this._buildIndex(document);
  }
  
  _buildIndex(document) {

	let location = 0;
	const words = document.split(&#39; &#39;);
	for (const word of words) {
	  if (word.length &gt; 0) { // could be an extra whitespace, leading to a &quot;&quot; token
		const clean = word.toLowerCase().replace(/[\W_]+/g, &#39;&#39;);
		this._index.add(clean, location);
	  }
	  location += word.length + 1;
	}
  }

  /*
   * findAll: Return a list of all locations in a document where the
   * (case insensitive) word begins with the given prefix.
   *
   * Example:  given the document &quot;a aa Aaa abca bca&quot;,
   *   1) findAll(&quot;a&quot;)   -&gt; [0, 2, 5, 9]
   *   2) findAll(&quot;bc&quot;)  -&gt; [14]
   *   3) findAll(&quot;aA&quot;)  -&gt; [2, 5]
   *   4) findAll(&quot;abc&quot;) -&gt; [9]
   *
   **/  
  findAll(prefix) {
	return this._index.get(prefix);
  }
}

/*********  Tests  *********/

/*
 * doTestsPass
 * Validate that the prefix search returns the correct results for the sample document.
 */
function doTestsPass() {
  
  const document =
	&quot;In publishing and graphic design, lorem ipsum is a &quot; +
	&quot;filler text commonly used to demonstrate the graphic elements of a &quot; +
	&quot;document or visual presentation. Replacing meaningful content that &quot; +
	&quot;could be distracting with placeholder text may allow viewers to focus &quot; +
	&quot;on graphic aspects such as font, typography, and page layout. It also &quot; +
	&quot;reduces the need for the designer to come up with meaningful text, as &quot; +
	&quot;they can instead use hastily generated lorem ipsum text. The lorem &quot; +
	&quot;ipsum text is typically a scrambled section of De finibus bonorum et &quot; +
	&quot;malorum, a 1st-century BC Latin text by Cicero, with words altered, &quot; +
	&quot;added, and removed to make it nonsensical, improper Latin. A variation &quot; +
	&quot;of the ordinary lorem ipsum text has been used in typesetting since &quot; +
	&quot;the 1960s or earlier, when it was popularized by advertisements for &quot; +
	&quot;Letraset transfer sheets. It was introduced to the Information Age in &quot; +
	&quot;the mid-1980s by Aldus Corporation, which employed it in graphics and &quot; +
	&quot;word processing templates for its desktop publishing program, &quot; +
	&quot;PageMaker, for the Apple Macintosh. A common form of lorem ipsum &quot; +
	&quot;reads: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do &quot; +
	&quot;eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad &quot; +
	&quot;minim veniam, quis nostrud exercitation ullamco laboris nisi ut &quot; +
	&quot;aliquip ex ea commodo consequat. Duis aute irure dolor in &quot; +
	&quot;reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla &quot; +
	&quot;pariatur. Excepteur sint occaecat cupidatat non proident, sunt in &quot; +
	&quot;culpa qui officia deserunt mollit anim id est laborum.&quot;;
   
  const prefixSearch = new MyPrefixSearch(document);
  
  return (
	_.isEqual(prefixSearch.findAll(&quot;demonstrate&quot;), [ 80 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;pub&quot;), [ 3, 988 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;publishing&quot;), [ 3, 988 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;lab&quot;), [ 1173, 1263, 1517 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;laborum&quot;), [ 1517 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;in&quot;), [ 0, 404, 717, 839, 857, 873, 930, 1159, 1334, 1351, 1468 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;lor&quot;), [ 34, 434, 456, 686, 1061, 1080 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;l&quot;), [ 34, 309, 434, 456, 557, 651, 686, 806, 1061, 1080, 1173, 1263, 1517 ]) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;&quot;), []) &amp;&amp;
	_.isEqual(prefixSearch.findAll(&quot;hamburger&quot;), []));
}

/**
 * Execution entry point.
 */
if (doTestsPass()) {
  console.log(&#39;All tests pass!&#39;);
} else {
  console.log(&#39;There are tests failures.&#39;);
}</pre>
</div></div></td></tr></tbody></table></div>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Feb 12, 2021 23:35</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
