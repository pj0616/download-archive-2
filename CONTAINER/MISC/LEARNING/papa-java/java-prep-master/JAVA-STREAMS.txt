============================================================================
                                    Arrays
============================================================================
int[] to Collection<Integer>
    List<Integer> list = Arrays.stream(a).boxed().collect(Collectors.toList());
    Set<Integer> set = Arrays.stream(a).boxed().collect(Collectors.toSet()));
    PriorityQueue<Integer> pq = new PriorityQueue<>(Arrays.stream(ar).boxed().collect(Collectors.toList()));

int[][] to int[]
    int[] ar = Arrays.stream(data).flatMapToInt(Arrays::stream).toArray();

int[] to Integer[]
    Integer[] result = IntStream.of(ar).boxed().toArray(Integer[]::new);

Integer[] to int[]
    Arrays.stream(result).mapToInt(i -> i).toArray();

List<Integer> to int[]
    list.stream().mapToInt(i -> i).toArray();

String[] to int[]
     Arrays.stream(vals).mapToInt(Integer::valueOf).toArray();

int[] to String[]
    Arrays.stream(a).mapToObj(String::valueOf).toArray(String[]::new);

Create array of consecutive ints (reverse order)
    int[] arr = IntStream.rangeClosed(0, 1000).toArray();
    IntStream.rangeClosed(from, to).map(i -> to - i + from).toArray();

Fill array with random integers
    new Random().ints(size, from, to).toArray();

Extract dimension from 2D array
    Arrays.stream(input).map(i -> i[dim]).toArray(String[]::new);

Sort 2D Arrays by some column (dimension)
    Arrays.sort(arr, Comparator.comparingInt((int [] a) -> a[0]));

Count occurences of certain value in int[]
    Arrays.stream(a).filter(i -> i == 0).count();

max/min in int[]
    Arrays.stream(ar).max().getAsInt()
    Arrays.stream(ar).reduce(Integer::max).getAsInt();

sum int[]
    Arrays.stream(a).sum();
    Arrays.stream(a).reduce(0, Integer::sum);

product of int[]
    Arrays.stream(a).reduce(1, (a, b) -> a * b);

Remove duplicates from int[]
    Arrays.stream(a).distinct().toArray();

Separate int[] into negative and positive
    Map<Boolean, List<Integer>> map = Arrays.stream(a).boxed().collect(Collectors.partitioningBy(x -> x > 0));
    int[] pos = map.get(true).stream().mapToInt(i -> i).toArray();
    int[] neg = map.get(false).stream().mapToInt(i -> i).toArray();

Remove certain values from int[]
    Arrays.stream(a).filter(x -> x != val).toArray();

Find nth largest/smallest value in int[]
    Arrays.stream(a).boxed().sorted(Comparator.reverseOrder()).mapToInt(x -> x).limit(n).toArray()[n - 1];
    Arrays.stream(a).boxed().sorted(Comparator.naturalOrder()).mapToInt(x -> x).limit(n).toArray()[n - 1];

Range of numbers to char[]
     IntStream.range(0, 3). mapToObj(c -> Character.toString((char) (c + 'a'))).collect(Collectors.joining()).toCharArray();

int[][] To Map<Integer,Set<Integer>>
    Map<Integer,Set<Integer>> xMap = Arrays.stream(points).collect(
      HashMap::new,
      (map, item) -> map.computeIfAbsent(item[0], e -> new HashSet<>()).add(item[1]),
      HashMap::putAll);

Combine values from two int[]
    int [] left = ...
    int [] right = ...
    int[] sumArray = new int[left.length];
    Arrays.setAll(sumArray, i -> left[i] + right[i]);

Range of numbers to char[]. For example: 5 to {'a', 'b', 'c', 'd', 'e'}
    IntStream.range(0, m)
    .mapToObj(c -> Character.toString((char) (c + 'a')))
    .collect(Collectors.joining())
    .toCharArray();

char[] to List<Character>. Convert to String first.
    String colorStr = new String(colors);
    List<Character> allColors = colorStr.chars().mapToObj(c -> (char) c).collect(Collectors.toList());

sort int[] descending
    Integer[] boxedInts = IntStream.of(ar).boxed().toArray(Integer[]::new);
    Arrays.sort(boxedInts, Collections.reverseOrder());
    int[] sortedDesc = Arrays.stream(boxedInts).mapToInt(i -> i).toArray();
============================================================================
                                    Strings
============================================================================
String to List<Character>
    colorStr.chars().mapToObj(c -> (char) c).collect(Collectors.toList());

String to Character[]
    Character[] ar = s.chars().mapToObj(c ->(char)c).toArray(Character[]::new);
    IntStream.range(0, s.length()).mapToObj(s::charAt).toArray(Character[]::new);

Character[] to String
    Arrays.stream(ar).map(Object::toString).collect(Collectors.joining());

String[] to String
    Arrays.stream(words).collect(Collectors.joining(" "));
    Arrays.stream(words).collect(Collectors.joining());

String to String after performing some operations
    s.chars().filter(x -> remove.indexOf(x) == -1).mapToObj(c -> (char)c).map(String::valueOf).collect(Collectors.joining());
    s.chars().mapToObj(c -> (char)c).distinct().map(String::valueOf).collect(Collectors.joining());

String to Stream<Character>
    s.chars().mapToObj(e -> (char)e);
    IntStream.range(0, s.length()).mapToObj(s::charAt);

Stream<Character> to String
    charStream.map(String::valueOf).collect(Collectors.joining());

Find longest string in the list
    list.stream().max(Comparator.comparingInt(String::length)).get();

============================================================================
                                    Maps
============================================================================
Track number of occurrences
    Map<Integer,Integer> map = new HashMap<>();
    map.merge(a[i], 1, Integer::sum);
    or:
    map.merge(a[i], 1, (count, incr) -> count + incr);

String[][] to Map<String,Set<String>>
    Map<String, Set<String>> pathMap = Arrays.stream(paths).collect(
        HashMap::new,
        (map, item) -> map.computeIfAbsent(item[0], e -> new HashSet<>()).add(item[1]),
        HashMap::putAll);

String[] to Map of word counts
    Map<String,Long> countMap = Arrays.stream(names).collect(
        Collectors.groupingBy(Function.identity(), Collectors.counting()));

int[] to Map of word counts
    Map<Integer,Long> countMap = Arrays.stream(ar).boxed().collect(
        Collectors.groupingBy(Function.identity(), Collectors.counting()));

Reverse Map keys and values
    input.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey)
    input.entrySet().stream().collect(
     HashMap<Integer,String>::new,
     (map, e) -> map.put(e.getValue(), e.getKey()),
     HashMap<Integer,String>::putAll);

Apply filter to map, keep only sets with at least one items
    xMap = xMap.entrySet().stream().filter(e -> e.getValue().size() > 1).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
============================================================================
                                    Collections
============================================================================
List<List<X>> to List<X>
    result.stream().flatMap(List::stream).collect(Collectors.toList());

============================================================================
                                    Streams
============================================================================
Create stream of values
    Stream<String> stream = Stream.of("Java8", "Lambdas", "In", "Action");

Stream<E> to Iterable<E>
    public static <E> Iterable<E> iterableOf(Stream<E> stream)
    {
      return stream::iterator;
    }

Iterable<E> to Stream<E>
    public static <E> Stream<E> streamOf(Iterable<E> iterable)
    {
      return StreamSupport.stream(iterable.spliterator(), false);
    }

============================================================================
                                    Objects
============================================================================
Sum by field of some type
	int totalCalories = menu.stream().mapToInt(Dish::getCalories).sum();
	int totalCalories = menu.stream().collect(Collectors.summingInt(Dish::getCalories));

Find max/min by field of some type
	Optional<Dish> mostCalorieDish = menu.stream().collect(maxBy(comparingInt(Dish::getCalories)));
	OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();
	Optional<Integer> max = menu.stream().mapToInt(Dish::getCalories).reduce(Integer::max);

Group by some field
    Map<Dish.Type,List<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType));
    Map<Dish.Type, Set<Dish>> dishesByType = menu.stream().collect(groupingBy(Dish::getType, toSet()));

Count number of items in each subgroup
    Map<Dish.Type, Long> typesCount = menu.stream().collect(groupingBy(Dish::getType, counting()));

Sum number of items in each subgroup
    Map<Dish.Type, Integer> totalCaloriesByType = menu.stream().collect(groupingBy(Dish::getType, summingInt(Dish::getCalories)));

Find max/min by type
    Map<Dish.Type, Optional<Dish>> mostCaloricByType = menu.stream().collect(groupingBy(Dish::getType, maxBy(comparingInt(Dish::getCalories))));
    Map<Dish.Type, Dish> mostCaloricByType = menu.stream().collect(groupingBy(Dish::getType, collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get)));

Sort by some criteria
    List<String> names = menu.stream().sorted(comparing(Dish::getCalories)).map(Dish.getName).collect(Comparators.toList());

Reverse Sort Order
    inventory.sort(comparing(Apple::getWeight).reversed());

Chain comparators
    inventory.sort(comparing(Apple::getWeight).reversed().thenComparing(Apple::getCountry);
